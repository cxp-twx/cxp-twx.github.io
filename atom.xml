<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cxp-twx.github.io</id>
    <title>CheckChen</title>
    <updated>2019-12-13T02:44:53.902Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cxp-twx.github.io"/>
    <link rel="self" href="https://cxp-twx.github.io/atom.xml"/>
    <subtitle>吾日三省吾身</subtitle>
    <logo>https://cxp-twx.github.io/images/avatar.png</logo>
    <icon>https://cxp-twx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, CheckChen</rights>
    <entry>
        <title type="html"><![CDATA[SpringMVC详细总结]]></title>
        <id>https://cxp-twx.github.io/post/springmvc-xiang-xi-zong-jie</id>
        <link href="https://cxp-twx.github.io/post/springmvc-xiang-xi-zong-jie">
        </link>
        <updated>2019-09-09T08:50:08.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#springmvc">SpringMVC</a>
<ul>
<li><a href="#mvc%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">MVC设计模式</a></li>
<li><a href="#springmvc%E7%9A%84%E4%BC%98%E5%8A%BF">SpringMVC的优势</a></li>
<li><a href="#springmvc%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8">SpringMVC简单使用</a></li>
<li><a href="#springmvc%E4%B8%BB%E8%A6%81%E7%BB%84%E4%BB%B6">SpringMVC主要组件</a>
<ul>
<li><a href="#rootapplicationcontext%E5%92%8Cservletapplicationcontext">RootApplicationContext和ServletApplicationContext</a>
<ul>
<li><a href="#%E4%B8%A4%E4%B8%AAapplicationcontext%E7%9A%84%E8%81%94%E7%B3%BB%E5%92%8C%E5%8C%BA%E5%88%AB">两个ApplicationContext的联系和区别</a></li>
</ul>
</li>
<li><a href="#1-%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">1. 视图解析器</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E5%99%A8">常用的视图解析器</a></li>
</ul>
</li>
<li><a href="#2-%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">2. 参数传递</a>
<ul>
<li><a href="#%E9%A1%B5%E9%9D%A2%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%88%B0controller">页面参数传递到Controller</a>
<ul>
<li><a href="#requestparam">@RequestParam</a></li>
<li><a href="#requestheader">@RequestHeader</a></li>
<li><a href="#pathvariable">@PathVariable</a></li>
<li><a href="#requestattribute">@RequestAttribute</a></li>
<li><a href="#sessionattribute">@SessionAttribute</a></li>
<li><a href="#cookievalue">@CookieValue</a></li>
</ul>
</li>
<li><a href="#controller%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92%E5%88%B0%E9%A1%B5%E9%9D%A2">Controller中的数据传递到页面</a>
<ul>
<li><a href="#model">Model</a></li>
<li><a href="#modelandview">ModelAndView</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#3-%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8">3. 视图控制器</a>
<ul>
<li><a href="#%E8%A7%86%E5%9B%BE%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%94%A8%E6%B3%95">视图控制器的作用和用法</a></li>
</ul>
</li>
<li><a href="#4-%E8%AE%BE%E7%BD%AEweb%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%BB%98%E8%AE%A4%E6%AC%A2%E8%BF%8E%E9%A1%B5">4. 设置Web项目的默认欢迎页</a>
<ul>
<li><a href="#%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E5%A4%84%E7%90%86">静态资源处理</a></li>
</ul>
</li>
<li><a href="#5-%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91">5. 重定向和转发</a>
<ul>
<li><a href="#%E5%9C%A8servlet%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91">在Servlet实现重定向和转发：</a></li>
<li><a href="#%E5%9C%A8springmvc%E4%B8%AD%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E5%A5%BD%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91">在SpringMVC中请求转发好和重定向</a>
<ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E6%9C%89%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">请求转发有三种方式</a></li>
<li><a href="#%E9%87%8D%E5%AE%9A%E5%90%91%E6%9C%89%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F">重定向有两种方式</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#6-restfull%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91">6. RESTFull服务接口开发</a>
<ul>
<li><a href="#%E5%B8%B8%E7%94%A8restfull%E6%B3%A8%E8%A7%A3">常用RESTFull注解</a></li>
</ul>
</li>
<li><a href="#7-%E8%BF%94%E5%9B%9Ejson%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%95%B0%E6%8D%AE-%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">7. 返回JSON格式的数据--消息转换器</a><br>
*
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88">消息转换器是什么</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AA%E8%BD%AC%E6%8D%A2json%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%B6%88%E6%81%AF%E8%BD%AC%E6%8D%A2%E5%99%A8">如何配置一个转换JSON格式的消息转换器</a></li>
</ul>
</li>
<li><a href="#8-%E9%80%9A%E8%BF%87%E7%BD%91%E9%A1%B5%E6%A8%A1%E6%8B%9Frestfull%E8%AF%B7%E6%B1%82">8. 通过网页模拟RESTFull请求</a>
<ul>
<li><a href="#resttemplate%E5%B7%A5%E5%85%B7%E7%B1%BB">RestTemplate工具类</a></li>
</ul>
</li>
<li><a href="#9-%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E4%B9%B1%E7%A0%81">9. 处理请求乱码</a></li>
<li><a href="#10-%E5%9C%A8springmvc%E6%96%B9%E6%B3%95%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%84%E5%8F%82%E6%95%B0">10. 在SpringMVC方法中支持的参数</a><br>
*
<ul>
<li><a href="#%E6%B3%A8%E5%85%A5%E5%8E%9F%E7%94%9Fservlet%E5%AF%B9%E8%B1%A1">注入原生Servlet对象</a></li>
<li><a href="#%E4%BB%A5%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93-%E4%BB%A5%E6%B5%81%E7%9A%84%E6%96%B9%E5%BC%8F%E5%93%8D%E5%BA%94%E5%88%B0%E5%AE%A2%E6%88%B7%E7%AB%AF">以流的方式读取请求体、以流的方式响应到客户端</a></li>
<li><a href="#%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82%E4%BD%93%E5%92%8C%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%95%B0%E6%8D%AE">读取请求体和请求头数据</a></li>
<li><a href="#%E5%90%91%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%8F%82">向页面传参</a></li>
</ul>
</li>
<li><a href="#11-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">11. 文件上传</a>
<ul>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Eapache-fileupload%E9%80%9A%E7%94%A8%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8C%85">基于Apache Fileupload通用文件上传包</a></li>
<li><a href="#%E5%9F%BA%E4%BA%8Eservlet30%E6%A0%87%E5%87%86api%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">基于Servlet3.0标准API文件上传</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E5%90%8D%E4%B8%8A%E4%BC%A0%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98">文件名上传乱码问题</a></li>
</ul>
</li>
<li><a href="#12-%E6%8B%A6%E6%88%AA%E5%99%A8">12. 拦截器</a>
<ul>
<li><a href="#%E6%8B%A6%E6%88%AA%E5%99%A8-vs-%E8%BF%87%E6%BB%A4%E5%99%A8">拦截器 VS 过滤器</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E6%8B%A6%E6%88%AA%E5%99%A8">如何使用拦截器</a>
<ul>
<li><a href="#%E5%AE%9A%E4%B9%89%E6%8B%A6%E6%88%AA%E5%99%A8%E7%B1%BB">定义拦截器类</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%8B%A6%E6%88%AA%E5%99%A8">配置拦截器</a>
<ul>
<li><a href="#%E5%85%A8%E5%B1%80%E6%8B%A6%E6%88%AA%E5%99%A8">全局拦截器</a></li>
<li><a href="#%E6%8B%A6%E6%88%AA%E6%8C%87%E5%AE%9A%E8%AF%B7%E6%B1%82%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8">拦截指定请求的拦截器</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#springmvc%E5%87%BA%E9%94%99%E7%82%B9">SpringMVC出错点：</a>
<ul>
<li><a href="#%E5%B1%95%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE">展示数据库数据：</a></li>
<li><a href="#springmvc%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%94%BE%E8%A1%8C">SpringMVC静态资源放行</a></li>
<li><a href="#spring-mvc%E7%9A%84controller%E5%B1%82%E8%8E%B7%E5%8F%96jsp%E9%A1%B5%E9%9D%A2%E5%8F%82%E6%95%B0">Spring MVC的controller层获取jsp页面参数</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="springmvc">SpringMVC</h1>
<h2 id="mvc设计模式">MVC设计模式</h2>
<blockquote>
<ul>
<li>MVC里面的M指的是：
<ul>
<li>Model（通常包含bean、dao(mapper)、service）；</li>
</ul>
</li>
<li>V指的是
<ul>
<li>View：视图层，视图层主要的技术（JSP、HTML、FreeMaker、Themeleaf）；</li>
</ul>
</li>
<li>C指的是
<ul>
<li>Controller，控制层。控制层不负责具体数据、逻辑的处理和运算，它只负责将Model层的结果返回给对应的视图层去展示。</li>
</ul>
</li>
</ul>
<p>在JavaWeb阶段， Controller层指的就是Servlet； View层指的就是JSP或者HTML;  Model层指的就是bean、dao、service。</p>
<p>在J2EE阶段，Controller层指的就是SpringMVC、Structs1\2；  View层不变还是主流的页面展示技术; Model层包括bean、mybatis、service。</p>
</blockquote>
<h2 id="springmvc的优势">SpringMVC的优势</h2>
<ul>
<li>SpringMVC是一款很轻量级的框架，要使用它的组件我们往往只需要定义一些最简单的Java类，然后添加某些注解就可以了</li>
<li>SpringMVC的参数注入只直接注入到方法中，可以很好的做到不同请求间数据的隔离，而Struts2是注入到类实例变量上，不同的请求可能会覆盖参数。</li>
<li>SpringMVC可以很轻易的和Spring整合，而Struts需要做比较复杂的配置。</li>
</ul>
<h2 id="springmvc简单使用">SpringMVC简单使用</h2>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在web.xml中配置DispatcherServlet</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 指定SpringMVC 配置文件位置，DispatcherServlet初始化时会初始化Spring上下文（WebApplicationContext） --&gt;
    &lt;!-- 默认配置文件寻找位置：/WEB-INF/{servlet-name}-servlet.xml，如果名字符合默认寻找规则，可以不指定配置文件路径 --&gt;
    &lt;!--&lt;init-param&gt;
      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
      &lt;param-value&gt;/WEB-INF/aa-servlet.xml&lt;/param-value&gt;
    &lt;/init-param&gt;--&gt;
    &lt;!-- 配置容器启动时初始化DispatcherServlet --&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;aa&lt;/servlet-name&gt;
    &lt;!-- 映射路径配置成/，代表当前Servlet是一个默认Servlet，就是当其他Servlet都无法处理请求时，由默认Servlet出马 --&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;!--    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;--&gt;
  &lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC  dispatcher-servlet.xml</p>
<p>SpringMVC大部分组件都有默认配置，我们一般简单应用只需要指定视图解析器就行了</p>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
<li>
<p>定义Controller</p>
<p>新建一个普通类，然后添加<code>@Controller</code>注解，就可以了</p>
</li>
<li>
<p>定义请求处理方法(Handler)</p>
<p>在Controller类中定义一个普通的方法，添加<code>@RequestMapping</code>注解就可以了</p>
</li>
</ol>
<h2 id="springmvc主要组件">SpringMVC主要组件</h2>
<ul>
<li>
<h3 id="rootapplicationcontext和servletapplicationcontext">RootApplicationContext和ServletApplicationContext</h3>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9kb2NzLnNwcmluZy5pby9zcHJpbmcvZG9jcy81LjIuMC5SRUxFQVNFL3NwcmluZy1mcmFtZXdvcmstcmVmZXJlbmNlL2ltYWdlcy9tdmMtY29udGV4dC1oaWVyYXJjaHkucG5n?x-oss-process=image/format,png" alt="父子上下文概念"></figure>
<ul>
<li>
<h4 id="两个applicationcontext的联系和区别">两个ApplicationContext的联系和区别</h4>
</li>
</ul>
<h3 id="1-视图解析器">1. 视图解析器</h3>
<p>视图解析器的作用是将请求处理方法中的返回值解析成一个真正可以渲染的页面。</p>
<h4 id="常用的视图解析器">常用的视图解析器</h4>
<ul>
<li>
<p>InternalResourceViewResolver</p>
<p>内部资源解析器： 用于将返回值对应到项目路径下的某个可显示的页面。比如方法返回值是index字符串，那么<code>InternalResourceViewResolver</code>解析器会在index前加上指定的前缀，在index后加上指定的后缀来拼接成指向某个视图的路径。</p>
<pre><code class="language-xml">&lt;!-- 配置视图解析器，用于将Handler方法中返回的视图名解析成真正可展示的页面 --&gt;
&lt;mvc:view-resolvers&gt;
    &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
        &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
        &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
    &lt;/bean&gt;
&lt;/mvc:view-resolvers&gt;
</code></pre>
</li>
</ul>
<h3 id="2-参数传递">2. 参数传递</h3>
<h4 id="页面参数传递到controller">页面参数传递到Controller</h4>
<ul>
<li>
<h5 id="requestparam">@RequestParam</h5>
</li>
</ul>
<p>获取请求参数，包括通过GET请求中的查询参数、POST请求中的参数等</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam String message, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestParam(&quot;message&quot;) String msg, Model model) {
	model.addAttribute(&quot;msg&quot;, message);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问: http://localhost:8080/hello?message=zhangsan 时，message参数会自动注入到方法的message参数中。</p>
</blockquote>
<ul>
<li>
<h5 id="requestheader">@RequestHeader</h5>
</li>
</ul>
<p>获取请求头中的参数，如浏览器默认自带的userAgent就是请求头参数</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader String userAgent, Model model) {
	model.addAttribute(&quot;msg&quot;, userAgent);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求头参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello&quot;)
public String toHelloPage(@RequestHeader(&quot;userAgent&quot;) String ua, Model model) {
	model.addAttribute(&quot;msg&quot;, ua);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>会自动将请求头中的userAgent参数注入到方法中</p>
</blockquote>
<ul>
<li>
<h5 id="pathvariable">@PathVariable</h5>
</li>
</ul>
<p>获取请求地址中的参数，注入到方法参数中</p>
<pre><code class="language-java">@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable String sname, Model model) {
	model.addAttribute(&quot;msg&quot;, sname);
	return &quot;hello_springmvc&quot;;
}


// 当方法参数名和请求地址中参数不一样时，可以使用注解的参数对应起来
@RequestMapping(&quot;/hello/{sname}&quot;)
public String toHelloPage(@PathVariable(&quot;sname&quot;) String sn, Model model) {
	model.addAttribute(&quot;msg&quot;, sn);
	return &quot;hello_springmvc&quot;;
}
</code></pre>
<blockquote>
<p>访问：http://localhost:8080/hello/zhangsan  会自动将zhangsan注入到方法的参数中</p>
</blockquote>
<ul>
<li>
<h5 id="requestattribute">@RequestAttribute</h5>
</li>
</ul>
<p>jsp中</p>
<pre><code class="language-jsp">&lt;%
        request.setAttribute(&quot;sname&quot;, &quot;虞姬req&quot;);
        request.getRequestDispatcher(&quot;/param/req_scope&quot;).forward(request, response);
%&gt;
</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * 请求作用域中的参数的传递
  * @return
  */
@RequestMapping(&quot;/req_scope&quot;)
public String requestScopeParamShow(@RequestAttribute String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;请求作用域参数&quot;);
    return &quot;param_show&quot;;
}
</code></pre>
<blockquote>
<p>获取请求作用域中的参数</p>
</blockquote>
<ul>
<li>
<h5 id="sessionattribute">@SessionAttribute</h5>
</li>
</ul>
<blockquote>
<p>获取Session作用域中的参数，用法和上面请求作用域中使用类似</p>
</blockquote>
<ul>
<li>
<h5 id="cookievalue">@CookieValue</h5>
</li>
</ul>
<p>jsp中代码</p>
<pre><code class="language-jsp">cookie参数传递：&lt;br /&gt;
&lt;%
response.addCookie(new Cookie(&quot;sname&quot;, &quot;yuji_cookie&quot;));
%&gt;
&lt;a href=&quot;/param/cookie&quot;&gt;发起请求&lt;/a&gt;

</code></pre>
<p>Controller中</p>
<pre><code class="language-java">/**
  * Cookie中的参数的传递
  * @return
  */
@RequestMapping(&quot;/cookie&quot;)
public String cookieParamShow(@CookieValue String sname, Model model) {
    model.addAttribute(&quot;sname&quot;, sname);
    model.addAttribute(&quot;type&quot;, &quot;cookie参数&quot;);
    return &quot;param_show&quot;;
}

</code></pre>
<blockquote>
<p>获取Cookie中的指定数据</p>
</blockquote>
<blockquote>
<p>上面这几个注解都是用于在方法的参数上标注，用于获取不同种类的参数</p>
</blockquote>
<h4 id="controller中的数据传递到页面">Controller中的数据传递到页面</h4>
<ul>
<li>
<h5 id="model">Model</h5>
</li>
</ul>
<p>handler方法定义：</p>
<pre><code class="language-java">@RequestMapping(&quot;/show_msg&quot;)
public String showMessage(Model model) {
    model.addAttribute(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    return &quot;message_page&quot;;
}
</code></pre>
<p>message_page.jsp</p>
<pre><code class="language-jsp">&lt;h1&gt;
    获取后台参数： ${msg}
&lt;/h1&gt;
</code></pre>
<ul>
<li>
<h5 id="modelandview">ModelAndView</h5>
</li>
</ul>
<pre><code class="language-java">/**
 * ModelAndView其实是将数据Model和视图View做了一个封装，底层实现原理一样
 */
@RequestMapping(&quot;/show_msg&quot;)
public ModelAndView showMessage(ModelAndView mv) {
    mv.addObject(&quot;msg&quot;, &quot;我是通过model传过来的参数&quot;);
    mv.setViewName(&quot;message_page&quot;);
    return mv;
}
</code></pre>
<blockquote>
<p>Model和ModelAndView传递的参数本质上也是用请求作用域来实现的，所以仅对请求转发有效。</p>
</blockquote>
<h3 id="3-视图控制器">3. 视图控制器</h3>
<p>用于通过配置的方式简化我们项目中不含业务逻辑的页面跳转，省去了我们写一个空方法的步骤。</p>
<h4 id="视图控制器的作用和用法">视图控制器的作用和用法</h4>
<p>试想一下，如果我们的工程中有这样的一个需求，比如当用户点了某个链接和按钮的时候，我们需要做一个页面跳转，这个跳转的目标可能是一个公开目录的页面也可能是私有目录（/WEB-INF/下）的页面、还可能是跳转到后台Controller的某个方法中，我们如何实现？</p>
<p>示例：比如我们想将登陆页设置为一个项目默认欢迎页面</p>
<p>方案一：在Controller中添加一个拦截/的handler方法</p>
<pre><code class="language-java">@RequestMapping(&quot;/&quot;)
public String toWelcomePage() {
    return &quot;login&quot;;
}

</code></pre>
<p>方法二：使用视图控制器</p>
<p>在dispatcher-servlet.xml（SpringMVC配置文件）配置中添加</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;login&quot; /&gt;

</code></pre>
<ul>
<li>path: 指定要匹配的访问路径</li>
<li>view-name: 返回的逻辑视图名</li>
<li>status-code: 设置响应状态码。(注：不能通过只设置状态码，不设置view-name实现只返回code，没有页面的处理)</li>
</ul>
<blockquote>
<p>view-name不仅可以是逻辑视图名，还可以添加forward、redirect前缀，通过转发或重定向的方式跳转到一个具体的路径，如：&lt;mvc:view-controller path=&quot;/&quot; view-anme=&quot;forward:/WEB-INF/login.jsp&quot; /&gt;</p>
</blockquote>
<!-- SpringMVC 第二天 -->
<h3 id="4-设置web项目的默认欢迎页">4. 设置Web项目的默认欢迎页</h3>
<ul>
<li>
<p>在web.xml中使用<welcome-file-list>标签指定</p>
</li>
<li>
<p>使用上面提到的视图控制器</p>
<pre><code class="language-xml">&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;逻辑视图名&quot; /&gt;
&lt;!-- 当工程中存在Tomcat默认欢迎页同名文件时此种方式可能失效，比如index.html、index.jsp、index.htm --&gt;

</code></pre>
</li>
</ul>
<h4 id="静态资源处理">静态资源处理</h4>
<pre><code class="language-xml">&lt;!-- 针对静态资源的处理 --&gt;
    &lt;!-- http://localhost:8080/static/css/index.css --&gt;
&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;

</code></pre>
<h3 id="5-重定向和转发">5. 重定向和转发</h3>
<h4 id="在servlet实现重定向和转发">在Servlet实现重定向和转发：</h4>
<p>重定向：response.sendRedirect(&quot;xxx.jsp&quot;);</p>
<p>转发： request.getRequestDispatcher(&quot;xxx.jsp&quot;).forward(request, response);</p>
<h4 id="在springmvc中请求转发好和重定向">在SpringMVC中请求转发好和重定向</h4>
<ul>
<li>
<h5 id="请求转发有三种方式">请求转发有三种方式</h5>
</li>
<li>
<p>在Handler方法中直接返回逻辑视图名称</p>
</li>
<li>
<p>在Handler方法中返回&quot;forward:路径&quot;</p>
</li>
<li>
<p>在Handler方法中返回InternalResourceView对象</p>
</li>
</ul>
<blockquote>
<p>其中第二种和第三种作用一样， 都是将路径用请求转发的方式跳转，返回的路径时不经过视图解析器处理的；而第一种虽然也是通过请求转发方式跳转，但是返回值会作为逻辑视图名称，经过视图解析器处理后，才渲染。</p>
</blockquote>
<ul>
<li>
<h5 id="重定向有两种方式">重定向有两种方式</h5>
</li>
<li>
<p>在Handler方法中返回&quot;redirect:路径&quot;</p>
</li>
<li>
<p>在Handler方法中返回RedirectView对象</p>
</li>
</ul>
<blockquote>
<p>这两种方法效果一样。 注意使用重定向的方式跳转页面，Model中的数据就无法带到页面了（因为Model底层也是用请求作用域来传递参数的）。</p>
</blockquote>
<h3 id="6-restfull服务接口开发">6. RESTFull服务接口开发</h3>
<p>SpringMVC给我们提供了一系列的注解用于支持RESTFull风格的服务开发</p>
<h4 id="常用restfull注解">常用RESTFull注解</h4>
<ul>
<li>
<p><code>@RestController</code></p>
<p>该注解本身是一个组合注解，由<code>@Controller</code>和<code>@ResponseBody</code>两个注解组成，所以拥有这两个注解的作用。 在类上声明后，该类会变成一个Controller类，同时，方法的返回值会作为响应体经过消息转换器直接响应给客户端，而不会将其作为视图渲染。</p>
<pre><code class="language-java">@RestController // 这个注解其实是组合了下面两个注解的作用
//@Controller
//@ResponseBody
public class UserRestController {

}

</code></pre>
</li>
<li>
<p><code>@GetMapping</code> :</p>
<p>作用： 申明当前handler方法只匹配GET请求</p>
<p>使用示例</p>
<pre><code class="language-java">@GetMapping(&quot;/{id}&quot;)
public User getUserById(@PathVariable Integer id) {
    return userService.findById(id);
}

</code></pre>
</li>
<li>
<p><code>@PostMapping</code>: 申明当前handler方法只匹配POST请求</p>
</li>
<li>
<p><code>@DeleteMapping</code>: 申明当前handler方法只匹配DELETE请求</p>
</li>
<li>
<p><code>@PutMapping</code>: 申明当前handler方法只匹配PUT请求</p>
</li>
</ul>
<blockquote>
<p>上面四个注解分别对应HTTP的一种请求方法，使用方法类似。</p>
</blockquote>
<p>上面四个注解其实是一种快捷注解， 等效于使用下面代码：</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.GET)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.POST)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.PUT)
@RequestMapping(value = &quot;/user&quot;, method = RequestMethod.DELETE)

</code></pre>
<ul>
<li>@PathVariable: 获取请求地址中的变量，注入到方法参数中</li>
</ul>
<h3 id="7-返回json格式的数据-消息转换器">7. 返回JSON格式的数据--消息转换器</h3>
<h5 id="消息转换器是什么">消息转换器是什么</h5>
<p>之前我们在写普通Controller时，handler方法的返回值要是就是一个String（逻辑视图名），要么就是一个ModelAndView、View对象。</p>
<p>而我们使用了RestController之后，方法的返回值已经不会被作为视图去渲染了，这时候我们的方法其实可以返回任意类型的数据。这些数据会直接通过响应体以流的方式返回给客户端。</p>
<p>我们知道Java中的对象是不能直接用流的方式读取的，需要序列化。比如我们的handler方法返回了一个User类型，SpringMVC就不知道如果将这个类型返回给客户端了。这时就需要我们通过配置消息转换器来完成这种类型对象的返回处理。 而在RESTFull服务中，对象绝大部分传递方式就是通过JSON格式。</p>
<h5 id="如何配置一个转换json格式的消息转换器">如何配置一个转换JSON格式的消息转换器</h5>
<ul>
<li>
<p>使用SpringMVC默认的Jackson库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;!-- jackson依赖，用于将handler方法返回的对象直接转换成JSON数据 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;version&gt;2.9.7&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>开启mvc注解支持</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven /&gt;

</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}
</code></pre>
</li>
</ol>
<blockquote>
<p>Jackson是SpringMVC默认的JSON格式消息转换器， 所以在不配置额外转json参数时，我们可以直接只引入jackson依赖，再开启mvc直接支持就可以了。而第三方的转换库如FastJSON就必须显示配置MessageConverter</p>
</blockquote>
</li>
<li>
<p>使用阿里巴巴的FastJSON库</p>
<ol>
<li>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba&lt;/groupId&gt;
     &lt;artifactId&gt;fastjson&lt;/artifactId&gt;
     &lt;version&gt;1.2.57&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置MessageConverter</p>
<pre><code class="language-xml">&lt;mvc:annotation-driven&gt;
    &lt;mvc:message-converters&gt;
        &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
            &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
            &lt;property name=&quot;fastJsonConfig&quot;&gt;
                &lt;!-- 设置转换JSON的参数 --&gt;
                &lt;bean class=&quot;com.alibaba.fastjson.support.config.FastJsonConfig&quot;&gt;
                    &lt;property name=&quot;dateFormat&quot; value=&quot;yyyy-MM-dd HH:mm:ss&quot; /&gt;
                &lt;/bean&gt;
            &lt;/property&gt;
            &lt;property name=&quot;supportedMediaTypes&quot;&gt;
            &lt;!-- 指定转换完JSON后返回的响应头和编码，添加text/html是为了处理在IE下application/json会弹出下载框问题 --&gt;
                &lt;list&gt;
                    &lt;!--&lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;--&gt;                
                    &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/mvc:message-converters&gt;
&lt;/mvc:annotation-driven&gt;
</code></pre>
</li>
<li>
<p>定义Controller类</p>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/user&quot;)
public class UserRestController {
    
    @GetMapping(&quot;/{id}&quot;)
    public User getUserById(Integer id) {
        return userService.findById(id);
    }
    
}

</code></pre>
</li>
</ol>
</li>
</ul>
<h3 id="8-通过网页模拟restfull请求">8. 通过网页模拟RESTFull请求</h3>
<p>通过SpringMVC给我们提供的一个过滤器，我们可以用表单模拟各种RESTFull的请求，使用方法如下：</p>
<ol>
<li>
<p>在web.xml中添加过滤器</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;httpMethodFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
</li>
<li>
<p>在表单中添加name为_method的hidden域，并将表单的method设置为post</p>
<pre><code class="language-html">&lt;!-- 使用表单模拟发起一个DELETE请求，删除user表中id为57的数据 --&gt;
&lt;form action=&quot;/user/57&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot; /&gt;
    &lt;input type=&quot;number&quot; name=&quot;id&quot; /&gt;
    &lt;input type=&quot;text&quot; name=&quot;username&quot; /&gt;
    &lt;input type=&quot;submit&quot; /&gt;
&lt;/form&gt;

</code></pre>
</li>
</ol>
<blockquote>
<p>由于RESTFull请求通常发生在服务于服务之间的调用，所以有些请求用浏览器不太好模拟，建议使用专业的网络测试工具postman来进行测试。</p>
</blockquote>
<h4 id="resttemplate工具类">RestTemplate工具类</h4>
<p>SpringMVC帮我们封装的一个Rest请求工具，可以使用一个URI地址发起网络请求，并且将结果封装成一个指定的对象。</p>
<h3 id="9-处理请求乱码">9. 处理请求乱码</h3>
<p>SpringMVC给我们提供了一个专门用来解决post请求乱码的过滤器，我们只需将其配置到web.xml中，就可以避免post请求乱码，免去了我们自己写过滤器的麻烦</p>
<p>在web.xml中</p>
<pre><code class="language-xml">&lt;!-- 解决POST请求乱码 --&gt;
&lt;filter&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>注意： 如果项目中配置了多个过滤器，建议将此过滤器放到所有过滤器的最上面。</p>
</blockquote>
<h3 id="10-在springmvc方法中支持的参数">10. 在SpringMVC方法中支持的参数</h3>
<p>SpringMVC的handler方法中支持诸如很多特殊类型的参数，常用的有</p>
<ul>
<li>
<h5 id="注入原生servlet对象">注入原生Servlet对象</h5>
</li>
<li>
<p>javax.servlet.ServletRequest</p>
</li>
<li>
<p>javax.servlet.ServletResponse</p>
</li>
<li>
<p>javax.serlvet.http.HttpSession</p>
</li>
<li>
<h5 id="以流的方式读取请求体-以流的方式响应到客户端">以流的方式读取请求体、以流的方式响应到客户端</h5>
</li>
<li>
<p><s>java.io.InputStream、java.io.Reader</s></p>
</li>
<li>
<p><s>java.io.OutputStream、java.io.Writer</s></p>
</li>
<li>
<h5 id="读取请求体和请求头数据">读取请求体和请求头数据</h5>
</li>
<li>
<p>HttpEntity</p>
</li>
<li>
<h5 id="向页面传参">向页面传参</h5>
</li>
<li>
<p>java.util.Map，org.springframework.ui.Model、org.springframework.ui.ModelMap</p>
</li>
</ul>
<!-- SpringMVC 第三天 -->
<h3 id="11-文件上传">11. 文件上传</h3>
<ul>
<li>
<h4 id="说明">说明</h4>
</li>
</ul>
<p>在Java中，主流的文件上传方式有两种，分别是通用文件上传(commons-fileupload)和Servlet3.0方式的文件上传。SpringMVC分别对着两种方式都做了支持。</p>
<ul>
<li>CommonsMultipartResolver</li>
<li>StandardServletMultipartResolver</li>
</ul>
<blockquote>
<p>除此之外SpringMVC对文件上传的接口做了统一的封装，使用<code>MultipartFile</code>接口代替了通用上传中的<code>FileItem</code>和Servlet3.0中的<code>Part</code>，使得开发人员在业务代码中可以使用统一的接口处理，而不用管底层用的是哪种文件上传实现方式。</p>
</blockquote>
<ul>
<li>
<h4 id="基于apache-fileupload通用文件上传包">基于Apache Fileupload通用文件上传包</h4>
</li>
</ul>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;
    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;
    &lt;version&gt;1.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;commons-io&lt;/groupId&gt;
    &lt;artifactId&gt;commons-io&lt;/artifactId&gt;
    &lt;version&gt;2.6&lt;/version&gt;
&lt;/dependency&gt;

</code></pre>
</li>
<li>
<p>在SpringMVC配置文件中添加MultipartResolver文件上传解析器</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;

</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<pre><code class="language-java">@RequestMapping(&quot;/upload&quot;)
public String upload(@RequestParam(&quot;myFile&quot;) MultipartFile file, HttpServletRequest req, Model model) {
    try {
        // 使用SpringMVC给我们提供的工具类获取项目中upload文件夹在硬盘上的绝对路径
        String uploadPath = WebUtils.getRealPath(req.getServletContext(), &quot;/upload/&quot;);
        // 将上传的文件写到上传目录
        file.transferTo(new File(uploadPath+file.getOriginalFilename()));
    } catch (IOException e) {
        e.printStackTrace();
    }
}

</code></pre>
</li>
</ol>
<ul>
<li>
<h4 id="基于servlet30标准api文件上传">基于Servlet3.0标准API文件上传</h4>
</li>
</ul>
<ol>
<li>
<p>开启Servlet文件上传支持</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;!-- 开启Servlet文件上传支持 --&gt;
    &lt;multipart-config /&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre>
</li>
<li>
<p>在SpringMVC中配置MultipartResolver</p>
<pre><code class="language-xml">&lt;!-- 配置基于Servlet3.0文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.support.StandardServletMultipartResolver&quot; /&gt;
</code></pre>
</li>
<li>
<p>在Controller中编写文件上传逻辑代码</p>
<blockquote>
<p>实现方式同通用上传代码一样。</p>
</blockquote>
</li>
</ol>
<ul>
<li>
<h4 id="文件名上传乱码问题">文件名上传乱码问题</h4>
</li>
<li>
<p>使用通用上传方式的解决方法</p>
<p>在配置的CommonsMultipartResolver bean中注入属性</p>
<pre><code class="language-xml">&lt;!-- 配置基于apache fileupload的通用文件上传器（注意：id属性不可省略） --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
    &lt;!-- 指定文件上传编码 --&gt;
    &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>使用Servlet3.0标准上传方式的解决方法</p>
<p>通过配置SpringMVC提供的编码过滤器解决</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;forceEncoding&lt;/param-name&gt;
        &lt;param-value&gt;true&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;characterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;

</code></pre>
<blockquote>
<p>本质上还是设置请求的编码 request.setCharacterEncoding(&quot;UTF-8&quot;);</p>
</blockquote>
</li>
</ul>
<h3 id="12-拦截器">12. 拦截器</h3>
<ul>
<li>
<h4 id="拦截器-vs-过滤器">拦截器 VS 过滤器</h4>
</li>
</ul>
<p>过滤器是Servlet规范中提供的一项技术。不依赖于任何第三方框架。它的作用主要用来做两件事： 加工请求、过滤请求。</p>
<p>拦截器是SpringMVC自己封装的一项基于Handler拦截的结束。也就是说只有在SpringMVC框架里面才有拦截器的概念。拦截器拦截的对象是Handler。它的全称是 HandlerInterceptor。</p>
<p>加上拦截器以后，请求处理流程：  request -&gt; DispatcherServlet -&gt; HandlerMapping -&gt; HandlerExecutionChain(包含了目标handler和若干个拦截器) -&gt; HandlerAdapter -&gt; 循环调用HandlerExecutionChain对象中所有拦截器的prehandler方法 -&gt; 如果preHandler返回false，那么handler将不会被调用。反之，才会正常调用。</p>
<ul>
<li>
<h4 id="如何使用拦截器">如何使用拦截器</h4>
</li>
<li>
<h5 id="定义拦截器类">定义拦截器类</h5>
</li>
</ul>
<p>新建一个类实现HandlerInterceptor接口</p>
<pre><code class="language-java">/**
 * 定义拦截器步骤：
 *      1. 定义一个普通类，实现HandlerInterceptor接口
 *      2. 按需实现接口中的方法
 *      3. 在SpringMVC配置文件中通过&lt;mvc:interceptors&gt;&lt;/mvc:interceptors&gt;配置拦截器
 */
public class NotAllowedInterceptor implements HandlerInterceptor {

    /**
     * 此回调方法在执行Handler之前被调用
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println(&quot;进入NotAllowedInterceptor, 凡是我能拦截到的请求，一律不准通过!&quot;);
        return false;
    }

    /**
     * 此回调方法在执行Handler之后被调用
     * @param request
     * @param response
     * @param handler
     * @param modelAndView
     * @throws Exception
     */
    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {

    }

    /**
     * 此回调方法在DispatcherServlet最终响应之前被调用
     * @param request
     * @param response
     * @param handler
     * @param ex
     * @throws Exception
     */
    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {

    }
}
</code></pre>
<h5 id="配置拦截器">配置拦截器</h5>
<ul>
<li>
<h6 id="全局拦截器">全局拦截器</h6>
</li>
</ul>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;!-- 这种方式配置的拦截器会拦截所有请求 --&gt;
    &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<ul>
<li>
<h6 id="拦截指定请求的拦截器">拦截指定请求的拦截器</h6>
</li>
</ul>
<pre><code class="language-xml">&lt;mvc:interceptors&gt;
    &lt;mvc:interceptor&gt;
        &lt;!-- 拦截的请求 --&gt;
        &lt;mvc:mapping path=&quot;/admin/**&quot; /&gt;
        &lt;!-- 不拦截的请求 --&gt;
        &lt;mvc:exclude-mapping path=&quot;/intercepor/**&quot;/&gt;
        &lt;!-- 配置我们定义的实现了HandlerInterceptor接口的类 --&gt;
        &lt;bean class=&quot;com.lanou3g.springmvc.interceptor.NotAllowedInterceptor&quot; /&gt;
    &lt;/mvc:interceptor&gt;
&lt;/mvc:interceptors&gt;
</code></pre>
<h2 id="springmvc出错点">SpringMVC出错点：</h2>
<h3 id="展示数据库数据">展示数据库数据：</h3>
<pre><code class="language-xml">&lt;!--Spring-MVC 查询数据库要在web.xml加的代码--&gt;
    &lt;!--父上下文的配置--&gt;
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt;
    &lt;/context-param&gt;

    &lt;!-- 监听器配置 --&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;

</code></pre>
<p><strong><mark>Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计</mark></strong></p>
<p><strong>总结：具体的一个项目中有：controller层调用了Service层的方法，Service层调用Dao层的方法，其中调用的参数是使用Entity(实体类)层进行传递的。</strong></p>
<h3 id="springmvc静态资源放行">SpringMVC静态资源放行</h3>
<p>这种放行方式只能在页面展示不能下载</p>
<p><strong><mark>&lt;mvc:default-servlet-handler /&gt;</mark></strong></p>
<p>还有一种办法</p>
<pre><code class="language-xml">&lt;!--放行静态资源！--&gt;&lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot;/&gt;
</code></pre>
<h3 id="spring-mvc的controller层获取jsp页面参数">Spring MVC的controller层获取jsp页面参数</h3>
<ul>
<li>方式有两种，一种为使用@RequestParam，一种为使用request.getParameter(“param”)来获取</li>
</ul>
<hr>
<p>。。。。。。好长。。。。。。<br>
<img src="https://img-blog.csdnimg.cn/20191102174707557.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[idea控制台日志打印]]></title>
        <id>https://cxp-twx.github.io/post/idea-kong-zhi-tai-ri-zhi-da-yin</id>
        <link href="https://cxp-twx.github.io/post/idea-kong-zhi-tai-ri-zhi-da-yin">
        </link>
        <updated>2019-08-18T07:48:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="logbackxml-文件">logback.xml 文件</h2>
<p>对于查看运行的SQL语句极有帮助！<br>
<img src="https://img-blog.csdnimg.cn/20191102165141764.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="效果"><br>
配合的依赖：</p>
 <!--打印日志-->
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
  &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
  &lt;version&gt;1.2.3&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>放在resources目录下的XML文件：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;configuration&gt;
    &lt;property name=&quot;HOME_LOG&quot; value=&quot;logs&quot;/&gt;
    &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;
        &lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&gt;
            &lt;Pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/Pattern&gt;
        &lt;/layout&gt;
    &lt;/appender&gt;
    &lt;appender name=&quot;RollingFile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;
        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;
            &lt;level&gt;TRACE&lt;/level&gt;
        &lt;/filter&gt; &lt;!-- 测试部署时使用如下配置 --&gt; &lt;!-- 可让每天产生一个日志文件，最多 30 个，更早的删除 --&gt;
        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;
            &lt;fileNamePattern&gt;${HOME_LOG}/log-%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;
            &lt;maxHistory&gt;10&lt;/maxHistory&gt;
        &lt;/rollingPolicy&gt; &lt;!-- RollingFileAppender 一般情况下需要配置两个参数： RollingPolicy，负责滚动。TriggeringPolicy，决定是否以及何时进行滚动 TimeBasedRollingPolicy比较特殊，它同时继承了RollingPolicy和TriggerPolicy。 --&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt; &lt;!-- 正式部署时使用此配置 --&gt; &lt;!-- &lt;file&gt;${app.home}/logs/log.log&lt;/file&gt; &lt;append&gt;true&lt;/append&gt; &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.FixedWindowRollingPolicy&quot;&gt; &lt;fileNamePattern&gt;${app.home}/logs/log.%i.log.zip &lt;/fileNamePattern&gt; &lt;minIndex&gt;1&lt;/minIndex&gt; &lt;maxIndex&gt;7&lt;/maxIndex&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger - %msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;triggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy&quot;&gt; &lt;maxFileSize&gt;50MB&lt;/maxFileSize&gt; &lt;/triggeringPolicy&gt; --&gt;
    &lt;/appender&gt;
    &lt;logger name=&quot;com.lanou3g&quot; level=&quot;DEBUG&quot;/&gt;
    &lt;logger name=&quot;org.springframework&quot; level=&quot;ERROR&quot;/&gt;
    &lt;logger name=&quot;org.mybatis.spring&quot; level=&quot;ERROR&quot;/&gt;
    &lt;logger name=&quot;org.apache&quot; level=&quot;ERROR&quot;/&gt;
    &lt;logger name=&quot;ch.qos.logback&quot; level=&quot;ERROR&quot;/&gt;
    &lt;root level=&quot;debug&quot;&gt;
        &lt;appender-ref ref=&quot;STDOUT&quot;/&gt;
        &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;
    &lt;/root&gt;
&lt;/configuration&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java反射（使用场景非常多！）]]></title>
        <id>https://cxp-twx.github.io/post/java-fan-she-shi-yong-chang-jing-fei-chang-duo</id>
        <link href="https://cxp-twx.github.io/post/java-fan-she-shi-yong-chang-jing-fei-chang-duo">
        </link>
        <updated>2019-07-17T06:48:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="反射">反射</h1>
<h3 id="生活中的反射">生活中的反射</h3>
<p>太阳光照射到镜子上，会发生反射。反射时光的方向会发生改变（略微的反向）。</p>
<p>代码中的反射，改变了我们使用对象的方式。之前：对象调方法，对象设置属性。反射刚好反了一下。方法调用对象，属性调用对象。</p>
<p>在Java中反射是比较底层的内容，<strong>想要实现反射需要使用Class类</strong>。</p>
<h3 id="什么是class类">什么是Class类</h3>
<p>类是相同事物的抽象。类在描述一类事物。例如：人都有姓名，性别，年龄，还有吃饭、睡觉、打豆豆。</p>
<p>通过创建对象，可以形成各种不同的人。</p>
<p>类是由谁来描述的呢？Class就是描述类的类。类也有共性，属性，方法，构造器，父类，接口。每一个类都有对应一个Class实例。你可以认为一个Class对象对应的是一个xx.class文件。</p>
<p>Class没有创建方法，每个类的Class实例是在这个类的class文件加载到内存中的时候，由ClassLoader创建。我们只能获取Class类的对象。</p>
<p><strong>Class类有以下几种获取方式：</strong></p>
<ol>
<li>
<p>类名.class</p>
<blockquote>
<p>基本数据类型也可以获取对应的Class实例  用法是int.class   double.class  普通类获取Class对象的方法：String.class   Person.class</p>
</blockquote>
</li>
<li>
<p>对象.getClass()</p>
</li>
<li>
<p>Class.forName(&quot;类的完整字符串描述&quot;)</p>
</li>
</ol>
<pre><code class="language-java">		//获取Class对象的方式一： 类名.class
		Class class1 = int.class;
		System.out.println(class1);
		Class class2 = String.class;
		System.out.println(class2);
		Class class3 = Person.class;
		System.out.println(class3);
		
		//获取Class对象的方式二： 对象.getClass();
		String str = &quot;hello&quot;;
		Class class4 = str.getClass();
		System.out.println(class4);
		System.out.println(class4 == class2);
		Person p = new Person();
		Class class5 = p.getClass();
		System.out.println(class5);
		System.out.println(class3 == class5);
		
		
		//获取Class对象的方式三： Class.forName(&quot;完整类名&quot;)
		Class class6 = Class.forName(&quot;java.util.ArrayList&quot;);
		System.out.println(class6);
		
		Class class7 = Class.forName(&quot;com.lanou.lessonclass.Person&quot;);
		System.out.println(class7);
</code></pre>
<h3 id="反射-2">反射</h3>
<p>在Java中提供了一套机制，这种机制允许你通过Class对象来获取类的全部信息（属性，方法，构造器，接口，父类，注解等等），获取之后，你可以对他们做你想做的事情。哪怕是私有的也可以操作。</p>
<h4 id="通过class对象获取类的属性">通过Class对象获取类的属性</h4>
<p>在Java中Filed类是用于描述属性的类。</p>
<p>通过Class对象获取类的属性的方式有4个：</p>
<p>getFields()  //获取类中所有的public属性（含继承链上的public属性）</p>
<p>getField(String name)  //获取类中指定名称的public属性。（含继承链上的 public属性）</p>
<p>getDeclaredFields()  //获取类中所有的属性（不含继承链上的属性）</p>
<p><strong>getDeclaredFiled(String name)</strong> //获取类中指定名称的属性</p>
<h4 id="通过class对象获取类的构造器">通过Class对象获取类的构造器</h4>
<p>在Java中Constructor类用于描述类的构造器。</p>
<p>通过Class对象获取类的构造器的方式有4个：</p>
<p>getConstructor(Class ...parameterTypes)  // 获取本类中指定参数的public构造器</p>
<p>getConstructors()	//获取本类中全部的public构造器</p>
<p><strong>getDeclaredConstructor(Class...parameterTypes)</strong> //获取本类中指定参数的构造器</p>
<p>getDeclaredConstructors()	//获取本类中全部的构造器。</p>
<h4 id="通过class对象获取类的方法">通过Class对象获取类的方法</h4>
<p>在Java中Method是用于描述类的方法。</p>
<p>通过Class对象获取类的方法的方式有4种：</p>
<p>getMethods()	//	获取全部的public方法（含继承链上的方法）</p>
<p>getMethod(String methodName, Class...parameterTypes) //获取指定名称的public方法</p>
<p>getDeclaredMethods() 	//获取本类中所有的方法</p>
<p><strong>getDeclaredMethod(String methodName, Class...paremeterTypes)</strong> //获取本类中指定名称的方法。</p>
<h3 id="反射的作用">反射的作用</h3>
<p>反射给的第一感觉：脱了裤子放屁！</p>
<p>实际上反射的价值就在于能动态获取信息！</p>
<p>虽然写了很多很多代码，但是代码一旦写成，复用性很高。而且不需要导包！因为Class.forName(&quot;类名&quot;)可以以字符串的方式获取类名，再通过类名得到类的Class对象。</p>
<p>反射多用于写框架，几乎所有的框架底层都是靠反射实现的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单例设计模式]]></title>
        <id>https://cxp-twx.github.io/post/dan-li-she-ji-mo-shi</id>
        <link href="https://cxp-twx.github.io/post/dan-li-she-ji-mo-shi">
        </link>
        <updated>2019-06-13T02:42:36.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单例">单例</h1>
<h3 id="什么是单例">什么是单例？</h3>
<p>单例指的是单个实例。如果一个类只能创建一个对象，这样的类叫单例类，这个类的对象就是单例。</p>
<h3 id="如何把一个类定义成单例类呢">如何把一个类定义成单例类呢？</h3>
<ol>
<li>构造器私有化。（禁用new）。提供一个私有的构造器，这样外界就无法创建对象了。</li>
<li>提供一个获取本类对象的静态方法。（方法内部要保证对象的唯一性）。</li>
</ol>
<h4 id="懒汉模式的单例">懒汉模式的单例</h4>
<p>所谓懒汉模式，也叫懒加载，也叫延迟加载，即：在<strong>首次用到的时候才加载</strong>。懒汉模式的好处：节省内存空间，首次用到的时候才创建对象，如果一直没有用到，就一直不创建对象。缺点：代码较多。</p>
<pre><code class="language-java">public class Singleton {

	// 第二步定义一个 本类类型的静态属性。
	private static Singleton s = null;

	// 第一步 禁用new，让外界无法创建对象
	private Singleton() {

	}

	//第三步 提供一个获取本类对象的方法
	public static Singleton sharedSingleton() {
		//如果s为空，说明尚未创建对象，如果s不为空，说明已经创建过对象，直接使用对象即可。
		if(s == null) {
			s = new Singleton();
		}
		return s;	
	}
}
</code></pre>
<p>上述代码定义了一个单例类，这个类只能创建一个对象（通过Singleton.sharedSingleton()创建对象）。</p>
<blockquote>
<p>上述的单例类在单线程模式下是没有问题的，但是在多线程环境中，有可能会出现不止一个对象。在多个线程中同时获取对象时，有可能不止一个对象产生（即执行了多次new）。</p>
</blockquote>
<p>可以通过添加同步代码块（或同步方法）的方式来应对多线程环境。</p>
<pre><code class="language-java">public class Singleton {

	// 第二步定义一个 本类类型的静态属性。
	private static Singleton s = null;

	// 第一步 禁用new，让外界无法创建对象
	private Singleton() {

	}

	// 第三步 提供一个获取本类对象的方法(多线程安全的写法)
	public static synchronized Singleton sharedSingleton() {
		// 如果s为空，说明尚未创建对象，如果s不为空，说明已经创建过对象，直接使用对象即可。
		if (s == null) {
			s = new Singleton();
		}
		return s;
	}

}
</code></pre>
<p>上述代码是同步代码块的方式解决多线程环境下有可能产生多个对象的问题。</p>
<blockquote>
<p>在某个线程执行 Singleton.sharedSingleton()的时候，加锁，这样别的线程就会处于等待状态，从而保证只创建一个对象。但是问题是，唯一的对象创建出来以后，每次调用Singleton.sharedSingleton()获取对象的时候仍然会加锁，无形之中降低了获取单例对象的效率。</p>
</blockquote>
<p>改进代码如下：</p>
<pre><code class="language-java">public class Singleton {

	// 第二步定义一个 本类类型的静态属性。
	private static Singleton s = null;

	// 第一步 禁用new，让外界无法创建对象
	private Singleton() {

	}

	// 第三步 提供一个获取本类对象的方法(多线程安全的写法)
	public static Singleton sharedSingleton() {
		// 如果s为空，说明尚未创建对象，如果s不为空，说明已经创建过对象，直接使用对象即可。
		if (s == null) {
			synchronized (Singleton.class) {
				if(s == null) {
					s = new Singleton();
				}
			}
		}
		return s;
	}
}
</code></pre>
<p>这个代码既保证了创建对象时的唯一性，又提升了获取对象的效率。即创建对象的时候上锁，一旦对象创建完毕以后，获取对象就不会触发上锁的代码。</p>
<h4 id="饿汉模式的单例">饿汉模式的单例</h4>
<p>在类加载的时候，就把对象创建好，用的时候，直接返回这个类的对象。</p>
<pre><code class="language-java">public class Singleton2 {
	//第二步，创建一个对象
	private static Singleton2 s = new Singleton2();
	
	//第一步，禁用new
	private Singleton2() {
		
	}
	
	//返回这个类的对象
	public static Singleton2 sharedSington2() {
		return s;
	}
}
</code></pre>
<p>饿汉模式的好处：代码少，多线程下是安全的。缺点：只要类一加载，对象就创建出来了，哪怕后面一直没有调用Singleton2.sharedSingleton2();对象也存在于内存中。</p>
<blockquote>
<p>面试的时候，面试官想让你写懒汉模式。实际开发中都写饿汉模式。系统的单例类也通常写饿汉模式。饿汉模式的缺点是个伪命题，既然你写了单例类，肯定是项目中要使用单例对象。</p>
</blockquote>
<h4 id="变形的懒汉模式">变形的懒汉模式</h4>
<pre><code class="language-java">public class Singleton3 {
	//第一步 禁用new
	private Singleton3() {
		
	}
	
	//第二步 定义一个静态内部类
	private static class SingletonLoader {
		static Singleton3 s = new Singleton3();
	}
	
	//第三步 提供一个获取单例对象的方法
	public Singleton3 sharedSingleton3() {
		return SingletonLoader.s;
	}
}
</code></pre>
<p>这种模式结合了懒汉模式的延迟加载优点以及饿汉模式代码简洁以及多线程安全的特点。</p>
<h3 id="单例有什么用">单例有什么用？</h3>
<p>只能创建一个实例的类有什么用呢？</p>
<p>单例是比较常用的设计模式，主要处理不同类（不同页面）之间传递数据。</p>
<h4 id="单例传值的思路">单例传值的思路</h4>
<p>把要存储的值以及要读取的值都放到单例对象里。只需要给单例对象添加属性以及getter、setter方法即可。存的时候使用单例对象的setter方法，读取的时候，使用单例对象的getter方法。</p>
<pre><code class="language-java">public class Singleton {
	
	private String privence;//用于存取省份
	private String city;//用于存取城市
	private String street;//用于存取区
	
	public String getPrivence() {
		return privence;
	}

	public void setPrivence(String privence) {
		this.privence = privence;
	}

	public String getCity() {
		return city;
	}

	public void setCity(String city) {
		this.city = city;
	}

	public String getStreet() {
		return street;
	}

	public void setStreet(String street) {
		this.street = street;
	}

	// 第二步定义一个 本类类型的静态属性。
	private static Singleton s = null;

	// 第一步 禁用new，让外界无法创建对象
	private Singleton() {

	}

	// 第三步 提供一个获取本类对象的方法(多线程安全的写法)
	public static Singleton sharedSingleton() {
		// 如果s为空，说明尚未创建对象，如果s不为空，说明已经创建过对象，直接使用对象即可。
		if (s == null) {
			synchronized (Singleton.class) {
				if(s == null) {
					s = new Singleton();
				}
			}
		}
		return s;
	}

}
</code></pre>
<pre><code class="language-java">public class TestSingleton {

	public static void main(String[] args) {
		//假定第一个页面要把省份传递给第二个页面。
		//不直接传给第二个页面，而是把省份信息放到单例对象里。
		Singleton s1 = Singleton.sharedSingleton();
		s1.setPrivence(&quot;河南&quot;);
		
		
		//这是第二个页面,我要根据省份来确定显示哪些城市。
		Singleton s2 = Singleton.sharedSingleton();
		String privence = s2.getPrivence();
		//显示该省份的城市列表。
		//假定已经选择某个城市，不直接把城市传递给第三个页面，而是存到单例里。
		s2.setCity(&quot;郑州市&quot;);
		
		//这是第三个页面，我要根据城市来确定显示哪些区。
		Singleton s3 = Singleton.sharedSingleton();
		String city = s3.getCity();
		s3.setStreet(&quot;高新区&quot;);
		//显示该城市下的全部区。
		//假定已经选择了区，要把选择的省市区都返回到最初的页面。不是把每个页面的数据返回到最初的页面
		//而是这些信息放单例里，最初的页面去单例里取就可以了。	
		
		//假定这是最初的页面，你要显示用户选择的省市区。
		Singleton s4 = Singleton.sharedSingleton();
		String p = s4.getPrivence();
		String c = s4.getCity();
		String s = s4.getStreet();
		
	}

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java接口]]></title>
        <id>https://cxp-twx.github.io/post/java-jie-kou</id>
        <link href="https://cxp-twx.github.io/post/java-jie-kou">
        </link>
        <updated>2019-05-16T06:46:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="java接口interface">Java接口(interface)</h1>
<h2 id="一-什么是接口">一、什么是接口?</h2>
<h3 id="1-生活中的接口">1、生活中的接口</h3>
<p>USB接口</p>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTY0MzEwNjg1MDY3JmRpPTBmZTFmNGMyZDZkNGYzODk3ZGQzNzhjNDQwMTUyN2Y1JmltZ3R5cGU9MCZzcmM9aHR0cCUzQSUyRiUyRmltZzEuY2FjaGUubmV0ZWFzZS5jb20lMkZjYXRjaHBpYyUyRkYlMkZGRSUyRkZFMUI1RkQyMjJDMEY3MEIwNzAyRDhDRkEyQTNFRUUxLmpwZw?x-oss-process=image/format,png" alt="USB接口"></figure>
<p>USB接口可以连接U盘, 移动硬盘, 鼠标, 键盘, 手机,...</p>
<blockquote>
<p>U盘, 移动硬盘, 鼠标, 键盘, 手机等之所以能连接USB, 是因为这些硬件在制造的时候已经遵循了USB的<strong>连接标准.</strong></p>
</blockquote>
<h3 id="2-java中的接口">2、Java中的接口</h3>
<p>Java中的接口与生活中的接口一样, 也是用于定义标准.</p>
<p>既然是定义标准, 也就意味着接口中只规定有哪些方法, 但是并不提供这些方法的具体实现. 谁用这套标准谁来实现.</p>
<h3 id="3-其他编程语言中的接口">3、其他编程语言中的接口</h3>
<p>除了Java有接口的概念以外, 很多编程语言都有接口的概念.</p>
<p>Java中用interface来表示接口</p>
<p>C#、C++、PHP等语言中也是使用interface来表示接口</p>
<p>Objective-C中使用protocol来表示接口.</p>
<h2 id="二-java中如何定义接口">二、Java中如何定义接口</h2>
<p>既然接口是一套标准，如何制定这套标准呢？</p>
<h3 id="1-使用interface定义接口">1、使用interface定义接口</h3>
<p>在java中使用interface关键之定义接口，具体语法格式如下：</p>
<pre><code class="language-java">public interface 接口名{
 方法的声明   
}
</code></pre>
<p>接口的示例如下:</p>
<pre><code class="language-java">public interface Driver{
    public void drive(Car car);//开车
}
</code></pre>
<p>上面定义了一个接口叫Driver(即:司机), 接口里规定了司机必须会开车, 也就是说谁想要成为司机, 谁必须要会开车.</p>
<h2 id="2-如何使用接口-implements">2、如何使用接口---(implements)</h2>
<p>接口是一套标准, 内部只声明方法, 不提供实现. 谁要使用接口谁负责实现接口.实现接口使用<strong>implements</strong>关键字.</p>
<p>实现接口的语法格式如下:</p>
<pre><code class="language-java">public class Programmer implements Driver{
    ...
    public void drive(Car car){
        System.out.println(&quot;程序员在小心翼翼的开车回家&quot;);
    }
}
</code></pre>
<p>上面的代码是Programmer类(即:程序员类)实现了Driver接口, 所谓的实现接口, 指的是实现接口中定义的全部方法.</p>
<p>由于程序员类实现了司机接口中的全部方法, 因此具备了司机所需要的全部技能, 所以程序员不再是普通的程序员, 而是一个会开车的程序员.(既是司机又是程序员)</p>
<p>再看下面的代码:</p>
<pre><code class="language-java">public class Actor implements Driver{
    ...
    public void drive(Car car){
        System.out.println(&quot;演员在开车兜风&quot;);
    }
}
</code></pre>
<p>上面的代码是Actor类(即:演员类)实现了Driver接口, 因此演员也不是普通的演员, 而是一个会开车的演员.</p>
<h3 id="3-一个类实现多个接口-不会开车的厨师不是好程序员">3、一个类实现多个接口---(不会开车的厨师不是好程序员)</h3>
<p>定义另外一个接口Cook（即:厨师）</p>
<pre><code class="language-java">public interface Cook{
    public void cook();//做饭
    public void washFoodMaterial();//洗菜
}
</code></pre>
<p>定义一个类(Programmer)同时实现Driver接口和Cook接口.</p>
<pre><code class="language-java">public class Programmer implements Driver, Cook{
    ...
    public void drive(Car car){
        System.out.println(&quot;程序员在小心翼翼的开车回家&quot;);
    }
    public void cook(){
        System.out.println(&quot;程序员做了美味的饭菜&quot;);
    }
    public void washFoodMaterial(){
        System.out.println(&quot;洗菜&quot;);
    }
}
</code></pre>
<p>上述代码Programmer实现了Driver和Cook接口, 即:实现了2个接口中规定的全部方法. 因此程序员具备了司机的技能和厨师的技能. 可以认为此程序员具备3种身份: 程序员,司机以及厨师.</p>
<h2 id="三-接口有什么用">三、接口有什么用?</h2>
<h3 id="1-实现多继承">1、实现多继承</h3>
<p>众所周知, Java只允许类单继承, 并不支持类的多继承.</p>
<p><strong>接口提供了一种间接实现多继承方式.只需要让类实现多个接口即可.</strong></p>
<blockquote>
<p>注意接口实现的多继承与C++中的多继承不同, C++是真正意义上的多继承, 每个父类的属性和方法都会继承, 而接口实现的多继承更多是继承方法, 因为接口中不能定义属性(能定义类常量).</p>
</blockquote>
<h3 id="2-多态">2、多态</h3>
<p>多态是面向对象的一个重要特征, 它允许父类引用指向子类对象.</p>
<p>既然接口可以实现继承乃至多继承, 因此可以把接口看做是实现类的父类, 进而产生多态的效果.</p>
<pre><code class="language-java">Driver zhangsan =  new Progarmmer();
</code></pre>
<p>上述代码就是把 程序员看作了司机, 之所以程序员能看作司机, 是因为程序员实现了Driver接口, 具有了司机全部的功能(方法).</p>
<h2 id="四-接口的注意事项">四、接口的注意事项</h2>
<h3 id="1-接口里面的方法都必须是-public-abstract类型的">1、接口里面的方法都必须是 public abstract类型的</h3>
<blockquote>
<p>即便你没有写修饰符，也会默认给你加上public abstract。</p>
</blockquote>
<h3 id="2-接口可以看成一个特殊的抽象类">2、接口可以看成一个特殊的抽象类</h3>
<p>接口里的所有方法都是抽象方法。这个类可以看成是一个抽象类，因此接口不能创建对象。只能有实现类创建类。</p>
<blockquote>
<p>实现类就是实现接口的类。</p>
</blockquote>
<h3 id="3-接口里面可以有属性">3、接口里面可以有属性</h3>
<p>接口里可以有属性，但是属性必须是<strong>public static final</strong>修饰的属性，也就是说接口里面只能定义 静态常量。既然是常量，命名方式应该全部大写。访问方式参考static的访问方式。</p>
<h3 id="4-接口可以继承别的接口">4、接口可以继承别的接口</h3>
<p>接口可以继承别的接口，在定义接口的时候使用extends关键字来继承别的接口。</p>
<p>一旦一个接口继承了别的接口，那么这个接口的实现类也要把继承的方法实现了。</p>
<h3 id="五-接口与抽象类有什么异同">五、接口与抽象类有什么异同</h3>
<h4 id="1-能否定义属性">1、能否定义属性</h4>
<p>抽象类：抽象能定义静态属性以及非静态属性。</p>
<p>接口：只能定义静态属性，并且这个静态属性必须是final类型的静态属性。本质上是常量。</p>
<p>抽象类：能对属性进行读取以及写入操作。</p>
<p>接口：只能读取属性的值，但是不能更改属性的值。</p>
<h4 id="2-访问修饰符">2、访问修饰符</h4>
<p>属性修饰符：</p>
<p>​	抽象类：public, 默认， protected， private ；  static   final</p>
<p>​	接口： 只能是public； static  final。</p>
<p>方法修饰符：</p>
<p>​	抽象类：public， 默认， protected ， private。static ，final, abstract</p>
<p>​	接口：public abstract</p>
<h4 id="3-能否有构造器">3、能否有构造器</h4>
<p>抽象类： 可以有。</p>
<p>接口：不可以。虽然接口可以看成类但是接口不是类。</p>
<h4 id="4-能否包含抽象方法">4、能否包含抽象方法</h4>
<p>抽象类：可以包含</p>
<p>接口: 可以包含，必须是抽象方法</p>
<h4 id="5-能否包含非抽象方法">5、能否包含非抽象方法</h4>
<p>抽象类： 可以。</p>
<p>接口：不可以。</p>
<h4 id="6-是否可以包含初始化块">6、是否可以包含初始化块</h4>
<p>抽象类：可以。</p>
<p>接口：不可以。</p>
<h4 id="7-是否可以包含内部类">7、是否可以包含内部类</h4>
<p>抽象类：可以。</p>
<p>接口：可以</p>
<h4 id="8-继承">8、继承</h4>
<p>抽象类：一个普通类只能继承一个抽象类。</p>
<p>接口：一个普通类可以实现多个接口。</p>
<h3 id="六-什么时候用接口什么时候用抽象类">六、什么时候用接口？什么时候用抽象类？</h3>
<h4 id="接口的核心用途">接口的核心用途</h4>
<p>定义一些方法，供实现类去实现。</p>
<h4 id="抽象类的核心用途">抽象类的核心用途</h4>
<p>定义一些方法以及一些属性，供子类继承。</p>
<blockquote>
<p>如果只是想增加几个方法，优先使用接口。让你的类去实现某个接口（接口里是你想要增加的方法）。</p>
<p>如果既要增加方法又要增加属性，使用抽象类。让你的类继承抽象类，这样就可以获得抽象类中的属性，而且还可以实现抽象类中的方法。</p>
<p>有一种情况，只能用接口不能用抽象类。-----多继承。你要实现的方法分别在多个接口里，你可以使用实现接口的方式来完成。但是你不能继承多个类。</p>
</blockquote>
<p>抽象类以及接口都是在讲述如何去设计项目中的类。</p>
<p><strong>如果既要增加方法又要增加属性，使用抽象类。如果只想要方法，使用接口。</strong></p>
<h2 id="练习">练习</h2>
<h4 id="1定义一个接口shout叫声接口中定义一个叫声方法shout定义dogcat类分别实现shout接口">1.定义一个接口Shout（叫声），接口中定义一个叫声方法shout，定义Dog，Cat类分别实现Shout接口。</h4>
<h4 id="2定义一个接口driver司机接口中定义一个开车方法drive定义一个person类让person实现driver接口">2.定义一个接口Driver（司机），接口中定义一个开车方法drive，定义一个Person类，让Person实现Driver接口。</h4>
<h4 id="3定义一个接口keeper保安接口中定义一个opendoor-patrol和closedoor方法让上述person类实现keeper接口">3.定义一个接口Keeper（保安），接口中定义一个openDoor、patrol和closeDoor方法，让上述Person类实现Keeper接口。</h4>
<h4 id="4-定义一个接口racer赛车手让racer接口继承driver接口racer接口内定义race方法-定义一个programmer类让这个类实现racer接口">4、定义一个接口Racer（赛车手），让Racer接口继承Driver接口，Racer接口内定义race方法。定义一个Programmer类，让这个类实现Racer接口。</h4>
<h4 id="5-定义person类包含姓名年龄身高属性定义student类继承于person类定义teacher类继承于person类-定义一个接口mycomparable接口中定义int-comparetoperson-other方法-让student和teacher分别实现mycomparable接口student的compareto方法按年龄比较大小teacher的compareto按身高比较大小">5、定义Person类（包含姓名，年龄，身高属性），定义Student类继承于Person类，定义Teacher类继承于Person类。定义一个接口MyComparable，接口中定义int compareTo(Person other)方法。让Student和Teacher分别实现MyComparable接口，Student的compareTo方法按年龄比较大小，Teacher的compareTo按身高比较大小。</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java抽象类]]></title>
        <id>https://cxp-twx.github.io/post/java-chou-xiang-lei</id>
        <link href="https://cxp-twx.github.io/post/java-chou-xiang-lei">
        </link>
        <updated>2019-05-13T02:47:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="抽象类">抽象类</h1>
<h3 id="什么是类">什么是类？</h3>
<p>具有相同特征和行为的事物的统称，称为类。</p>
<h3 id="类有什么作用">类有什么作用？</h3>
<p>类的作用是创建对象。</p>
<h3 id="类里可以包含哪些内容">类里可以包含哪些内容？</h3>
<ol>
<li>属性（静态属性，非静态属性）</li>
<li>方法（静态方法，非静态方法）</li>
<li>构造器</li>
<li>代码块（静态代码块，非静态代码块）</li>
<li>类</li>
</ol>
<h3 id="什么是抽象类">什么是抽象类？</h3>
<p>抽象类和普通的类非常相似。普通类能包含的内容，抽象类都可以包含。</p>
<p>唯一的不同点就是，<strong>抽象类不能创建对象</strong>。</p>
<h1 id="如何创建一个抽象类">如何创建一个抽象类？</h1>
<p>创建抽象类，只需要在创建类的时候，添加一个关键字<strong>abstract</strong>.</p>
<p>语法格式如下：</p>
<pre><code class="language-java">public abstract class Shape{
    ....
}
</code></pre>
<p>抽象类的特点：<strong>不能创建对象，不能创建对象，不能创建对象</strong></p>
<h3 id="抽象类有什么用">抽象类有什么用？</h3>
<p>类不就是用来创建对象的吗？抽象类不能创建对象有什么用？</p>
<p><strong>抽象类的最大价值就是被子类继承</strong></p>
<p>抽象类可以定义公共的信息，例如 形状类的 周长，面积，边的个数。</p>
<h3 id="哪些信息写到抽象类里">哪些信息写到抽象类里？</h3>
<p>需要有某些方法，但是这个类（父类）实现这些方法没有意义，不写方法体还会报错，这样的方法要写在抽象类里，而且这个方法要声明为抽象方法。</p>
<blockquote>
<p>一个类中如果有抽象方法， 这个类必须定义为抽象类！</p>
<p>思考一下为什么要定义成抽象类？</p>
</blockquote>
<p>假如包含抽象方法的类不定义成抽象类，那它就是一个普通类，普通类可以创建对象，创建完对象以后，对象可以调用这个类方法。万一调用到了这个抽象方法会怎么样？会报错！为什么会报错，因为这个抽象方法没有方法体。为了避免这个问题，不能让含有抽象方法的类去创建对象。从语法上，怎么样才能让一个类不能创建对象呢？定义成抽象类。</p>
<h3 id="抽象方法">抽象方法</h3>
<p>什么是抽象方法？</p>
<p>一个方法如果你只想声明一下，不想去实现它（本质上不是你不想实现它，而是你不知道应该怎么去实现它，这个时候应该交给子类去实现），这个方法可以定义为抽象方法。</p>
<p>抽象方法的特点：</p>
<p>​	只有方法的声明，没有方法体。</p>
<p>如何定义抽象方法：</p>
<p>​	在方法的返回值之前添加abstract关键字。</p>
<p>语法格式如下：</p>
<pre><code class="language-java">public abstract 返回值类型  方法名(参数列表);
</code></pre>
<blockquote>
<p>一旦一个方法定义为抽象方法，你不能去实现。想实现都不能实现。</p>
</blockquote>
<h2 id="abstract-不能和哪些关键字同时出现">abstract 不能和哪些关键字同时出现？</h2>
<h3 id="private">private</h3>
<p>abstract不能和private同时出现。</p>
<p>private修饰的方法是私有的，子类根本就不知道有这个方法。</p>
<p>abstract修饰的方法是希望子类去实现。</p>
<h3 id="static">static</h3>
<p>abstract不能和static同时出现。</p>
<p>abstract修饰的方法只有声明，没有实现（没有方法体）。</p>
<p>static 不创建对象，用类名就可以调用。</p>
<p>虽然抽象类不能创建对象，但是 static修饰的方法可以不用对象去调用，用类名可以直接调用，那调用了一个没有实现的方法会怎么样呢？会报错。怎么办？避免调用，所以说抽象方法不能定义为static。</p>
<h3 id="final">final</h3>
<p>abstract不能和final同时出现。</p>
<p>abstract修饰的方法希望子类去实现的。</p>
<p>final修饰的方法表示已经是最终实现了，子类不能重写了。</p>
<h2 id="抽象类的注意事项">抽象类的注意事项</h2>
<ol>
<li>如果一个类继承了抽象类，这个类应该实现抽象中定义的全部的抽象方法。例如：Triangle继承了抽象类Shape，要实现Shape中定义的全部抽象方法。</li>
<li>如果一个类继承了抽象类，但是这个类并没有实现全部的抽象方法，意味着这个类包含抽象方法，那这个类也必须定义为抽象类。它尚未实现的方法教给它的子类去实现。</li>
</ol>
<h1 id="核心要点">核心要点</h1>
<ol>
<li>抽象方法 只有方法的声明，没有方法体。</li>
<li>包含抽象方法的类必须定位抽象类。</li>
<li>抽象类不能创建对象。</li>
<li>abstract不能和static、final、private中任何一个同时出现。</li>
</ol>
<h1 id="测试题">测试题</h1>
<ol>
<li>抽象类中可以不包含抽象方法吗？  对的</li>
<li>抽象方法可以不在抽象类中吗？  不可以</li>
<li>抽象类可以定义为私有类吗？  不可以    abstract不能和private同时出现</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO流理解和常用]]></title>
        <id>https://cxp-twx.github.io/post/io-liu-li-jie-he-chang-yong</id>
        <link href="https://cxp-twx.github.io/post/io-liu-li-jie-he-chang-yong">
        </link>
        <updated>2019-03-16T07:46:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="io流">IO流</h1>
<h2 id="什么是io流">什么是IO流</h2>
<p>IO：input（输入），output（输出）。</p>
<p>无论输入还是输出都有源头和目的地。</p>
<p>对于Java来说，输入指的是从哪到哪呢？输出指的是从哪到哪呢？</p>
<p>Java里的输入：把数据从文件（或者网络）读取到程序里。</p>
<p>Java里的输出：把程序里的数据写入到文件（或者网络）中。</p>
<h2 id="java中的io">Java中的IO</h2>
<p>在Java里的输入输出流有2大类：<strong>字节流、字符流</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>字符输入流</th>
<th>字符输出流</th>
<th>字节输入流</th>
<th>字节输出流</th>
</tr>
</thead>
<tbody>
<tr>
<td>抽象父类</td>
<td>Reader</td>
<td>Writer</td>
<td>InputStream</td>
<td>OutputStream</td>
</tr>
<tr>
<td>访问文件</td>
<td>FileReader</td>
<td>FileWriter</td>
<td>FileInputStream</td>
<td>FileOutputStream</td>
</tr>
<tr>
<td>缓冲流</td>
<td>BufferedReader</td>
<td>BufferedWriter</td>
<td>BufferedInputStream</td>
<td>BufferedOutputStream</td>
</tr>
<tr>
<td>数据流</td>
<td></td>
<td></td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
</tr>
<tr>
<td>对象流</td>
<td></td>
<td></td>
<td>ObjectInputStream</td>
<td>ObjectOutputStream</td>
</tr>
<tr>
<td>转换流</td>
<td>InputStreamReader</td>
<td>OutputStreamWriter</td>
<td></td>
<td></td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintWriter</td>
<td></td>
<td>PrintStream</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数据库语句]]></title>
        <id>https://cxp-twx.github.io/post/shu-ju-ku-yu-ju</id>
        <link href="https://cxp-twx.github.io/post/shu-ju-ku-yu-ju">
        </link>
        <updated>2019-03-16T05:44:19.000Z</updated>
        <content type="html"><![CDATA[<h1 id="数据库">数据库</h1>
<h3 id="什么是数据库">什么是数据库？</h3>
<p>用于存储数据的仓库。更重要的是，它能够对数据进行分类，而且可以快速找到这些数据。</p>
<h3 id="数据库分类">数据库分类</h3>
<ol>
<li>
<p>关系型数据库。</p>
<p>关系就是一张二维表。数据库主要靠表来存储数据，有些时候表与表之间有关联关系。</p>
<p>mysql, Oracle, SQL Server</p>
</li>
<li>
<p>非关系型数据库。no-sql数据库    （not  only  sql）</p>
<p>mongodb， redis</p>
</li>
</ol>
<p>目前主流的数据库：mysql，oracle。</p>
<h3 id="如何操作数据库">如何操作数据库</h3>
<ol>
<li>首先要有一个数据库服务器。---mysql安装包（32位和64位）。</li>
<li>启动mysql服务。（net start mysql,  或者右键我的电脑-&gt;管理-&gt;服务-&gt;标准-&gt;myslq-&gt;右键启动）</li>
<li>登陆数据库服务器。（mysql  -uroot  -p你的密码）</li>
<li>做数据库的操作。（DDL，DCL，DML）</li>
<li>退出数据库服务器。（exit）</li>
</ol>
<h3 id="数据库的常用命令">数据库的常用命令</h3>
<p>SQL（Structured  Query  Language）结构化查询语言。它是一门语言，这门语言用于操作数据库。</p>
<p>表是数据操作的基本单元。</p>
<p>表中的几个概念：</p>
<p>字段，也叫属性，也叫列名。</p>
<p>记录，一条记录用于表示一个完整信息，也称为元组。</p>
<ol>
<li>
<p>创建数据库</p>
<p>create database 数据库名</p>
<p>例如： create database  lanounbest;</p>
</li>
<li>
<p>查看全部的数据库</p>
<p>show databases;</p>
</li>
<li>
<p>进入数据库（切换数据库）</p>
</li>
<li>
<p>use 数据库名;</p>
<p>例如：use  lanounbest;</p>
</li>
<li>
<p>查看数据库中有哪些表</p>
<p>show tables;</p>
</li>
<li>
<p>删除数据库</p>
<p>drop database 数据库名;</p>
<p>例如：drop database lanounbest;</p>
</li>
<li>
<p>创建表</p>
<p>create table  表名(字段名  类型, 字段名 类型,....)</p>
<pre><code class="language-sql">create table `user`(
	`id` int(10)  primary key auto_increment,
	`username` varchar(30) not null unique,
	`password` varchar(16) not null,
	`nickname` varchar(10),
	`email` varchar(30) unique,
	`create_time` datetime,
	`last_login_time` datetime,
	`status` int(5) default 1
);
</code></pre>
</li>
<li>
<p>添加数据（插入数据）</p>
<p>insert into 表名(列名, 列名, 列名,...) values (值,值,值,...),(值,值,值,...),...</p>
<pre><code class="language-sql">insert into `user`(`username`, `password`) 
values('qiaoshouyuan', '123456'),(&quot;huleilei&quot;,&quot;woaiwanjingwei&quot;);
</code></pre>
<p>insert into 表名 values(值,值,值...),(值,值,值,...),...</p>
<pre><code class="language-sql">insert into `user` values (null,'liuxiang','liguang', '极客刘', 'liuxiang@163.com',
 '2019-08-21 11:49:39', '2019-08-21 12:25:13', 1);
</code></pre>
</li>
<li>
<p>更新数据</p>
<p>update  表名  set  列 = 值,  列 = 值, ... where 条件</p>
<pre><code class="language-sql">update user set nickname = '老崔',password = '8888' where id = 3;
</code></pre>
</li>
<li>
<p>删除数据</p>
<p>delete from 表名 where 条件</p>
<pre><code class="language-sql">delete from user where id = 1;
</code></pre>
</li>
<li>
<p>删除表</p>
<p>drop table 表名</p>
<pre><code class="language-sql">drop table user;
</code></pre>
</li>
<li>
<p>查询数据</p>
<p>查询指定列的数据（所有行）</p>
<p>select  列名, 列名,... from  表名</p>
<p>查询所有列的数据（所有行）</p>
<p>select * from 表名</p>
<p>查询指定列的数据（所有行，部分列起了别名）</p>
<p>select  列名 as 新的列名, 列名 新的列名,... from  表名</p>
</li>
<li>
<p>带条件的查询语句</p>
<p>select  列名,列名,...  from  表名  where 条件</p>
<p>条件可以是关系运算   &gt;  =   &gt;=    &lt;  &lt;=    !=</p>
<p>条件可以是模糊查询条件   like      %    _</p>
<p>条件可以支持  and   or</p>
<p>条件可以支持 between ..and</p>
<p>条件可以支持 in( )</p>
</li>
<li>
<p>分组查询（group  by）</p>
<p>分组查询是对查询结果进行分组。分组一旦成功，查询结果里相同的值只会出现一次。</p>
<p>通常，分组后不再对单独数据进行查询，而是对整个组进行查询。可以查询 max(列名)   min(列名)   avg（列名） sum(列名)</p>
</li>
<li>
<p>排序(order by)</p>
<p>select 列名,.. from 表名 order by   列名  desc , 列名</p>
</li>
<li>
<p>限制条数（分页查询）</p>
<p>取前5条数据</p>
<p>select  * from 表名  where  条件  limit 5;</p>
<p>从指定下标开始取，取若干条</p>
<p><strong>select  *  from  表名  where 条件  limit  其实下标, 条数</strong></p>
</li>
<li></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Postman的简单使用]]></title>
        <id>https://cxp-twx.github.io/post/postman-de-jian-dan-shi-yong</id>
        <link href="https://cxp-twx.github.io/post/postman-de-jian-dan-shi-yong">
        </link>
        <updated>2019-02-16T06:42:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="postman视图图解">Postman视图图解</h1>
<p><img src="https://img-blog.csdnimg.cn/20191022212400167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="全局介绍"><br>
<img src="https://img-blog.csdnimg.cn/20191022212434802.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="请求方式介绍"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[枚举简介]]></title>
        <id>https://cxp-twx.github.io/post/mei-ju-jian-jie</id>
        <link href="https://cxp-twx.github.io/post/mei-ju-jian-jie">
        </link>
        <updated>2018-12-28T07:42:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="枚举">枚举</h1>
<h3 id="什么是枚举">什么是枚举？</h3>
<p>所谓的枚举，就是把某个类所有的对象一一罗列出来。</p>
<p>枚举类：这个类的对象是有限的。</p>
<h3 id="定义枚举的语法格式">定义枚举的语法格式</h3>
<pre><code class="language-java">public enum 枚举类类名{
    值1, 值2, 值3, 值4;
}
</code></pre>
<p>示例</p>
<pre><code class="language-java">public enum Season {
	SPRING, SUMMER, AUTUMN, WINTER;
}
</code></pre>
<h3 id="枚举的使用">枚举的使用</h3>
<p>枚举一般是配合switch..case使用的。</p>
<pre><code class="language-java">public class TestEnum {

	public static void main(String[] args) {
		
		Season s = Season.SPRING;
		switch(s) {
		case SPRING:{
			System.out.println(&quot;春天想去小河边散步&quot;);
			break;
		}
		case SUMMER:{
			System.out.println(&quot;夏天我想逆流而上&quot;);
			break;
		}
		case AUTUMN:{
			System.out.println(&quot;秋天想去拍婚纱照&quot;);
			break;
		}
		case WINTER:{
			System.out.println(&quot;冬天去三亚玩&quot;);
			break;
		}
		}
	}
}
</code></pre>
<h3 id="枚举的剖析">枚举的剖析</h3>
<p>枚举的本质是一个类，这个类继承于Enum。</p>
<pre><code class="language-java">public final class Season extends Enum
{
	public static final Season SPRING;
	public static final Season SUMMER;
	public static final Season AUTUMN;
	public static final Season WINTER;
	private static final Season ENUM$VALUES[];

	private Season(String s, int i)
	{
		super(s, i);
	}

	public static Season[] values()
	{
		Season aseason[];
		int i;
		Season aseason1[];
		System.arraycopy(aseason = ENUM$VALUES, 0, aseason1 = new Season[i = aseason.length], 0, i);
		return aseason1;
	}

	public static Season valueOf(String s)
	{
		return (Season)Enum.valueOf(com/lanu/enumeration/Season, s);
	}

	static 
	{
		SPRING = new Season(&quot;SPRING&quot;, 0);
		SUMMER = new Season(&quot;SUMMER&quot;, 1);
		AUTUMN = new Season(&quot;AUTUMN&quot;, 2);
		WINTER = new Season(&quot;WINTER&quot;, 3);
		ENUM$VALUES = (new Season[] {
			SPRING, SUMMER, AUTUMN, WINTER
		});
	}
}
</code></pre>
<p>上述代码是对Season反编译的结果，从反编译的结果可以看出：枚举本质上是一个类。每一个枚举值本质上是一个（public static final）对象。</p>
<p>既然是对象，就可以调用方法，方法要么是自己定义的，要么是继承于父类的方法。</p>
<p>它的父类提供了2个常用的方法：</p>
<p>String name();	//获取枚举值的名字</p>
<p>int ordinal();	//获取枚举值的序号，序号从0开始。</p>
<p>由于枚举本质上是一个类，所以枚举可以添加属性，添加方法，添加构造器等，类所能做的事情，它都可以做。</p>
<p>下面为Season添加属性，方法以及构造器：</p>
<pre><code class="language-java">public enum Season {
	SPRING(&quot;春&quot;), SUMMER(&quot;夏&quot;), AUTUMN(&quot;秋&quot;), WINTER(&quot;冬&quot;);

	private String name;//自定义属性
	
	private Season(String name) {//自定义构造器
		this.name = name;
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public void test() {//自定义方法
		System.out.println(&quot;hello,my name is &quot; + this.name());
	}
}
</code></pre>
<p>反编译后的结果如下：</p>
<pre><code class="language-java">import java.io.PrintStream;

public final class Season extends Enum
{

	public static final Season SPRING;
	public static final Season SUMMER;
	public static final Season AUTUMN;
	public static final Season WINTER;
	private String name;
	private static final Season ENUM$VALUES[];

	private Season(String s, int i, String name)
	{
		super(s, i);
		this.name = name;
	}

	public String getName()
	{
		return name;
	}

	public void setName(String name)
	{
		this.name = name;
	}

	public void test()
	{
		System.out.println((new StringBuilder(&quot;hello,my name is&quot;)).append(name()).toString());
	}

	public static Season[] values()
	{
		Season aseason[];
		int i;
		Season aseason1[];
		System.arraycopy(aseason = ENUM$VALUES, 0, aseason1 = new Season[i = aseason.length], 0, i);
		return aseason1;
	}

	public static Season valueOf(String s)
	{
		return (Season)Enum.valueOf(com/lanu/enumeration/Season, s);
	}

	static 
	{
		SPRING = new Season(&quot;SPRING&quot;, 0, &quot;春&quot;);
		SUMMER = new Season(&quot;SUMMER&quot;, 1, &quot;夏&quot;);
		AUTUMN = new Season(&quot;AUTUMN&quot;, 2, &quot;秋&quot;);
		WINTER = new Season(&quot;WINTER&quot;, 3, &quot;冬&quot;);
		ENUM$VALUES = (new Season[] {
			SPRING, SUMMER, AUTUMN, WINTER
		});
	}
}
</code></pre>
<h3 id="枚举的总结">枚举的总结</h3>
<p>枚举就是一种数据类型，只不过这种数据类型把<strong>可能出现的值提前定义好了</strong>，用的时候拿类直接访问即可。枚举多用于switch...case和if语句。</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191022211621386.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
]]></content>
    </entry>
</feed>