<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://cxp-twx.github.io</id>
    <title>CheckChen</title>
    <updated>2019-12-13T02:54:58.368Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://cxp-twx.github.io"/>
    <link rel="self" href="https://cxp-twx.github.io/atom.xml"/>
    <subtitle>吾日三省吾身</subtitle>
    <logo>https://cxp-twx.github.io/images/avatar.png</logo>
    <icon>https://cxp-twx.github.io/favicon.ico</icon>
    <rights>All rights reserved 2019, CheckChen</rights>
    <entry>
        <title type="html"><![CDATA[MVC模式&DAO，Service，Controller、View层级理解]]></title>
        <id>https://cxp-twx.github.io/post/mvc-mo-shi-anddaoservicecontrollerview-ceng-ji-li-jie</id>
        <link href="https://cxp-twx.github.io/post/mvc-mo-shi-anddaoservicecontrollerview-ceng-ji-li-jie">
        </link>
        <updated>2019-12-13T13:57:47.000Z</updated>
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20191021190711418.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>
<ul class="markdownIt-TOC">
<li><a href="#mvc%E6%A8%A1%E5%BC%8F">MVC模式</a></li>
<li><a href="#dao%E5%B1%82service%E5%B1%82controller%E5%B1%82-view%E5%B1%82">DAO层，Service层，Controller层、View层</a></li>
<li><a href="#ssm%E6%A1%86%E6%9E%B6%E4%B8%ADdao%E5%B1%82mapper%E5%B1%82controller%E5%B1%82service%E5%B1%82model%E5%B1%82entity%E5%B1%82">SSM框架中Dao层，Mapper层，controller层，service层，model层，entity层</a></li>
<li><a href="#springboot%E7%9A%84entitydaocontrollerservice%E5%B1%82%E7%BA%A7%E7%90%86%E8%A7%A3">Springboot的entity,dao,controller,service层级理解</a></li>
</ul>
</p>
<h1 id="mvc模式">MVC模式</h1>
<blockquote>
<p>你在浏览器输入好用户名和密码之后，点击登录，浏览器会给服务器发个请求。</p>
<p>服务器接到请求之后，按照预先设定的路由规则把参数传给相应的controller。</p>
<p>controller判断参数合法性之后，从model那边拿数据。</p>
<p>model通过orm从数据库里面把数据取出来、封装成对象给controller。</p>
<p>之后，controller根据结果进行判断，然后加载相应的view（模板）。</p>
<p>最后controller把模板渲染出来的html打印到网络流中。</p>
</blockquote>
<ul>
<li><strong>生活中的例子：</strong></li>
</ul>
<p>​		总统在舞台上演讲，总统口渴了需要水；秘书负责传唤幕后人员送上水来；后台人员负责送水。总统以及舞台是view，秘书是controller，后台人员是model。总统的要求都是由model实际来完成的，controller只是个传话的。世界中很多实际场景都是按这个步骤来运行的，只是我们没有发觉。</p>
<h1 id="dao层service层controller层-view层">DAO层，Service层，Controller层、View层</h1>
<p>**DAO层：**DAO层主要是做数据持久层的工作，负责与数据库进行联络的一些任务都封装在此，DAO层的设计首先是设计DAO的接口，然后在Spring的配置文件中定义此接口的实现类，然后就可在模块中调用此接口来进行数据业务的处理，而不用关心此接口的具体实现类是哪个类，显得结构非常清晰，DAO层的数据源配置，以及有关数据库连接的参数都在Spring的配置文件中进行配置。</p>
<p>**Service层：**Service层主要负责业务模块的逻辑应用设计。同样是首先设计接口，再设计其实现的类，接着再Spring的配置文件中配置其实现的关联。这样我们就可以在应用中调用Service接口来进行业务处理。Service层的业务实现，具体要调用到已定义的DAO层的接口，封装Service层的业务逻辑有利于通用的业务逻辑的独立性和重复利用性，程序显得非常简洁。<br>
**Controller层：**Controller层负责具体的业务模块流程的控制，在此层里面要调用Serice层的接口来控制业务流程，控制的配置也同样是在Spring的配置文件里面进行，针对具体的业务流程，会有不同的控制器，我们具体的设计过程中可以将流程进行抽象归纳，设计出可以重复利用的子单元流程模块，这样不仅使程序结构变得清晰，也大大减少了代码量。</p>
<p>**View层：**此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示，</p>
<p>DAO层，Service层这两个层次都可以单独开发，互相的耦合度很低，完全可以独立进行，这样的一种模式在开发大项目的过程中尤其有优势，Controller，View层因为耦合度比较高，因而要结合在一起开发，但是也可以看作一个整体独立于前两个层进行开发。这样，在层与层之前我们只需要知道接口的定义，调用接口即可完成所需要的逻辑单元应用，一切显得非常清晰简单。</p>
<p>DAO设计的总体规划需要和设计的表，和实现类之间一一对应。</p>
<p>DAO层所定义的接口里的方法都大同小异，这是由我们在DAO层对数据库访问的操作来决定的，对数据库的操作，我们基本要用到的就是新增，更新，删除，查询等方法。因而DAO层里面基本上都应该要涵盖这些方法对应的操作。除此之外，可以定义一些自定义的特殊的对数据库访问的方法。</p>
<p><strong>Service逻辑层设计</strong></p>
<p>Service层是建立在DAO层之上的，建立了DAO层后才可以建立Service层，而Service层又是在Controller层之下的，因而Service层应该既调用DAO层的接口，又要提供接口给Controller层的类来进行调用，它刚好处于一个中间层的位置。每个模型都有一个Service接口，每个接口分别封装各自的业务处理方法。</p>
<p>在DAO层定义的一些方法，在Service层并没有使用，那为什么还要在DAO层进行定义呢？这是由我们定义的需求逻辑所决定的。DAO层的操作 经过抽象后基本上都是通用的，因而我们在定义DAO层的时候可以将相关的方法定义完毕，这样的好处是在对Service进行扩展的时候不需要再对DAO层进行修改，提高了程序的可扩展性。</p>
<h1 id="ssm框架中dao层mapper层controller层service层model层entity层">SSM框架中Dao层，Mapper层，controller层，service层，model层，entity层</h1>
<p>SSM是sping+springMVC+mybatis集成的框架。</p>
<p>MVC即model view controller。</p>
<p>model层=entity层。存放我们的实体类，与数据库中的属性值基本保持一致。</p>
<p>service层。存放业务逻辑处理，也是一些关于数据库处理的操作，但不是直接和数据库打交道，他有接口还有接口的实现方法，在接口的实现方法中需要导入mapper层，mapper层是直接跟数据库打交道的，他也是个接口，只有方法名字，具体实现在mapper.xml文件里，service是供我们使用的方法。</p>
<p>mapper层=dao层，现在用mybatis逆向工程生成的mapper层，其实就是dao层。对数据库进行数据持久化操作，他的方法语句是直接针对数据库操作的，而service层是针对我们controller，也就是针对我们使用者。service的impl是把mapper和service进行整合的文件。</p>
<p>（多说一句，数据持久化操作就是指，把数据放到持久化的介质中，同时提供增删改查操作，比如数据通过hibernate插入到数据库中。）</p>
<p>controller层。控制器，导入service层，因为service中的方法是我们使用到的，controller通过接收前端传过来的参数进行业务操作，在返回一个指定的路径或者数据表。</p>
<p>在实际开发中的Service层可能被处理为实体Service层，而不是接口，业务逻辑直接写在Service（Class，不是Interface）层中，Controller直接调用Service，Service调用Mapper。</p>
<p>当然了，Service之间也是可以互相调用！</p>
<h1 id="springboot的entitydaocontrollerservice层级理解">Springboot的entity,dao,controller,service层级理解</h1>
<p><strong>Dao层：持久层，主要与数据库交互</strong></p>
<p>DAO层首先会创建Dao接口，接着就可以在配置文件中定义该接口的实现类；接着就可以在模块中调用Dao的接口进行数据业务的处理，而不用关注此接口的具体实现类是哪一个类，Dao层的数据源和数据库连接的参数都是在配置文件中进行配置的。</p>
<p><strong>Entity层：实体层，数据库在项目中的类</strong></p>
<p>主要用于定义与数据库对象应的属性，提供get/set方法,tostring方法,有参无参构造函数。</p>
<p><strong>Service层：业务层 控制业务</strong></p>
<p>业务模块的逻辑应用设计，和DAO层一样都是先设计接口，再创建要实现的类，然后在配置文件中进行配置其实现的关联。接下来就可以在service层调用接口进行业务逻辑应用的处理。</p>
<p>好处：封装Service层的业务逻辑有利于业务逻辑的独立性和重复利用性。</p>
<p><strong>Controller层：控制层 控制业务逻辑</strong></p>
<p>具体的业务模块流程的控制，controller层主要调用Service层里面的接口控制具体的业务流程，控制的配置也要在配置文件中进行。</p>
<p><strong>View层</strong></p>
<p>此层与控制层结合比较紧密，需要二者结合起来协同工发。View层主要负责前台jsp页面的表示。</p>
<p><strong>Controller和Service的区别是：Controller负责具体的业务模块流程的控制；Service层负责业务模块的逻辑应用设计</strong></p>
<p><strong>总结：具体的一个项目中有：controller层调用了Service层的方法，Service层调用Dao层的方法，其中调用的参数是使用Entity层进行传递的。</strong></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SSM整合]]></title>
        <id>https://cxp-twx.github.io/post/ssm-zheng-he</id>
        <link href="https://cxp-twx.github.io/post/ssm-zheng-he">
        </link>
        <updated>2019-12-08T13:55:22.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#ssm%E6%95%B4%E5%90%88%E6%AD%A5%E9%AA%A4">SSM整合步骤</a>
<ul>
<li><a href="#spring%E5%92%8Cmybatis%E6%95%B4%E5%90%88">Spring和Mybatis整合</a></li>
<li><a href="#spring%E5%92%8Cspringmvc">Spring和SpringMVC</a></li>
<li><a href="#ssm%E5%87%BA%E9%94%99%E7%82%B9">SSM出错点：</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="ssm整合步骤">SSM整合步骤</h1>
<h2 id="spring和mybatis整合">Spring和Mybatis整合</h2>
<ol>
<li>
<p>加入Spring和mybatis的依赖</p>
<pre><code class="language-xml">&lt;!-- Spring相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mybatis相关依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;
    &lt;version&gt;3.4.6&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- Spring、Mybatis整合依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;
    &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;

&lt;!-- mysql驱动 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;version&gt;5.1.47&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>在Spring bean配置文件中，配置整合的Bean</p>
<p>在类路径下新建applicationContext.xml文件，做如下配置：</p>
<ol>
<li>
<p>配置数据源</p>
<pre><code class="language-xml">&lt;context:property-placeholder location=&quot;classpath*:/jdbc.properties&quot; /&gt;
&lt;!-- 连接池 --&gt;
&lt;bean id=&quot;dataSource&quot; class=&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;&gt;
    &lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&gt;
    &lt;property name=&quot;url&quot; value=&quot;${jdbc.url}&quot; /&gt;
    &lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot; /&gt;
    &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
<li>
<p>配置SqlSessionFactoryBean</p>
<pre><code class="language-xml">&lt;bean class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
    &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.lanou3g.ssm.bean&quot; /&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:/mybatis/mappers/*.xml&quot; /&gt;
&lt;/bean&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>编写mybatis的mapper映射文件、mapper接口、核心配置文件(可选)</p>
<blockquote>
<p>mapper映射文件和mapper接口可直接用mybatis逆向工程生成</p>
</blockquote>
</li>
<li>
<p>配置扫描包路径</p>
<pre><code class="language-xml">&lt;context:component-scan base-package=&quot;com.lanou3g.ssm.service&quot;  /&gt;
</code></pre>
</li>
<li>
<p>配置mapper接口扫描路径</p>
<pre><code class="language-xml">&lt;mybatis:scan base-package=&quot;com.lanou3g.ssm.mapper&quot; /&gt;
</code></pre>
<blockquote>
<p>作用是让mybatis去指定的包下找Mapper接口，生成实现类，注入到IOC容器中</p>
</blockquote>
</li>
</ol>
<h2 id="spring和springmvc">Spring和SpringMVC</h2>
<ol>
<li>
<p>添加SpringMVC依赖和Servlet、JSTL依赖</p>
<pre><code class="language-xml">&lt;!-- SpringMVC依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;
    &lt;version&gt;5.2.0.RELEASE&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- Servlet api 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
    &lt;artifactId&gt;jstl&lt;/artifactId&gt;
    &lt;version&gt;1.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>配置SpringMVC</p>
<p>web.xml</p>
<pre><code class="language-xml">&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;
         version=&quot;3.1&quot;&gt;

  &lt;!-- 配置root applicationContext --&gt;
  &lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;classpath*:application*.xml&lt;/param-value&gt;
  &lt;/context-param&gt;

  &lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
  &lt;/listener&gt;

  &lt;!-- 配置请求编码 --&gt;
  &lt;filter&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
      &lt;param-name&gt;encoding&lt;/param-name&gt;
      &lt;param-value&gt;UTF-8&lt;/param-value&gt;
    &lt;/init-param&gt;
  &lt;/filter&gt;
  &lt;filter-mapping&gt;
    &lt;filter-name&gt;charchaterFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;

  &lt;!-- 配置DispatcherServlet大总管 --&gt;
  &lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
  &lt;/servlet&gt;
  &lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
  &lt;/servlet-mapping&gt;

&lt;/web-app&gt;
</code></pre>
<p>dispatcher-servlet.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/mvc
        http://www.springframework.org/schema/mvc/spring-mvc.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;

    &lt;!-- 配置扫描Controller的包路径 --&gt;
    &lt;context:component-scan base-package=&quot;com.lanou3g.ssm.web&quot; /&gt;

    &lt;!-- 配置视图解析器 --&gt;
    &lt;mvc:view-resolvers&gt;
        &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
            &lt;property name=&quot;prefix&quot; value=&quot;/&quot; /&gt;
            &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
        &lt;/bean&gt;
    &lt;/mvc:view-resolvers&gt;

    &lt;!-- 开启SpringMVC注解支持 --&gt;
    &lt;mvc:annotation-driven&gt;
        &lt;!-- 配置消息转换器，将REST返回的对象类型转成JSON --&gt;
        &lt;mvc:message-converters&gt;
            &lt;bean class=&quot;com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter&quot;&gt;
                &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt;
                &lt;property name=&quot;supportedMediaTypes&quot;&gt;
                    &lt;list&gt;
                        &lt;!-- 这里配置的text/html主要是解决IE浏览器请求JSON会弹出下载框的问题 --&gt;
                        &lt;value&gt;text/html&lt;/value&gt;
                        &lt;value&gt;application/json&lt;/value&gt;
                    &lt;/list&gt;
                &lt;/property&gt;
            &lt;/bean&gt;
        &lt;/mvc:message-converters&gt;
    &lt;/mvc:annotation-driven&gt;

    &lt;!-- 静态资源放行 --&gt;
    &lt;mvc:resources mapping=&quot;/static/**&quot; location=&quot;/static/&quot; /&gt;
&lt;/beans&gt;
</code></pre>
</li>
</ol>
<p>至此，SSM三个框架就整合完成了。 可以编写自己的service代码和controller层代码。放一个项目目录结构图<br>
<img src="https://img-blog.csdnimg.cn/20191102145134675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h2 id="ssm出错点">SSM出错点：</h2>
<pre><code class="language-xml">&lt;!--2：配置sqlSessionFactoryBean--&gt;
    &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;

        &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
        &lt;!--实体bean的起别称，可以以类名的小写注明--&gt;
        &lt;!--逆向工程生成的mapper文件已经设定了到具体的bean故不需再配置此别称--&gt;
        &lt;!--&lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.cxp.ssm.bean&quot;/&gt;--&gt;

        &lt;!--映射文件地址--&gt;
        &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:/mappers/*.xml&quot;/&gt;

        &lt;!--还有一个起别称的方式就是在这个配置文件里设置一下，类似逆向工程生成的文件--&gt;
        &lt;!--&lt;property name=&quot;typeAliases&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;com.cxp.ssm.bean.Books&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;--&gt;
     &lt;/bean&gt;


 &lt;!--3：编写mybatis的mapper映射文件、mapper接口、已用逆向工程生成
    核心配置文件(可选：因为有这个上下文代替（相当于整合）)--&gt;
</code></pre>
<p>基础知识点：</p>
<p><strong>BooksSyncController</strong></p>
<pre><code class="language-java">@Controller
public class BooksSyncController {
    //此方法用来同步请求展示到页面

    @Autowired
    private BooksService booksService;

    @RequestMapping(&quot;/query&quot;)
    public String queryAllBooks(Model model){

        List&lt;Books&gt; books = booksService.QueryAllBooks();
        model.addAttribute(&quot;books&quot;,books);

        return &quot;bookList&quot;;
    }
}

</code></pre>
<p><strong>BooksAjaxController:</strong></p>
<pre><code class="language-java">@RequestMapping(&quot;/query2&quot;)
@RestController
public class BooksAjaxController {

    @Autowired
    private BooksService booksService;

    //此方法用来直接返回前端JSON格式文件，使用ajax请求展示到页面

    @GetMapping(&quot;/&quot;)
    public List&lt;Books&gt; queryAllBook(){
        List&lt;Books&gt; books = booksService.QueryAllBooks();
        return book;
    }


}
</code></pre>
<p>。。。。。。<br>
<img src="https://img-blog.csdnimg.cn/20191027173155565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[文件上传—Servlet]]></title>
        <id>https://cxp-twx.github.io/post/wen-jian-shang-chuan-servlet</id>
        <link href="https://cxp-twx.github.io/post/wen-jian-shang-chuan-servlet">
        </link>
        <updated>2019-12-02T13:56:42.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0">文件上传</a>
<ul>
<li><a href="#%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2">前端页面</a>
<ul>
<li><a href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">必要条件</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF">后端技术</a>
<ul>
<li><a href="#servlet30%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F">Servlet3.0上传方式</a>
<ul>
<li><a href="#servlet30%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%A0%B8%E5%BF%83-%E4%B8%80%E4%B8%AA%E6%B3%A8%E8%A7%A3-%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3">Servlet3.0上传的核心： 一个注解、一个接口</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4">具体操作步骤</a></li>
</ul>
</li>
<li><a href="#apache-commons-fileupload-%E4%B8%8A%E4%BC%A0%E6%96%B9%E5%BC%8F">Apache Commons Fileupload 上传方式</a>
<ul>
<li><a href="#%E7%94%A8fileupload%E4%B8%8A%E4%BC%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E6%8E%A5%E5%8F%A3-%E4%B8%A4%E4%B8%AA%E7%B1%BB">用fileupload上传的核心就是：一个接口、两个类</a></li>
<li><a href="#%E5%85%B7%E4%BD%93%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4-2">具体操作步骤</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h1 id="文件上传">文件上传</h1>
<h2 id="前端页面">前端页面</h2>
<h3 id="必要条件">必要条件</h3>
<ol>
<li>需要有一个form表单</li>
<li>form表单需要设置以下几个属性：
<ol>
<li>action:  提交数据的目的地</li>
<li>method: 设置post</li>
<li>enctype: 设置成multipart/form-data</li>
</ol>
</li>
<li>form里需要至少有一个file域： &lt;input type=&quot;file&quot; name=&quot;xxx&quot; /&gt;</li>
</ol>
<h2 id="后端技术">后端技术</h2>
<p>所谓文件上传其实就是用流的方式，将文件从客户的电脑上通过网页中的表单， 以二进制流的方式，流到服务器的过程。</p>
<p>文件下载就是反过来， 将文件从服务器上通过二进制流的方式流到客户电脑上。</p>
<h3 id="servlet30上传方式">Servlet3.0上传方式</h3>
<h4 id="servlet30上传的核心-一个注解-一个接口">Servlet3.0上传的核心： 一个注解、一个接口</h4>
<p>注解：</p>
<p>@MultipartConfig： 开启Servlet文件上传功能</p>
<p>接口：</p>
<p>javax.servlet.http.Part：  封装了上传的文件相关的所有信息</p>
<h4 id="具体操作步骤">具体操作步骤</h4>
<ol>
<li>新建处理文件上传的Servlet，然后重写doPost方法</li>
<li>给Servlet添加@MultipartConfig注解，开启文件上传功能</li>
<li>Part part = request.getPart(&quot;input type='type' name的值&quot;);</li>
<li>part对象有两个作用：
<ol>
<li>可以获取到上传文件的所有信息，比如：文件名、大小、类型、文件流数据</li>
<li>可以直接将文件写到服务器   part.write(&quot;文件保存的路径&quot;);</li>
</ol>
</li>
</ol>
<h3 id="apache-commons-fileupload-上传方式">Apache Commons Fileupload 上传方式</h3>
<h4 id="用fileupload上传的核心就是一个接口-两个类">用fileupload上传的核心就是：一个接口、两个类</h4>
<p>接口： FileItem</p>
<p>封装了我们表单中的每个域的数据（可能是普通文本数据，也可能是上传的文件）</p>
<p>类：</p>
<p>DiskFileItemFactory：  用于创建文件上传对象的工厂</p>
<p>ServletFileupload： 文件上传对象</p>
<h4 id="具体操作步骤-2">具体操作步骤</h4>
<ol>
<li>
<p>需要添加依赖： commons-fileupload.jar、commons-io.jar</p>
</li>
<li>
<p>新建处理文件上传的Servlet，然后重写doPost方法</p>
</li>
<li>
<p>调用ServletFileupload对象的静态方法，判断请求是否是一个文件上传请求</p>
<pre><code class="language-java">if(!ServletFileupload.isMultipartContent(request)) {
    // 如果不是multipart请求，代表不是一个有效的文件上传请求， 下面的步骤都可以省略了
}
</code></pre>
</li>
<li>
<p>创建文件上传工厂对象：</p>
<pre><code class="language-java">DiskFileItemFactory factory = new DiskFileItemFactory();
// factory.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>创建文件上传对象</p>
<pre><code class="language-java">ServletFileupload upload = new ServletFileupload(factory);
// upload.set.... 可以设置相关参数
</code></pre>
</li>
<li>
<p>用文件上传对象解析请求对象，然后获取解析后的所有FileItem</p>
<pre><code class="language-java">List&lt;FileItem&gt; fileItems = upload.parseRequest(request);
</code></pre>
</li>
<li>
<p>迭代处理每个FileItem</p>
<ol>
<li>文本信息的FileItem获取后进行相关的业务操作</li>
<li>文件类型的FileItem获取后，调用FileItem.write将文件写到服务器某个目录下。</li>
</ol>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud常用组件学习]]></title>
        <id>https://cxp-twx.github.io/post/springcloud-chang-yong-zu-jian-xue-xi</id>
        <link href="https://cxp-twx.github.io/post/springcloud-chang-yong-zu-jian-xue-xi">
        </link>
        <updated>2019-11-29T07:55:58.000Z</updated>
        <content type="html"><![CDATA[<p><ul class="markdownIt-TOC">
<li><a href="#springcloud%E5%AD%A6%E4%B9%A0">SpringCloud学习</a>
<ul>
<li><a href="#eureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9F%BA%E7%A1%80%E6%90%AD%E5%BB%BA">Eureka注册中心基础搭建</a>
<ul>
<li><a href="#netflix-eureka">Netflix Eureka</a></li>
<li><a href="#netflix-ribbon">Netflix Ribbon</a></li>
<li><a href="#ribbon%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Ribbon的使用方法</a></li>
</ul>
</li>
<li><a href="#%E6%90%AD%E5%BB%BA%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8Bpomymlapplication%E5%BA%94%E7%94%A8%E5%B1%82%E4%B8%9A%E5%8A%A1%E4%BB%A3%E7%A0%81">搭建工程过程：pom——yml——Application——应用层（业务代码）</a>
<ul>
<li><a href="#1-%E7%88%B6%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96pom%E6%96%87%E4%BB%B6springcloud-parent">1. *父工程依赖pom文件（SpringCloud-parent）</a></li>
<li><a href="#2-springcloud-eureka-server%E6%9C%8D%E5%8A%A1%E8%80%85">2. *SpringCloud-eureka-server（服务者）</a></li>
<li><a href="#%E6%8B%93%E5%B1%95jdk18%E9%85%8D%E7%BD%AE-pomxml">拓展：*jdk1.8配置（ pom.xml）</a></li>
<li><a href="#3-springcloud-eureka-server-cloud-%E6%A8%A1%E5%9D%97%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%E8%80%85">3. *springcloud-eureka-server-cloud 模块（高可用的服务者）</a></li>
<li><a href="#4-providercloud%E6%8F%90%E4%BE%9B%E8%80%85">4. *Provider（cloud提供者）</a></li>
<li><a href="#5-consumercloud%E6%B6%88%E8%B4%B9%E8%80%85">5. *Consumer（cloud消费者）</a></li>
</ul>
</li>
<li><a href="#%E5%AD%A6%E4%B9%A0%E7%90%86%E8%A7%A3">学习理解：</a>
<ul>
<li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1-rpc%E5%92%8Crest%E5%8D%8F%E8%AE%AE">微服务 Rpc和Rest协议</a></li>
<li><a href="#eureka%E7%9A%84%E8%A7%92%E8%89%B2">Eureka的角色</a></li>
</ul>
</li>
<li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98">遇到的问题：</a>
<ul>
<li><a href="#1-%E4%B8%A4%E4%B8%AA%E6%B3%A8%E8%A7%A3">1. *两个注解</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#feign%E5%A3%B0%E6%98%8E%E5%BC%8Frest%E5%AE%A2%E6%88%B7%E7%AB%AF">Feign声明式REST客户端</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">实现过程：</a>
<ul>
<li><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E6%8E%A7%E5%88%B6%E5%B1%82">消费者控制层</a></li>
<li><a href="#%E6%B6%88%E8%B4%B9%E8%80%85%E7%9A%84feign%E6%8E%A5%E5%8F%A3">消费者的Feign（接口）</a></li>
<li><a href="#%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E6%8E%A7%E5%88%B6%E5%B1%82">提供者的控制层</a></li>
<li><a href="#%E6%8F%90%E4%BE%9B%E8%80%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E7%B1%BB">提供者的实现类</a></li>
<li><a href="#server%E7%AB%AF%E9%BB%98%E9%BB%98%E7%9A%84%E5%81%9A%E7%9D%80%E8%BF%9E%E6%8E%A5%E6%A1%A5%E6%A2%81%E5%B7%A5%E4%BD%9C">server端默默的做着连接桥梁工作。</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#hystrix-%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD-%E9%99%8D%E7%BA%A7-%E9%99%90%E6%B5%81-%E9%9A%94%E7%A6%BB">Hystrix 服务熔断、降级、限流、隔离</a><br>
*
<ul>
<li><a href="#pom%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96">pom文件依赖</a></li>
<li><a href="#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">完整配置文件：</a></li>
<li><a href="#%E9%80%9A%E8%BF%87properties%E4%BF%AE%E6%94%B9%E6%8C%87%E5%AE%9Ahystrixcommand%E7%9A%84%E5%8F%82%E6%95%B0">通过Properties修改指定HystrixCommand的参数</a></li>
<li><a href="#%E5%90%AF%E5%8A%A8%E7%B1%BBribbon%E6%96%B9%E5%BC%8F">启动类（Ribbon方式）：</a></li>
<li><a href="#%E5%9C%A8%E9%9C%80%E8%A6%81%E7%9A%84%E6%96%B9%E6%B3%95%E4%B8%8A%E8%BE%B9%E6%B7%BB%E5%8A%A0%E6%B3%A8%E8%A7%A3">==*在需要的方法上边添加注解==</a></li>
<li><a href="#feign%E6%96%B9%E5%BC%8F">Feign方式</a></li>
<li><a href="#%E6%88%90%E5%8A%9F%E9%85%8D%E7%BD%AE-%E6%B7%BB%E5%8A%A0hystrix%E7%9A%84fallback%E6%96%B9%E6%B3%95">==成功配置、添加hystrix的fallback方法==</a></li>
</ul>
</li>
<li><a href="#%E7%9B%91%E6%8E%A7">监控</a>
<ul>
<li><a href="#dashboard-turbine">Dashboard、turbine</a></li>
<li><a href="#1-hystrix-dashboard">1. Hystrix Dashboard</a>
<ul>
<li><a href="#hystrix-dashboard%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Hystrix Dashboard使用方法</a></li>
</ul>
</li>
<li><a href="#2-turbine%E8%81%9A%E5%90%88%E6%9C%8D%E5%8A%A1">2. Turbine（聚合服务）</a>
<ul>
<li><a href="#turbine%E4%B8%8Edashboard-hystrix-eventstream%E7%9A%84%E5%85%B3%E7%B3%BB">Turbine与Dashboard、Hystrix EventStream的关系</a></li>
<li><a href="#turbine%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95">Turbine的使用方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#zuulnetflix-%E7%BB%9F%E4%B8%80%E7%BD%91%E5%85%B3-%E5%9C%B0%E5%9D%80%E8%B7%AF%E7%94%B1">Zuul(Netflix) - 统一网关、地址路由</a>
<ul>
<li><a href="#1-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86">1. 反向代理</a></li>
<li><a href="#2-%E7%BB%9F%E4%B8%80%E6%9D%83%E9%99%90%E6%A0%A1%E9%AA%8C">2. 统一权限校验</a></li>
<li><a href="#3-%E5%92%8Chystrix%E7%9A%84%E6%95%B4%E5%90%88">3. 和hystrix的整合</a></li>
<li><a href="#zuul%E4%BB%8B%E7%BB%8D">Zuul介绍</a></li>
<li><a href="#%E5%9C%A8%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8%E5%90%8E%E5%8F%B0%E7%9A%84%E6%97%B6%E5%80%99%E5%8A%A0%E4%B8%80%E5%B1%82%E5%B7%A5%E7%A8%8B%E7%9C%8B%E4%BC%BC%E5%B0%B1%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%E4%B9%9F%E5%B0%B1%E4%B8%8D%E5%AD%98%E5%9C%A8%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98">（在前端调用后台的时候加一层工程（看似就访问了一个端口服务，也就不存在跨域问题））</a>
<ul>
<li><a href="#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E7%94%A8%E6%B3%95">反向代理用法：</a></li>
<li><a href="#zuul%E7%9A%84%E8%AE%BF%E9%97%AE%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6">Zuul的访问超时控制</a>
<ul>
<li><a href="#%E9%80%9A%E8%BF%87serviceid%E4%BB%A3%E7%90%86%E7%9A%84%E8%AF%B7%E6%B1%82">通过ServiceId代理的请求</a></li>
</ul>
</li>
<li><a href="#zuul%E7%9A%84%E6%A0%B8%E5%BF%83filter">Zuul的核心——Filter</a>
<ul>
<li><a href="#zuul%E4%B8%AD%E9%BB%98%E8%AE%A4%E5%AE%9E%E7%8E%B0%E7%9A%84filter">Zuul中默认实现的Filter</a></li>
<li><a href="#%E7%A6%81%E7%94%A8%E6%8C%87%E5%AE%9A%E7%9A%84filter">禁用指定的Filter</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89filter%E7%A4%BA%E4%BE%8B">自定义Filter示例</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%9F%BA%E4%BA%8Egit%E4%BB%93%E5%BA%93">配置中心（基于git仓库）</a>
<ul>
<li><a href="#1-%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E9%85%8D%E7%BD%AE">1. 解决重复配置</a></li>
<li><a href="#2-%E5%9F%BA%E4%BA%8Eweb%E7%9A%84%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86">2. 基于web的加密解密</a></li>
<li><a href="#3%E7%83%AD%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE%E5%8A%A8%E6%80%81">3.热更新配置（动态）</a></li>
<li><a href="#%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E9%85%8D%E7%BD%AE">解决重复配置</a>
<ul>
<li><a href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8springcloud-config">客户端使用springcloud-config：</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">配置文件</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E6%98%A0%E5%B0%84%E5%8F%82%E6%95%B0">配置映射参数</a></li>
</ul>
</li>
<li><a href="#git%E4%BB%93%E5%BA%93%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86">git仓库加密解密</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86">配置加密解密</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%86%E7%A0%81">（数据库如：用户名密码）</a>
<ul>
<li><a href="#%E6%96%B9%E6%B3%95">方法：</a></li>
<li><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">对称加密</a></li>
<li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E9%9D%9E%E6%B3%95%E7%9A%84key%E9%9C%80%E8%A6%81jce">遇到的问题：非法的key需要jce</a></li>
<li><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">非对称加密</a></li>
</ul>
</li>
<li><a href="#%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0%E9%85%8D%E7%BD%AE">动态更新配置：</a>
<ul>
<li><a href="#%E5%8D%95%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0">单台客户端动态更新</a></li>
<li><a href="#%E5%A4%9A%E5%8F%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8A%A8%E6%80%81%E6%9B%B4%E6%96%B0">多台客户端动态更新</a>
<ul>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA">使用工具，环境搭建：</a></li>
<li><a href="#springcloud-config-server%E7%AB%AF%E9%85%8D%E7%BD%AE">SpringCloud  Config  Server端配置</a></li>
<li><a href="#springcloud-client%E7%AB%AF">SpringCloud -client端</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AF%BE%E5%A0%82%E7%9F%A5%E8%AF%86">课堂知识：</a></li>
<li><a href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98-2">遇到的问题</a></li>
</ul>
</p>
<h1 id="springcloud学习">SpringCloud学习</h1>
<h2 id="eureka注册中心基础搭建">Eureka注册中心基础搭建</h2>
<blockquote>
<p>还有一个集中配置中心（很方便和关键）</p>
</blockquote>
<h3 id="netflix-eureka">Netflix Eureka</h3>
<blockquote>
<p>服务中心，云端服务发现，一个基于 REST 的服务，用于定位服务，以实现云端中间层服务发现和故障转移。这个可是springcloud最牛鼻的小弟，服务中心，任何小弟需要其它小弟支持什么都需要从这里来拿，同样的你有什么独门武功的都赶紧过报道，方便以后其它小弟来调用；它的好处是你不需要直接找各种什么小弟支持，只需要到服务中心来领取，也不需要知道提供支持的其它小弟在哪里，还是几个小弟来支持的，反正拿来用就行，服务中心来保证稳定性和质量。</p>
</blockquote>
<h3 id="netflix-ribbon">Netflix Ribbon</h3>
<p><em>Ribbon是一个客户端负载均衡组件，帮我们实现后端服务节点动态扩容，而不影响调用方。</em></p>
<h3 id="ribbon的使用方法">Ribbon的使用方法</h3>
<blockquote>
<p>Eureka和Feign中已经默认集成了Ribbon，</p>
<p>如果项目中引入了Eureka，通过在RestTemplate上添加@LoadBalanced；</p>
<p>如果用的是Feign声明式REST客户端，feign默认就已经帮我们开启了ribbon负载均衡能力。</p>
</blockquote>
<h2 id="搭建工程过程pomymlapplication应用层业务代码">搭建工程过程：pom——yml——Application——应用层（业务代码）</h2>
<h3 id="1-父工程依赖pom文件springcloud-parent">1. *父工程依赖pom文件（SpringCloud-parent）</h3>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.cxp&lt;/groupId&gt;
    &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
            &lt;artifactId&gt;lombok&lt;/artifactId&gt;
            &lt;version&gt;1.18.10&lt;/version&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 定义SpringBoot依赖版本 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
                &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
            &lt;!-- 注意：SpringCloud最新的Greenwich版本是基于SpringBoot2.1.x(Greenwich)版本构建的
                    所以这里不支持SpringBoot2.2.x版本
                    具体SpringBoot与SpringCloud版本对应关系参见：https://spring.io/projects/spring-cloud页面最下方的Release Trains
                 --&gt;
            &lt;!--&lt;version&gt;2.2.1.RELEASE&lt;/version&gt;--&gt;


            &lt;!-- 定义SpringCloud依赖版本 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Greenwich.SR2&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<h3 id="2-springcloud-eureka-server服务者">2. *SpringCloud-eureka-server（服务者）</h3>
<p>配置文件：</p>
<pre><code class="language-yml">server:
  port: 8761


eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    #instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com
  client:
    # 是否将当前应用注册到eureka中
    registerWithEureka: true
    # 是否从eureka注册中心中拉取服务提供者列表
    fetchRegistry: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/

spring:
  application:
    name: eureka-server
</code></pre>
<h3 id="拓展jdk18配置-pomxml">拓展：*jdk1.8配置（ pom.xml）</h3>
<pre><code class="language-xml">&lt;!-- 配置maven编码字符、编译版本 --&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
</code></pre>
<h3 id="3-springcloud-eureka-server-cloud-模块高可用的服务者">3. *springcloud-eureka-server-cloud 模块（高可用的服务者）</h3>
<pre><code class="language-yml">spring:
  application:
    name: eureka-server

eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    #instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com
  client:
    # 是否将当前应用注册到eureka中
    registerWithEureka: true
    # 是否从eureka注册中心中拉取服务提供者列表
    fetchRegistry: true
    service-url:
      defaultZone: http://cloud02.study.com:8762/eureka/,http://cloud03.study.com:8763/eureka/

server:
  port: 8761

---
spring:
  profiles: cloud02

server:
  port: 8762

eureka:
  instance:
    hostname: cloud02.study.com
  client:
    service-url:
      defaultZone: http://cloud.study.com:8761/eureka/,http://cloud03.study.com:8763/eureka/

---
spring:
  profiles: cloud03

server:
  port: 8763

eureka:
  instance:
    hostname: cloud03.study.com
  client:
    service-url:
      defaultZone: http://cloud.study.com:8761/eureka/,http://cloud02.study.com:8762/eureka/
</code></pre>
<p>注：这个cloud需要一一都启动起来：才不会报错</p>
<p>​	<img src="https://img-blog.csdnimg.cn/20191202180520911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="4-providercloud提供者">4. *Provider（cloud提供者）</h3>
<p>配置文件；</p>
<pre><code class="language-yml">server:
  port: 8765


eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    #instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com
  client:
    # 是否将当前应用注册到eureka中
    registerWithEureka: true
    # 是否从eureka注册中心中拉取服务提供者列表
    fetchRegistry: false
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/

spring:
  application:
    name: eureka-server
</code></pre>
<h3 id="5-consumercloud消费者">5. *Consumer（cloud消费者）</h3>
<p>yml文件：</p>
<pre><code class="language-yml">spring:
  application:
    name: service-consumer

eureka:
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8765
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com

server:
  port: 8082
</code></pre>
<h2 id="学习理解">学习理解：</h2>
<h3 id="微服务-rpc和rest协议">微服务 Rpc和Rest协议</h3>
<blockquote>
<p>接口调用通常包含两个部分，序列化和通信协议。常见的序列化协议包括json、xml、hession、protobuf、thrift、text、bytes等；通信比较流行的是http、soap、websockect，RPC通常基于TCP实现，常用框架例如dubbo，netty、mina、thrift</p>
</blockquote>
<ul>
<li><mark>Rest</mark>：严格意义上说接口很规范，操作对象即为资源，对资源的四种操作（post、get、put、delete），并且参数都放在URL上,但是不严格的说Http+json、Http+xml，常见的http api都可以称为Rest接口。</li>
<li><mark>Rpc</mark>:我们常说的远程方法调用，就是像调用本地方法一样调用远程方法，通信协议大多采用二进制方式</li>
</ul>
<h3 id="eureka的角色">Eureka的<a href="https://blog.csdn.net/hry2015/article/details/82597311">角色</a></h3>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdn.net/20180910222113763?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hyeTIwMTU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></figure>
<blockquote>
<p>Eureka 是 Netflix 开源的服务注册发现组件，服务端通过 REST 协议暴露服务，提供应用服务的注册和发现的功能。<br>
所有的Eureka服务都被称为实例（instance）。Eureka服务又分为两类角色：Eureka Server和Eureka Client<br>
Eureka-Client又分为Application Provider 和Application Consumer<br>
Application Provider ：服务提供者，内嵌 Eureka-Client ，它向 Eureka-Server 注册自身服务、续约、下线等操作<br>
Application Consumer ：服务消费者，内嵌 Eureka-Client ，它从 Eureka-Server 获取服务列表，分为全量获取和增量。</p>
</blockquote>
<h2 id="遇到的问题">遇到的问题：</h2>
<h3 id="1-两个注解">1. *两个注解</h3>
<blockquote>
<ul>
<li>
<p>开启应用的Eureka Server功能<br>
在应用启动类上加 @EnableEurekaServer注解</p>
</li>
<li>
<p>开启应用的Eureka Client功能<br>
在应用启动类上加 @EnableEurekaClient注解</p>
<ul>
<li>@EnableDiscoveryClient   注解</li>
</ul>
<p>这是SpringCloud通过的一个注解，所有的服务发现中心组件都可以使用（客户端和服务端使用的注解一样）</p>
</li>
</ul>
</blockquote>
<h1 id="feign声明式rest客户端">Feign声明式REST客户端</h1>
<blockquote>
<p>依赖eureka和Ribbon</p>
<p>Feign底层会根据我们配置的注解属性拼接得到最终访问的URI，根据接口中定义的方法的参数和返回值将请求参数、返回结果处理好，这些都是Feign通过帮我们生成代理实现类的方式完成的。</p>
</blockquote>
<h2 id="实现过程">实现过程：</h2>
<blockquote>
<p>还是需要三方配合，那好处在哪里</p>
<p>过程：</p>
<ol>
<li><strong>（外部路线）首先消费者的控制层——提供者的控制层（返回responseInfo）——返回页面（页面展示数据）</strong></li>
<li><strong>其次消费者的控制层通过（接口注解以及@RequestMapping(&quot;/calc&quot;))——访问提供者的控制层（通过处理得到数据可以看成是消费者层级的接口实现）——回到消费者控制层返回页面数据</strong></li>
<li><strong>最后server端默默的做着他们之间的桥梁。</strong></li>
</ol>
</blockquote>
<h3 id="消费者控制层">消费者控制层</h3>
<pre><code class="language-java">@Controller
@RequestMapping(&quot;/calc&quot;)
public class CalcController {

    @Autowired
    private CalcServiceFeign calcServiceFeign;

    @RequestMapping(&quot;/add&quot;)
    public String add(@RequestParam int num1, @RequestParam int num2, Model model) {
        ResponseInfo responseInfo = calcServiceFeign.add(num1, num2);
        Map data = (Map) responseInfo.getData();
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        model.addAttribute(&quot;result&quot;, data.get(&quot;result&quot;));
        return &quot;index&quot;;
    }
}
</code></pre>
<h3 id="消费者的feign接口">消费者的Feign（接口）</h3>
<pre><code class="language-java">//提供者名字（provider）
@FeignClient(name = &quot;SERVICE-PROVIDER&quot;)
@RequestMapping(&quot;/calc&quot;)
public interface CalcServiceFeign {

    @GetMapping(&quot;/add/{num1}/{num2}&quot;)
    ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1,@PathVariable(&quot;num2&quot;) int num2);
}
</code></pre>
<h3 id="提供者的控制层">提供者的控制层</h3>
<pre><code class="language-java">@RestController
@RequestMapping(&quot;/calc&quot;)
public class CalcController {

    @Autowired
    private CalcServiceImpl calcService;

    @RequestMapping(&quot;/add/{num1}/{num2}&quot;)
    public ResponseInfo add(@PathVariable int num1, @PathVariable int num2) {
        int result = calcService.add(num1, num2);
        Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();
        data.put(&quot;num1&quot;, num1);
        data.put(&quot;num2&quot;, num2);
        data.put(&quot;operator&quot;, &quot;+&quot;);
        data.put(&quot;result&quot;, result);
        return new ResponseInfo(200, &quot;请求成功&quot;, data);

    }

} 

</code></pre>
<h3 id="提供者的实现类">提供者的实现类</h3>
<pre><code class="language-java">@Service
public class CalcServiceImpl {

    @Autowired
    private Registration registration;

    public int add(int num1, int num2) {

        String serviceInfo = registration.getHost() + &quot;-&quot; + registration.getInstanceId();

       
        return num1 + num2;
    }
} 	

</code></pre>
<h3 id="server端默默的做着连接桥梁工作">server端默默的做着连接桥梁工作。</h3>
<h1 id="hystrix-服务熔断-降级-限流-隔离">Hystrix 服务熔断、降级、限流、隔离</h1>
<p>消费者模块两种方式</p>
<blockquote>
<p>Ribbon: RestTemplate</p>
<p>Feign。分别做降级处理、步骤如下：</p>
</blockquote>
<h3 id="pom文件依赖">pom文件依赖</h3>
<pre><code class="language-xml"> &lt;dependencies&gt;
   
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 添加SpringBoot Actuator端点监控依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

    &lt;/dependencies&gt;

</code></pre>
<h3 id="完整配置文件">完整配置文件：</h3>
<pre><code class="language-yml">spring:
  application:
    name: service-consumer-hystrix

server:
  port: 8082


eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com

  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8765

#hystris的配置
hystrix:
  command:
    calc_add_command:
##对应@HystrixCommand注解的commandKey属性，指定特定熔断器的属性(一般建议在代码中通过注解配置)，此处换成default可修改全局属性。
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s

#hystris.stream的配置
management:
  server:
    port: 8092
  endpoints:
    web:
      base-path: /actuator
      exposure:
        include: &quot;*&quot;



</code></pre>
<h3 id="通过properties修改指定hystrixcommand的参数">通过Properties修改指定HystrixCommand的参数</h3>
<pre><code class="language-yml">hystrix:
  command:
    hystrixCommandName (如：calc_add_command):  #对应@HystrixCommand注解的commandKey属性，指定特定熔断器的属性(一般建议在代码中通过注解配置)，此处换成default可修改全局属性。
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 5000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s
</code></pre>
<h3 id="启动类ribbon方式">启动类（Ribbon方式）：</h3>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaClient
//@EnableHystrix    /*不是此注解*/
@EnableCircuitBreaker   //启用断路器
public class ConsumerHystrixApplication {

    @Bean
    @LoadBalanced      //(Ribbon)开启负载均衡
    public RestTemplate restTemplate(){

        return new RestTemplate();
    }
    public static void main(String[] args) {

        SpringApplication.run(ConsumerHystrixApplication.class,args);
    }
}

</code></pre>
<p><mark>成功配置、添加hystrix的fallback方法</mark></p>
<h3 id="在需要的方法上边添加注解"><mark>*在需要的方法上边添加注解</mark></h3>
<pre><code class="language-java">@HystrixCommand(
            fallbackMethod = &quot;addFallback&quot;,
            commandKey = &quot;calc_add_command&quot;             
    )

//服务正常通过的方法。
public String add(){}



/**
     * 定义add方法的降级方法，当add方法调用远程服务出现问题，发生熔断时，hystrix会自动放弃调用原来的服务，转而调用降级方法
     * @param num1
     * @param num2
     * @param model
     * @return
     */
    public String addFallback(@RequestParam int num1, @RequestParam int num2, Model model) {
        model.addAttribute(&quot;num1&quot;, num1);
        model.addAttribute(&quot;num2&quot;, num2);
        model.addAttribute(&quot;result&quot;, &quot;-1&quot;);
        return &quot;index&quot;;
    }


</code></pre>
<p>模拟处理时间（provider——impl）：</p>
<pre><code class="language-java">// 只是模拟处理时间长的服务调用
        Random random = new Random();
        int sleepTime = random.nextInt(3000);
        log.info(&quot;休眠时间：&quot; + sleepTime+&quot;ms.&quot;);
        try {
            Thread.sleep(sleepTime);

        } catch (InterruptedException e) {
            e.printStackTrace();
        }

</code></pre>
<h3 id="feign方式">Feign方式</h3>
<p>配置文件也不同；（多个Feign的配置）</p>
<pre><code class="language-yml">spring:
  application:
    name: service-consumer-feign-with-hystrix

server:
  port: 8082

eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com

  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8765

hystrix:
  command:
    default:
#    calc_add_command:
      ##对应@HystrixCommand注解的commandKey属性，指定特定熔断器的属性(一般建议在代码中通过注解配置)，此处换成default可修改全局属性。
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 #设置熔断器判定超时的时间，超过此时间的请求会执行降级逻辑，默认1s
      circuitBreaker:
        requestVolumeThreshold: 2 #设置熔断阈值，在熔断统计窗口期内，错误请求（超时、异常）次数达到阈值就会触发熔断，执行降级逻辑，默认20
        sleepWindowInMilliseconds: 10000  #设置熔断器多久进入半开状态，然后再次尝试确定熔断器是否应再次关闭，默认5s
        errorThresholdPercentage: 50  #设置在熔断统计窗口期内，错误请求达到百分之多少触发熔断，默认50
      metrics:
        rollingStats:
          timeInMilliseconds: 5000 #熔断度量窗口期时间， 默认10s
#hystris.stream的配置
management:
  server:
    port: 8092
  endpoints:
    web:
      base-path: /actuator
      exposure:
        include: &quot;*&quot;
feign:
  client:
    config:
      #calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000
  hystrix:
    enabled: true

</code></pre>
<p>pom文件主要依赖（全）</p>
<pre><code class="language-xml">&lt;!-- 引入feign依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- SpringCloud 格林威治版本中需要单独将hystrix依赖也添加上 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 引入eureka客户端依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 引入eureka依赖会自动将ribbon依赖一并引入，我们不需要自己单独添加 --&gt;
        &lt;!--&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-ribbon&lt;/artifactId&gt;
        &lt;/dependency&gt;--&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<h3 id="成功配置-添加hystrix的fallback方法"><mark>成功配置、添加hystrix的fallback方法</mark></h3>
<p><strong>(改动地方：一个注解一个实现类（fallback）)</strong></p>
<pre><code class="language-java">//提供者名字（provider）
@FeignClient(name = &quot;SERVICE-PROVIDER&quot;,fallback = CalcClientFallback.class)
@RequestMapping(&quot;/calc&quot;)
public interface CalcServiceFeign {

    @GetMapping(&quot;/add/{num1}/{num2}&quot;)

    ResponseInfo add(@PathVariable(&quot;num1&quot;) int num1, @PathVariable(&quot;num2&quot;) int num2);
}


</code></pre>
<p>有个坑（错误信息：）</p>
<p>There is already 'calcClientFallback' bean method</p>
<pre><code class="language-java">@Component
@RequestMapping(&quot;/fallback&quot;)  //此处只是为了避免重复（实现接口的时候和RestMapping一并继承了）
public class CalcClientFallback implements CalcServiceFeign{
    public ResponseInfo add(int num1, int num2) {
        Map data = new HashMap();
        data.put(&quot;num1&quot;, num1);
        data.put(&quot;num2&quot;, num2);
        data.put(&quot;result&quot;, -1);
        ResponseInfo responseInfo = new ResponseInfo(203,  &quot;降级结果&quot;, data);
        return responseInfo;
    }
}

</code></pre>
<p>Feign和Ribbon（RestTemplate方式）</p>
<ol>
<li>配置文件不同</li>
</ol>
<p>Feign多了它自己的配置</p>
<pre><code class="language-yml">feign:
  client:
    config:
#      calc-service-provider:  这一级可以写具体的微服务名称或者default，default代表全局配置，影响所有微服务的调用
      default:
        connectTimeout: 1000
        readTimeout: 2000
  hystrix:
    enabled: true

</code></pre>
<ol start="2">
<li>
<p>熔断的回调方式不同</p>
<blockquote>
<p>（RestTemplate 放在消费者的控制层复写方法加注解建立联系）：[目录](*在需要的方法上边添加注解)</p>
<p>Feign是通过接口添加另一个实现类也是通过注解建立联系：【目录】（上高亮处）</p>
</blockquote>
</li>
</ol>
<h1 id="监控">监控</h1>
<blockquote>
<p>基于spring-boot-starter-actuator的一项可视化图表工具</p>
</blockquote>
<p>消费者工程添加依赖</p>
<pre><code class="language-xml"> &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

</code></pre>
<h2 id="dashboard-turbine">Dashboard、turbine</h2>
<h2 id="1-hystrix-dashboard">1. Hystrix Dashboard</h2>
<p>Hystrix Dashboard是Hystrix给我们提供的实时查看单机熔断情况的工具。需要配合SpringBoot Actuator使用。</p>
<h3 id="hystrix-dashboard使用方法">Hystrix Dashboard使用方法</h3>
<p>Hystrix Dashboard就是一个独立的图表工具，与业务没有任何关联。我们可以单独创建一个工程，引入dashboard的包</p>
<ol>
<li>需要的依赖</li>
</ol>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<ol start="2">
<li>
<p>启动类注解：@EnableHystrixDashboard</p>
</li>
<li>
<p>浏览器中访问：http://localhost:9000/hystrix 就可以打开dashboard首页了</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191203215429765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
</li>
</ol>
<p>dashboard地址和turbine地址说明：</p>
<blockquote>
<p>http://localhost:8092/actuator/hystrix.stream</p>
<p>ping的数据供dashboard收集成图表工具</p>
<p>把上述地址放到搜索框里面得到以下现象</p>
</blockquote>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191204192818771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>上条地址的图表数据来源如下：</p>
<p>springboot 提供的监控数据</p>
<p>首页访问信息(基于actuator的hystrix.stream)</p>
<p>访问地址：http://localhost:8092/actuator/</p>
<p>后面可拼的其他路径：</p>
<blockquote>
<p>beans、mappings、info、health。。。等</p>
</blockquote>
<pre><code class="language-yml">#hystris.stream的配置
management:
  server:
    port: 8092
  endpoints:
    web:
      base-path: /actuator
      #默认是health、info
      exposure:
        include: &quot;*&quot;

</code></pre>
<p>昨天还有一个知识点没练习完</p>
<h2 id="2-turbine聚合服务">2. Turbine（聚合服务）</h2>
<ul>
<li>DashBoard、turbine、hystrix stream三者之间的关系</li>
</ul>
<blockquote>
<p>在复杂的分布式系统中，相同服务的节点经常需要部署上百甚至上千个，很多时候，运维人员希望能够把相同服务的节点状态以一个整体集群的形式展现出来，这样可以更好的把握整个系统的状态。 为此，Netflix提供了一个开源项目（Turbine）来提供把多个hystrix.stream的内容聚合为一个数据源供Dashboard展示。</p>
</blockquote>
<h3 id="turbine与dashboard-hystrix-eventstream的关系">Turbine与Dashboard、Hystrix EventStream的关系</h3>
<figure data-type="image" tabindex="4"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3dpa2kvTmV0ZmxpeC9IeXN0cml4L2ltYWdlcy9kYXNoYm9hcmQtZGlyZWN0LXZzLXR1cmJpbmUtNjQwLnBuZw?x-oss-process=image/format,png" alt="Turbine与Dashboard关系图"></figure>
<h3 id="turbine的使用方法">Turbine的使用方法</h3>
<ol>
<li>
<p>引入Turbine依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-netflix-turbine&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
</li>
<li>
<p>配置Turbine要监控的服务</p>
<pre><code class="language-yml">server:
  port: 9005
  
#turbine 配置@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
turbine:
  app-config: calc-service-consumer-hystrix,calc-service-feign-consumer-with-hystrix
  cluster-name-expression: &quot;'default'&quot;
  aggregator:
    cluster-config: default

#eureka配置Turbine需要从Eureka中获取服务列表，然后遍历每个服务每个节点上的hystrix.stream数据，然后汇聚到一起
eureka:
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: node1.john.com
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8761

#hystrix.stream的配置@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;


</code></pre>
<blockquote>
<ul>
<li><code>turbine.appConfig</code>：配置Eureka中的serviceId列表，表明监控哪些服务</li>
<li><code>turbine.aggregator.clusterConfig</code>：指定聚合哪些集群，多个使用”,”分割，默认为default。可使用http...turbine.streamcluster={clusterConfig之一}访问</li>
<li><code>turbine.clusterNameExpression</code>：
<ol>
<li>clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称；</li>
<li>当clusterNameExpression default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default；</li>
<li>当clusterNameExpression metadata[‘cluster’]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster ABC，则需要配置，同时turbine.aggregator.clusterConfig ABC</li>
</ol>
</li>
</ul>
</blockquote>
<ol start="3">
<li>启动类：</li>
</ol>
<pre><code class="language-java">@SpringBootApplication
@EnableTurbine
public class TurbineConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(TurbineConsumerApplication.class,args);
    }
}


</code></pre>
<ol start="4">
<li>
<p>访问turbine.stream<br>
在浏览器中访问http://localhost:9005/turbine.stream 就可以看到配置到Turbine上的所有微服务产生的流式事件数据</p>
</li>
<li>
<p>在Hystrix Dashboard中查看所有、指定微服务的实时熔断监控。<br>
将上述地址输入到Hystrix Dashboard中即可查看所有微服务的监控情况，或者加上cluster=[clusterName] 参数，只看某个微服务的情况</p>
</li>
<li>
<p>在dashboard中查看聚合图表数据地址：http://localhost:9005/turbine.stream ?cluster=default</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191204202949425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
</li>
</ol>
</li>
</ol>
<h1 id="zuulnetflix-统一网关-地址路由">Zuul(Netflix) - 统一网关、地址路由</h1>
<p>主要用途：</p>
<h2 id="1-反向代理">1. 反向代理</h2>
<h2 id="2-统一权限校验">2. 统一权限校验</h2>
<h2 id="3-和hystrix的整合">3. 和hystrix的整合</h2>
<p>​		设置整体的熔断。</p>
<hr>
<h2 id="zuul介绍">Zuul介绍</h2>
<h2 id="在前端调用后台的时候加一层工程看似就访问了一个端口服务也就不存在跨域问题">（在前端调用后台的时候加一层工程（看似就访问了一个端口服务，也就不存在跨域问题））</h2>
<blockquote>
<p>Zuul是Netflx开源的微服务网关。可以和Eureka、Ribbon、Hystrix配合使用，一个主要的功能就是可以将后端众多的微服务屏蔽、整合，<mark>对前端提供一套统一的服务(有点像是后端的Facade)</mark>。</p>
</blockquote>
<h3 id="反向代理用法">反向代理用法：</h3>
<ol>
<li>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>
</li>
<li>
<p>配置文件</p>
<pre><code class="language-yml">server:
  port: 9100
spring:
  application:
    name: zuul-server

eureka:
  client:
    service-url:
      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
    eureka-server-port: 8765
  instance:
    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
    hostname: cloud.study.com

management:
  endpoints:
    web:
      exposure:
        include: &quot;*&quot;

zuul:
  routes:
    # 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径（更安全）
    #service-provider: /calcApi/**

    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: service-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
    #    taotao-rest-proxy:
    #      serviceId: taotao-rest
    #      path: /rest/**
    taotao-rest-proxy-forward: # 使用forward本地转发(就是将匹配到路由规则的请求，转发到网关本地应用中去处理)
      path: /rest-f/**
      url: forward:/rest
    # 比如浏览器访问：http://localhost:9100/api/rest-f/content/getall/89
    # 会被转发到：http://localhost:9100/rest/content/getall/89


  ignored-services: &quot;*&quot; # 忽略所有未显示配置路由规则的微服务
  prefix: /api
  strip-prefix: true  # 是否在网关层面消耗掉全局前缀

#淘淘商城测试
# 使用Zuul代理未接入Eureka的传统服务
taotao-rest:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList #如果不配置ServerList类型为ConfigurationBasedServerList的话就需要禁用ribbon的eureka支持
    ConnectTimeout: 500
    ReadTimeout: 2000
    listOfServers: http://localhost:8081

#和hystrix不同  （配置超时）
service-provider:   #微服务名称
  ribbon:
    ReadTimeout: 2000
    ConnectTimeout: 500

</code></pre>
</li>
<li>
<p>启动类</p>
<pre><code class="language-java">@SpringBootApplication
@EnableZuulProxy
@EnableEurekaClient
public class ZuulApplication {

    public static void main(String[] args) {
        SpringApplication.run(ZuulApplication.class,args);
    }
}

</code></pre>
<p>重点主要在它的application.yml文件中的配置。</p>
</li>
</ol>
<h3 id="zuul的访问超时控制">Zuul的访问超时控制</h3>
<h4 id="通过serviceid代理的请求">通过ServiceId代理的请求</h4>
<p>由于通过ServiceId的方式代理的请求(包括手动配置的Ribbon 服务和自动服务发现的服务)会走Ribbon和Hystrix，所以我们要控制超时就包括Ribbon请求的超时和Hystrix的访问超时。</p>
<pre><code class="language-yml">test-service:
  ribbon:
    ReadTimeout:100
    ConnectTimeout:500
    MaxAutoRetries:1
    MaxAutoRetriesNextServer:1

</code></pre>
<p>上面这段配置通过Zuul访问test-service服务时，Ribbon的ConnectTimeout是500ms，ReadTimeout是100ms，重试次数为1次； Zuul会根据ribbon设置的超时时间和重试次数，自动设置Hystrix的超时时间(上面这段配置, Zuul会把Hystrix的超时时间设置为:(100+500)*2=1200ms<br>
当然，我们也可以通过添加下面的配置显示指定Hystrix参数</p>
<pre><code class="language-yml">hystrix:
  command:
    service-calc-ribbon:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 3000

</code></pre>
<p>这里如果不显示设置，Zuul会根据ribbon设置的ConnectionTimeout和ReadTimeout自动确定Hystrix的超时时间（所以一般可以通过配置ribbon的超时时间来控制hystrix超时），由于ribbon默认重试次数是1，所以Hystrix的超时时间会被设置为(500+2000)*2=5000</p>
<h3 id="zuul的核心filter">Zuul的核心——Filter</h3>
<blockquote>
<p>Filter是Zuul的核心，用来实现对外服务的控制。Filter的生命周期有4个，分别是“PRE”、“ROUTING”、“POST”、“ERROR”，<br>
Zuul大部分功能都是通过过滤器来实现的，这些过滤器类型对应于请求的典型生命周期。</p>
</blockquote>
<ul>
<li>PRE： 这种过滤器在请求被路由之前调用。我们可利用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等。</li>
<li>ROUTING：这种过滤器将请求路由到微服务。这种过滤器用于构建发送给微服务的请求，并使用Apache HttpClient或Netfilx Ribbon请求微服务。</li>
<li>POST：这种过滤器在路由到微服务以后执行。这种过滤器可用来为响应添加标准的HTTP Header、收集统计信息和指标、将响应从微服务发送给客户端等。</li>
<li>ERROR：在其他阶段发生错误时执行该过滤器。 除了默认的过滤器类型，Zuul还允许我们创建自定义的过滤器类型。例如，我们可以定制一种STATIC类型的过滤器，直接在Zuul中生成响应，而不将请求转发到后端的微服务。</li>
</ul>
<h4 id="zuul中默认实现的filter">Zuul中默认实现的Filter</h4>
<table>
<thead>
<tr>
<th>类型</th>
<th>顺序</th>
<th>过滤器</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>pre</td>
<td>-3</td>
<td>ServletDetectionFilter</td>
<td>标记处理Servlet的类型</td>
</tr>
<tr>
<td>pre</td>
<td>-2</td>
<td>Servlet30WrapperFilter</td>
<td>包装HttpServletRequest请求</td>
</tr>
<tr>
<td>pre</td>
<td>-1</td>
<td>FormBodyWrapperFilter</td>
<td>包装请求体</td>
</tr>
<tr>
<td>route</td>
<td>1</td>
<td>DebugFilter</td>
<td>标记调试标志</td>
</tr>
<tr>
<td>route</td>
<td>5</td>
<td>PreDecorationFilter</td>
<td>处理请求上下文供后续使用</td>
</tr>
<tr>
<td>route</td>
<td>10</td>
<td>RibbonRoutingFilter</td>
<td>serviceId请求转发</td>
</tr>
<tr>
<td>route</td>
<td>100</td>
<td>SimpleHostRoutingFilter</td>
<td>url请求转发</td>
</tr>
<tr>
<td>route</td>
<td>500</td>
<td>SendForwardFilter</td>
<td>forward请求转发</td>
</tr>
<tr>
<td>post</td>
<td>0</td>
<td>SendErrorFilter</td>
<td>处理有错误的请求响应</td>
</tr>
<tr>
<td>post</td>
<td>1000</td>
<td>SendResponseFilter</td>
<td>处理正常的请求响应</td>
</tr>
</tbody>
</table>
<h4 id="禁用指定的filter">禁用指定的Filter</h4>
<pre><code class="language-yml">zuul:
  FormBodyWrapperFilter:
    pre:
	  disable: true

</code></pre>
<h4 id="自定义filter示例">自定义Filter示例</h4>
<p>我们假设有这样一个场景，因为服务网关应对的是外部的所有请求，为了避免产生安全隐患，我们需要对请求做一定的限制，比如请求中含有Token便让请求继续往下走，如果请求不带Token就直接返回并给出提示。</p>
<ol>
<li>
<p>首先自定义一个Filter，在run()方法中验证参数是否含有Token。</p>
<pre><code class="language-java">/**
 * 自定义网关过滤器
 */
@Component
public class TokenFilter extends ZuulFilter {

    /**
     * 过滤器类型
     * @return
     */
    public String filterType() {
        return &quot;pre&quot;;
    }

    /**
     * 过滤器顺序
     * @return
     */
    public int filterOrder() {
        return 2;
    }

    /**
     * 是否开启过滤
     * @return
     */
    public boolean shouldFilter() {
        return true;
    }

    /**
     * 过滤器中要执行的具体逻辑
     * @return
     * @throws ZuulException
     */
    public Object run() throws ZuulException {

        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest req = ctx.getRequest();

        String token = req.getHeader(&quot;token&quot;);
        if(token == null) {
            // 不对其进行路由，直接返回错误
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(403);
            ctx.setResponseBody(&quot;forbidden&quot;);
            return null;
        }
        // 检查token
        if(token.startsWith(&quot;abc&quot;)) {
            ctx.setSendZuulResponse(true);
            ctx.setResponseStatusCode(200);
            return null;
        }
        // 不对其进行路由，直接返回错误
        ctx.setSendZuulResponse(false);
        ctx.setResponseStatusCode(403);
        ctx.setResponseBody(&quot;invalid token&quot;);
        return null;
    }
}


</code></pre>
<ol start="2">
<li>将TokenFilter加入到请求拦截队列，在启动类中添加以下代码</li>
</ol>
<pre><code class="language-java">@Bean
public TokenFilter tokenFilter() {
	return new TokenFilter();
}

</code></pre>
<p>通过上面这例子我们可以看出，我们可以使用“PRE”类型的Filter做很多的验证工作，在实际使用中我们可以结合shiro、oauth2.0等技术去做鉴权、验证。</p>
</li>
</ol>
<h1 id="配置中心基于git仓库">配置中心（基于git仓库）</h1>
<blockquote>
<h2 id="1-解决重复配置">1. 解决重复配置</h2>
<h2 id="2-基于web的加密解密">2. 基于web的加密解密</h2>
<h2 id="3热更新配置动态">3.热更新配置（动态）</h2>
</blockquote>
<hr>
<blockquote>
<p>单台服务端的更新方式。</p>
<p>基于Springcloud bus （rabbitmq。。。或 kafka方式的更新配置</p>
</blockquote>
<h2 id="解决重复配置">解决重复配置</h2>
<p>需要依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 添加SpringCloud Bus amqp依赖，用于bus通知各个微服务刷新配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<p>配置文件：</p>
<pre><code class="language-yml">#这个文件不是必要的使用bootstrap.yml

server:
  port: 7000
spring:
  application:
    name: config-server
    #主要有关配置。
  cloud:
    config:
      server:
        git:
          uri: https://gitee.com/checkChen/Springcloud-config-server.git
          search-paths: test_repo  #精确到文件夹
          #也可以是本地地址
          #uri: file://${user.home}/work/test_repo
  #          username: xxx
  #          password: xxx
  #基于客户端配置消息中间件
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest

encrypt:
  key: lanou3g  # 配置一个自己的秘钥，用于对称加密算法加密


management:
  endpoints:
    web:
      exposure:
        include: bus-refresh


</code></pre>
<p>启动类：</p>
<pre><code class="language-java">@SpringBootApplication
@EnableConfigServer
public class ConfigApplication {
    public static void main(String[] args) {
        SpringApplication.run(ConfigApplication.class,args);
    }
}

</code></pre>
<p>模拟查看匹配到的配置文件(后面地址是模糊查询也可以很具体。)</p>
<blockquote>
<p>http://localhost:8888/app/dev</p>
<p>全都不匹配的话有个默认的application.properties/yml</p>
</blockquote>
<h3 id="客户端使用springcloud-config">客户端使用springcloud-config：</h3>
<p>server配置完成接下来consumer使用：</p>
<p>首先配置文件：</p>
<blockquote>
<p>bootstrap.yml是云配置优先级高于application.yml</p>
</blockquote>
<p>所需依赖：</p>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--基于普通consumer新添加依赖--&gt;
        &lt;!-- 配置中心客户端依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- 为了使用/refresh端点动态刷新配置，需要添加actuator依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

</code></pre>
<h3 id="配置文件">配置文件</h3>
<p><strong>application.yml:</strong></p>
<pre><code class="language-yml">spring:
  application:
    name: service-config-consumer

    
#git上已经配置
#eureka:
#  client:
#    service-url:
#      defaultZone: http://${eureka.instance.hostname}:${eureka.client.eureka-server-port}/eureka/
#    eureka-server-port: 8765
#  instance:
#    prefer-ip-address: true #在某些情况下，Eureka优先使用IP地址而不是主机名。设置为true，当应用程序向eureka注册时，它将使用其IP地址而不是其主机名
#    instance-id: ${spring.application.name}:${spring.application.instance_id:${server.port}}
#    hostname: cloud.study.com

server:
  port: 8082
  
management:
  endpoints:
    web:
      exposure:
        include: bus-refresh  #或者&quot;*&quot;

</code></pre>
<p><strong>bootstrap.yml:</strong></p>
<pre><code class="language-yml">spring:
  cloud:
    config:
      uri: http://localhost:7000   #config-server文件地址
      name: config-calc-consumer
#      profile: dev
#  拉取的二级路径profile

</code></pre>
<h3 id="配置映射参数">配置映射参数</h3>
<p>在SpringCloudConfig中，</p>
<ul>
<li>
<p>{application}对应<font color="red">客户端</font>配置的“spring.application.name”参数（如果指定了spring.cloud.config.name则以其为准。）；</p>
</li>
<li>
<p>{profile} 对应<font color="red">客户端</font>配置的“spring.profiles.active”参数（如果指定了spring.cloud.config.profile则以其为准。）；</p>
</li>
<li>
<p>{label}对应版本库中的branch(或tag)名称，取决于<font color="red">客户端</font>的“spring.cloud.config.label”参数决定。</p>
<p>如果分支名称中包含“/”，label配置中应该使用“（_）”替换，如foot/dev配置为foot(_)dev。</p>
</li>
</ul>
<h2 id="git仓库加密解密">git仓库加密解密</h2>
<p>命令：id_rsa.pub公钥、id_rsa秘钥（公钥的钥匙）</p>
<pre><code class="language-bash">$ cd ~/.ssh/

$ ls
id_rsa  id_rsa.pub  known_hosts

$ cat id_rsa

</code></pre>
<h2 id="配置加密解密">配置加密解密</h2>
<blockquote>
<h2 id="数据库如用户名密码">（数据库如：用户名密码）</h2>
</blockquote>
<h3 id="方法">方法：</h3>
<blockquote>
<p>使用命令行（参考SpringCloud笔记之微服务配置中心Config.pdf）</p>
<p>使用postman：http://localhost:7000/encrypt</p>
</blockquote>
<h3 id="对称加密">对称加密</h3>
<p>配置文件config-server加密、在客户端接收的发送回来的信息是解密后的。</p>
<pre><code class="language-yml">encrypt:
  key: lanou3g  # 配置一个自己的秘钥，用于对称加密算法加密

#加密后的串提交git仓库。(.yml文件必须加引号、.properties文件必须不加引号。)
password:
'{cipher}fda4hu54sd7a7df78sadf9aga7d6g'
</code></pre>
<h3 id="遇到的问题非法的key需要jce">遇到的问题：非法的key需要jce</h3>
<blockquote>
<p>在SpringCloud中实现RSA对称加密需要一些前提条件，首先要给jdk/jre配置JCE安装JCE加密可扩展。替换两个文件</p>
</blockquote>
<h3 id="非对称加密">非对称加密</h3>
<p>参见<a href="https://cloud.spring.io/spring-cloud-static/Greenwich.SR4/single/spring-cloud.html">官网</a>或笔记</p>
<h2 id="动态更新配置">动态更新配置：</h2>
<h3 id="单台客户端动态更新">单台客户端动态更新</h3>
<p>由于SpringCloud Config-Server端在每次客户端拉取配置时都会从远程仓库拉取最新的配置，所以Config- Server端的配置其实已经更新了， 我们要做的是让客户端应用更新配置，如果是单台客户端的话，我们直接通过SpringBoot提供的小下文断电中的：”/refresh“ 断电就可以了。具体步骤如下：</p>
<ol>
<li>加入SpringBoot actuator依赖</li>
<li>在需要支持动态刷新配置的类中添加@RefreshScope注解</li>
<li>访问http://localhost:port/refresh，即可刷新配置。（不支持get请求、可以使用postman）</li>
</ol>
<p>但是工作量很大、容易遗漏、要做到同时让所有客户端都刷新配置很麻烦。基于此SpringCould Config Server给我们提供了一种更便利的方式、基于Spring Cloud Bus的方式充当中间人通知所有客户端（配置变更相关的客户端）更新配置。</p>
<h3 id="多台客户端动态更新">多台客户端动态更新</h3>
<h4 id="使用工具环境搭建">使用工具，环境搭建：</h4>
<blockquote>
<p>erlang_otp_win64_21.3.exe</p>
<p>rabbitmq-server-3.7.22.exe</p>
</blockquote>
<p>安装之后修改rabbitmq_server-3.7.22\etc下的rabbitmq.config.example文件。</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191205152014137.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>登录密码</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191205152201927.png" alt="在这里插入图片描述"></figure>
<p>启动和访问地址</p>
<p>http://localhost:15672</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191205152101367.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>RabbitMQ 端口</p>
<p>-   4369 (epmd), 25672 (Erlang distribution)</p>
<p>-   5672, 5671 (AMQP 0-9-1 without and with TLS)</p>
<p>-   15672 (if management plugin is enabled)</p>
<p>-   61613, 61614 (if STOMP is enabled)</p>
<p>-   1883, 8883 (if MQTT is enabled)</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/2019120515212966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>安装步骤：</p>
<pre><code class="language-ruby">Windows安装ribbitmq步骤：
https://blog.csdn.net/qq_38931949/article/details/95513014
https://www.rabbitmq.com/install-windows.html（官方说明）


配置中心加密错误： https://bbs.csdn.net/topics/392514733
解决办法： https://blog.csdn.net/qq_36827957/article/details/81777333
</code></pre>
<h4 id="springcloud-config-server端配置">SpringCloud  Config  Server端配置</h4>
<ol>
<li>
<p>添加bus依赖</p>
<pre><code class="language-xml">&lt;!-- 添加SpringCloud Bus amqp依赖，用于bus通知各个微服务刷新配置 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
</ol>
<blockquote>
<p>这里我们用的是rabbitmq，所以添加的是amqp依赖、如果消息中间件用的是kafka的话就换成bus-kafka依赖。</p>
</blockquote>
<ol start="2">
<li>
<p>配置消息中间件</p>
<pre><code class="language-yml">#基于客户端配置消息中间件
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest
    password: guest
</code></pre>
</li>
<li>
<p>当配置修改完成，并且push到远程仓库之后，执行下面的请求。</p>
<blockquote>
<p>新版地址不同有变化。</p>
<p>旧版本：http://localhost:7000/bus/refresh</p>
<p>新版本：http://localhost:7000/actuator/bus-refresh</p>
<p>必须要配置如下server - config端</p>
<pre><code class="language-yml">management:
endpoints:
 web:
   exposure:
     include: bus-refresh  #或者&quot;*&quot;
</code></pre>
<p>访问Config Server 的actuator/bus-refresh端点，触发Config 的检查更新。（必须post请求）</p>
</blockquote>
</li>
</ol>
<h4 id="springcloud-client端">SpringCloud -client端</h4>
<blockquote>
<p>重复 1.添加bus依赖 2. 配置消息中间件</p>
</blockquote>
<h1 id="课堂知识">课堂知识：</h1>
<p>查看可调用的服务（可以配个虚假的就是不和服务名保持一致（提高安全性））：http://localhost:9100/actuator/routes   （方式如下）</p>
<blockquote>
<p><mark>理解如下：</mark></p>
<p><strong>此地址用来查看使用zuul代理服务（如：taotao-rest(只是服务的名字)）的访问路径地址    配合（属性strip-prefix: true  # 是否在网关层面消耗掉全局前缀即path：/api——最简化通过zuul的访问地址）</strong></p>
</blockquote>
<pre><code class="language-yml"># 这种方式配置路由规则：前面的key是微服务名称，后面是匹配路径（更安全）
    service-provider: /calcApi/**
    
    # 这种方式配置路由规则：第一级的key可以随便取（路由名称），下面可以配置更多key、value（相比上面一种配置更强大）
    calc-proxy:
      serviceId: service-provider # 有效的微服务名称
      path: /calc/**  # 访问路径
      strip-prefix: false # 是否在网关层面消耗掉指定服务的路由规则前缀
    
    
    
  ignored-services: &quot;*&quot; # 忽略所有未显示配置路由规则的微服务
</code></pre>
<h1 id="遇到的问题-2">遇到的问题</h1>
<ol>
<li>所需工具：</li>
</ol>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20191204203451601.png" alt="在这里插入图片描述"></figure>
<ol start="2">
<li>安装步骤：</li>
</ol>
<pre><code class="language-ruby">Windows安装步骤：
https://blog.csdn.net/qq_38931949/article/details/95513014
https://www.rabbitmq.com/install-windows.html（官方说明）


配置中心加密错误： https://bbs.csdn.net/topics/392514733
解决办法： https://blog.csdn.net/qq_36827957/article/details/81777333
</code></pre>
<ol start="3">
<li>
<p>小知识</p>
<blockquote>
<p>iml是 intellij idea的工程配置文件，里面是当前 project 的一些配置信息。.Idea 存放项目的配置信息，包括历史记录，版本控制信息等。</p>
</blockquote>
</li>
<li>
<p>通过配置代理服务</p>
<pre><code class="language-yml"># 使用Zuul代理未接入Eureka的传统服务
taotao-rest:
  ribbon:
    NIWSServerListClassName: com.netflix.loadbalancer.ConfigurationBasedServerList #如果不配置ServerList类型为ConfigurationBasedServerList的话就需要禁用ribbon的eureka支持
    ConnectTimeout: 500
    ReadTimeout: 2000
    listOfServers: http://localhost:8081
</code></pre>
</li>
<li>
<p>属性：（通过）</p>
<pre><code class="language-yml">zuul:
  routes:
    microserver-calc: /calcs/**  #指定的服务下

  prefix: /api
  strip-prefix: true  # 是否在网关层面消耗掉全局前缀即/api
</code></pre>
</li>
<li>
<p>测试forward的路径</p>
<pre><code class="language-java">@RestController
//@RequestMapping(&quot;/rest&quot;)
public class TestController {

    //@RequestMapping(&quot;/content/getall/{id}&quot;)
  @RequestMapping(&quot;/**&quot;)
 public void handlerRequest(HttpServletRequest req) {
        StringBuffer requestURL = req.getRequestURL();
      //得到完整路径forward后的地址。
        System.out.println(requestURL.toString());
    }

}

</code></pre>
</li>
<li>
<p>本地转发(forward);地址栏没变forward只是把结果带到页面：在地址栏<mark>再</mark>拼路径</p>
<pre><code class="language-yml">zuul:
  routes:
    route-name:
      path: /path-a/**
      url: forward:/path-b
      
      
      
      
taotao-rest-proxy-forward: # 使用forward本地转发(就是将匹配到路由规则的请求，转发到网关本地应用中去处理)
      path: /rest-f/**
      url: forward:/rest
    # 比如浏览器访问：http://localhost:9100/api/rest-f/content/getall/89
    # 会被转发到：http://localhost:9100/rest/content/getall/89

</code></pre>
</li>
<li>
<p>nginx代理很重要！（实现集群）</p>
</li>
</ol>
<hr>
<p><span style="color:red;float:right">Author:CheckChen</span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Dubbo学习步骤]]></title>
        <id>https://cxp-twx.github.io/post/dubbo-xue-xi-bu-zou</id>
        <link href="https://cxp-twx.github.io/post/dubbo-xue-xi-bu-zou">
        </link>
        <updated>2019-11-27T08:56:18.000Z</updated>
        <content type="html"><![CDATA[<h1 id="dubbo框架笔记">Dubbo框架笔记</h1>
<h2 id="dubbo介绍">Dubbo介绍</h2>
<h3 id="互联网架构演变过程">互联网架构演变过程</h3>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1YmJvLmFwYWNoZS5vcmcvZG9jcy96aC1jbi91c2VyL3NvdXJjZXMvaW1hZ2VzL2R1YmJvLWFyY2hpdGVjdHVyZS1yb2FkbWFwLmpwZw?x-oss-process=image/format,png" alt=""></figure>
<h4 id="单一应用架构">单一应用架构</h4>
<p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>
<h4 id="垂直应用架构">垂直应用架构</h4>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<h4 id="分布式服务架构">分布式服务架构</h4>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<h4 id="流动计算架构">流动计算架构</h4>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。</p>
<h3 id="dubbo解决了什么问题">Dubbo解决了什么问题</h3>
<p>在大规模服务化之前，应用可能只是通过 RMI 或 Hessian 等工具，简单的暴露和引用远程服务，通过配置服务的URL地址进行调用，通过 F5 等硬件进行负载均衡。</p>
<p><strong>当服务越来越多时，服务 URL 配置管理变得非常困难，F5 硬件负载均衡器的单点压力也越来越大。</strong> 此时需要一个服务注册中心，动态地注册和发现服务，使服务的位置透明。并通过在消费方获取服务提供方地址列表，实现软负载均衡和 Failover，降低对 F5 硬件负载均衡器的依赖，也能减少部分成本。</p>
<p><strong>当进一步发展，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。</strong> 这时，需要自动画出应用间的依赖关系图，以帮助架构师理清理关系。</p>
<p><strong>接着，服务的调用量越来越大，服务的容量问题就暴露出来，这个服务需要多少机器支撑？什么时候该加机器？</strong> 为了解决这些问题，第一步，要将服务现在每天的调用量，响应时间，都统计出来，作为容量规划的参考指标。其次，要可以动态调整权重，在线上，将某台机器的权重一直加大，并在加大的过程中记录响应时间的变化，直到响应时间到达阈值，记录此时的访问量，再以此访问量乘以机器数反推总容量。</p>
<p>除了服务注册中心之外， Dubbo还帮我们解决了服务远程调用的问题。 之前我们需要显示通过HttpClient、OkHttp、RestTemplate。。这些技术去通过Http协议调用远程服务，其间还要手动处理序列化、反序列化问题。而Dubbo将这些细节屏蔽了，对于我们开发者来说，调用远程的服务就像调用本地服务一样方便。</p>
<blockquote>
<p>总的来说， Dubbo主要帮我们解决了分布式应用中的服务注册发现和RPC（Remote Procedure Call）远程调用这两个核心问题。</p>
</blockquote>
<h2 id="快速开始">快速开始</h2>
<p>因为服务提供者和服务消费者都需要引入共同的服务接口。所以在Dubbo的最佳实践上要求我们将服务接口抽出来作为单独的一个模块，供服务提供者、消费者引用。这样Dubbo应用就包含三部分：共同的api接口、服务提供者、服务消费者三部分（其中服务提供者和消费者都需要依赖API接口）</p>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191127211649968.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<ol>
<li>
<p>引入依赖</p>
<p>依赖主要包含： Spring、Dubbo</p>
<pre><code class="language-xml">&lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;spring.version&gt;5.2.1.RELEASE&lt;/spring.version&gt;
    &lt;dubbo.version&gt;2.7.3&lt;/dubbo.version&gt;
&lt;/properties&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework&lt;/groupId&gt;
    &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
    &lt;version&gt;${spring.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo&lt;/artifactId&gt;
    &lt;version&gt;${dubbo.version}&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
<li>
<p>编写核心API接口</p>
<p>新建一个单独的maven module(如<code>dubbo-service-api</code>)，在里面添加需要远程访问的接口</p>
<pre><code class="language-java">public interface ICalcService {

    int plus(int num1, int num2);

    int minus(int num1, int num2);

}
</code></pre>
</li>
<li>
<p>开发服务提供者</p>
<p>​	新建单独的服务提供者模块 (如<code>dubbo-service-provider</code>)</p>
<ol>
<li>
<p>开发API接口实现逻辑</p>
<pre><code class="language-java">public class CalcServiceImpl implements ICalcService {
    public int plus(int num1, int num2) {
        int result = num1 + num2;
        System.out.println(num1 + &quot; + &quot; + num2 + &quot; = &quot; + result);
        return result;
    }

    public int minus(int num1, int num2) {
        int result = num1 - num2;
        System.out.println(num1 + &quot; - &quot; + num2 + &quot; = &quot; + result);
        return result;
    }
}
</code></pre>
</li>
<li>
<p>通过Dubbo注册中心暴露服务（发布服务到注册中心）</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://dubbo.apache.org/schema/dubbo
        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 给dubbo应用命名 --&gt;
    &lt;dubbo:application name=&quot;hello-dubbo&quot;&gt;
        &lt;dubbo:parameter key=&quot;qos.enable&quot; value=&quot;false&quot; /&gt;
    &lt;/dubbo:application&gt;

    &lt;!-- 配置Dubbo服务注册中心（这里使用的是基于multicast协议的注册中心） --&gt;
    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234&quot; /&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;
    
    &lt;!-- 对外暴露服务 --&gt;
    &lt;dubbo:service interface=&quot;com.lanou3g.dubbo.service.ICalcService&quot; ref=&quot;calcService&quot; /&gt;

    &lt;bean id=&quot;calcService&quot; class=&quot;com.lanou3g.dubbo.service.impl.CalcServiceImpl&quot; /&gt;

&lt;/beans&gt;
</code></pre>
</li>
<li>
<p>启动服务提供者</p>
<pre><code class="language-java">public class ProviderApplication {
    public static void main(String[] args) throws IOException {

        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
        ctx.start();
        ctx.registerShutdownHook();

        System.out.println(&quot;Provider启动完成&quot;);

        // 阻塞当前应用，直到输入任意字符后才退出
        System.in.read();
    }
}
</code></pre>
</li>
</ol>
</li>
<li>
<p>开发服务消费者</p>
<p>​	新建一个单独的服务消费者模块(如<code>dubbo-service-consumer</code>)</p>
<ol>
<li>
<p>通过Dubbo注册中心引用远程服务</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xmlns:dubbo=&quot;http://dubbo.apache.org/schema/dubbo&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://dubbo.apache.org/schema/dubbo
        http://dubbo.apache.org/schema/dubbo/dubbo.xsd&quot;&gt;

    &lt;!-- 给dubbo应用命名 --&gt;
    &lt;dubbo:application name=&quot;hello-dubbo&quot;&gt;
        &lt;dubbo:parameter key=&quot;qos.enable&quot; value=&quot;false&quot; /&gt;
    &lt;/dubbo:application&gt;

    &lt;!-- 配置Dubbo服务注册中心（这里使用的是基于multicast协议的注册中心） --&gt;
    &lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234?unicast=false&quot; /&gt;

    &lt;!-- 指定Dubbo底层在远程调用服务时通过什么协议，哪个端口调用 --&gt;
    &lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;

    &lt;dubbo:reference id=&quot;calcService&quot; interface=&quot;com.lanou3g.dubbo.service.ICalcService&quot; /&gt;

&lt;/beans&gt;
</code></pre>
</li>
</ol>
</li>
<li>
<p>通过公共的API接口调用服务方法，完成远程接口调用</p>
<pre><code class="language-java">   public class ConsumerApplication {
       public static void main(String[] args) {
           ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
           ctx.registerShutdownHook();
           ctx.start();
   
           // 通过公共接口像调用本地方法一样调用远程服务
   		ICalcService calcService = ctx.getBean(&quot;calcService&quot;, ICalcService.class);
           int result = calcService.plus(11, 89);
           System.out.println(&quot;调用远程服务计算结果：&quot; + result);
       }
   }
</code></pre>
</li>
</ol>
<h2 id="深入dubbo知识点">深入Dubbo知识点</h2>
<h3 id="dubbo的架构图">Dubbo的架构图</h3>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2R1YmJvLmFwYWNoZS5vcmcvZG9jcy96aC1jbi91c2VyL3NvdXJjZXMvaW1hZ2VzL2R1YmJvLWFyY2hpdGVjdHVyZS5qcGc?x-oss-process=image/format,png" alt=""></figure>
<ol start="0">
<li>服务容器负责启动，加载，运行服务提供者。</li>
<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>
<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>
<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>
<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>
<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>
</ol>
<h3 id="dubbo中的角色">Dubbo中的角色</h3>
<table>
<thead>
<tr>
<th>节点</th>
<th>角色说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Provider</code></td>
<td>暴露服务的服务提供方</td>
</tr>
<tr>
<td><code>Consumer</code></td>
<td>调用远程服务的服务消费方</td>
</tr>
<tr>
<td><code>Registry</code></td>
<td>服务注册与发现的注册中心</td>
</tr>
<tr>
<td><code>Monitor</code></td>
<td>统计服务的调用次数和调用时间的监控中心</td>
</tr>
<tr>
<td><code>Container</code></td>
<td>服务运行容器</td>
</tr>
</tbody>
</table>
<h3 id="dubbo支持的服务注册中心">Dubbo支持的服务注册中心</h3>
<h4 id="基于zookeeper的注册中心">基于Zookeeper的注册中心</h4>
<ol>
<li>
<p>需要启动zookeeper服务</p>
<p>下载、启动zookeeper服务</p>
</li>
<li>
<p>在dubbo的应用中修改注册中心配置为zookeeper方式</p>
<pre><code class="language-xml">&lt;!-- 服务提供方和消费方都添加如下配置 --&gt;
&lt;!-- 配置基于zookeeper的服务注册中心  --&gt;
&lt;!--&lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; client=&quot;curator&quot; /&gt;--&gt;
</code></pre>
</li>
<li>
<p>在dubbo应用中需要添加zookeeper客户端依赖</p>
<pre><code class="language-xml">&lt;!-- zookeeper客户端 —— curator依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.netflix.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
    &lt;version&gt;1.1.10&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
    &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
    &lt;version&gt;4.0.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ol>
<h4 id="基于redis的注册中心">基于Redis的注册中心</h4>
<ol>
<li>
<p>启动redis服务</p>
</li>
<li>
<p>修改注册中心配置为redis</p>
<pre><code class="language-xml">&lt;!-- 配置基于redis的服务注册中心 --&gt;
&lt;dubbo:registry address=&quot;redis://localhost:6379&quot; /&gt;
</code></pre>
<blockquote>
<p>注意： 如果说Redis需要口令验证，则不能作为Dubbo的注册中心</p>
</blockquote>
</li>
<li>
<p>添加redis客户端依赖到工程中（服务提供者、消费者都需要）</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
    &lt;version&gt;2.7.0&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;redis.clients&lt;/groupId&gt;
    &lt;artifactId&gt;jedis&lt;/artifactId&gt;
    &lt;version&gt;3.1.0&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
</li>
</ol>
<h4 id="基于multicast组播的注册中心">基于Multicast组播的注册中心</h4>
<blockquote>
<p>参见快速开始配置</p>
</blockquote>
<h2 id="dubbo支持的配置方式">Dubbo支持的配置方式</h2>
<p>Dubbo支持以下几种方式的配置方式：</p>
<ul>
<li>基于SpringBean的XML配置</li>
<li>基于注解的配置</li>
<li>基于Properties属性文件的配置</li>
<li>基于硬编码的配置</li>
<li>支持加载存储在外部配置中心中的配置（如存储在zookeeper中的dubbo.properties配置）</li>
</ul>
<h3 id="dubbo支持的rpc通讯协议">Dubbo支持的RPC通讯协议</h3>
<p>Dubbo支持以下几种服务远程调用的通讯协议：</p>
<ul>
<li>dubbo(默认)</li>
<li>rest</li>
<li>http</li>
<li>redis</li>
<li>webservice</li>
<li>......</li>
</ul>
<h2 id="springboot整合dubbo">SpringBoot整合Dubbo</h2>
<p>现在SpringBoot技术非常流行，可以极大程度上让我们从管理项目依赖和配置的工作中解放出来，更专注于核心业务实现（更傻瓜），Dubbo官方也提供了对SpringBoot的支持。</p>
<p>使用步骤如下：</p>
<h3 id="第一步在parent中定义所有依赖">第一步：在parent中定义所有依赖</h3>
<p>在企业开发中的建议做法，便于统一管理整个工程中所有模块的依赖和版本。如果你不想这样做，这步可以省略，直接在各个module中添加需要的依赖也是可以滴。</p>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.lanou3g&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-springboot-parent&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

    &lt;properties&gt;
        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
        &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
        &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;/properties&gt;

    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;!-- 引入SpringBoot --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.2.1.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;

            &lt;!-- dubbo springboot依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
                &lt;version&gt;2.7.3&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- redis注册中心依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
                &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
                &lt;version&gt;2.7.0&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;redis.clients&lt;/groupId&gt;
                &lt;artifactId&gt;jedis&lt;/artifactId&gt;
                &lt;version&gt;3.1.0&lt;/version&gt;
            &lt;/dependency&gt;

            &lt;!-- zookeeper注册中心依赖 --&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.netflix.curator&lt;/groupId&gt;
                &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
                &lt;version&gt;1.1.10&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
                &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
                &lt;version&gt;4.0.1&lt;/version&gt;
            &lt;/dependency&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.lanou3g&lt;/groupId&gt;
                &lt;artifactId&gt;dubbo-springboot-api&lt;/artifactId&gt;
                &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<h3 id="第二步定义公共的服务api接口模块">第二步：定义公共的服务API接口模块</h3>
<p>该模块不需要添加什么依赖， 主要是定义各个服务的接口文件。以便让服务提供者和消费者依赖和复用。</p>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.lanou3g&lt;/groupId&gt;
    &lt;artifactId&gt;dubbo-springboot-api&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>服务接口示例：</li>
</ul>
<p>IHelloService.java</p>
<pre><code class="language-java">package com.lanou3g.dubbo.service;

public interface IHelloService {
    String hello();
    String hello(String name);
}
</code></pre>
<h3 id="第三步开发服务提供者模块">第三步：开发服务提供者模块</h3>
<p>该模块提供了服务接口的具体实现逻辑，并且通过Dubbo的服务注册中心将服务暴露出去。</p>
<ul>
<li>pom.xml</li>
</ul>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;dubbo-springboot-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.lanou3g&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
        &lt;relativePath&gt;../dubbo-springboot-parent/pom.xml&lt;/relativePath&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;dubbo-springboot-provider&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- redis注册中心依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!-- 如果注册中心是zookeeper换成此依赖 --&gt;
        &lt;!--&lt;dependency&gt;
            &lt;groupId&gt;com.netflix.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
        &lt;/dependency&gt;
		--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.lanou3g&lt;/groupId&gt;
            &lt;artifactId&gt;dubbo-springboot-api&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<ul>
<li>服务实现示例代码</li>
</ul>
<p>HelloService.java</p>
<pre><code class="language-java">package com.lanou3g.provider.service;

import com.lanou3g.dubbo.service.IHelloService;
import org.apache.dubbo.config.annotation.Service;

// 通过此注解将服务注册到Dubbo的服务注册中心（注意包名是dubbo而不是spring的）
// 该注解还支持添加服务的版本、所属组等参数，都是可选的
@Service
public class HelloService implements IHelloService {
    @Override
    public String hello() {
        String msg = &quot;Hello Dubbo&quot;;
        System.out.println(msg);
        return msg;
    }

    @Override
    public String hello(String name) {
        String msg = &quot;Hello, &quot; + name;
        System.out.println(msg);
        return msg;
    }
}
</code></pre>
<ul>
<li>配置Dubbo的注册中心、应用名等参数</li>
</ul>
<p>application.yml</p>
<pre><code class="language-yml">dubbo:
  application:
    name: hello-dubbo-springboot
    qos-enable: false

  registry:
    address: redis://localhost:6379
</code></pre>
<ul>
<li>启动类</li>
</ul>
<p>ProviderApplication.java</p>
<pre><code class="language-java">package com.lanou3g;

import org.apache.dubbo.config.spring.context.annotation.EnableDubbo;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
// 服务提供方一定要添加此注解，开启Dubbo的注解扫描（扫描我们配置的@Service注解）
@EnableDubbo(scanBasePackages = &quot;com.lanou3g.provider.service&quot;)
public class ProvicerApplication {
    public static void main(String[] args) {
        SpringApplication.run(ProvicerApplication.class, args);
    }
}

</code></pre>
<h3 id="第四步开发服务消费者模块">第四步：开发服务消费者模块</h3>
<p>该模块同样依赖公共的服务接口模块，通过接口类型，结合Dubbo的服务中心和RPC可以像调用本地Service方法一样调用远程的服务接口实现。</p>
<ul>
<li>
<p>pom依赖</p>
<p>和服务提供者一样，参见上面服务提供者pom文件</p>
</li>
<li>
<p>配置Dubbo的注册中心、应用名等参数</p>
<p>application.yml</p>
<pre><code class="language-yml">dubbo:
  application:
    name: hello-dubbo-springboot
    qos-enable: false

  registry:
    address: redis://localhost:6379
</code></pre>
</li>
<li>
<p>在需要调用远程服务的地方通过Dubbo引入远程服务（这里直接在Application类中通过生命周期方法调用）</p>
<p>ConsumerApplication.java</p>
<pre><code class="language-java">package com.lanou3g;

import com.lanou3g.dubbo.service.IHelloService;
import org.apache.dubbo.config.annotation.Reference;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import javax.annotation.PostConstruct;

@SpringBootApplication
public class ConsumerApplication {
    
    // 通过Dubbo提供的Reference注解引用远程服务
    // 如果服务提供者暴露服务时配置的版本、所属组等参数，这里引用时也需要加上，所有参数匹配才能调用
    @Reference
    private IHelloService helloService;

    public static void main(String[] args) {
        SpringApplication.run(ConsumerApplication.class, args);
    }

    @PostConstruct
    public void invokeService() {
        String result = helloService.hello();
        System.out.println(&quot;远程服务hello()调用结果: &quot; + result);

        result = helloService.hello(&quot;John&quot;);
        System.out.println(&quot;远程服务hello(name)调用结果: &quot; + result);
    }
}
</code></pre>
</li>
</ul>
<h2 id="dubbo监控工具dubboadmin">Dubbo监控工具DubboAdmin</h2>
<ol>
<li>
<p>下载安装</p>
</li>
<li>
<p>修改配置</p>
<p>主要修改dubbo注册中心地址为你现在使用的注册中心地址：</p>
<pre><code class="language-proper">dubbo.registry.address=zookeeper://teacher.lanou.com:2181?client=curator
# dubbo.registry.address=multicast://224.5.6.7:1234?unicast=false
# dubbo.registry.address=redis://127.0.0.1:6379
</code></pre>
</li>
<li>
<p>重新打包</p>
<pre><code>mvn clean package
</code></pre>
</li>
<li>
<p>启动</p>
<pre><code>java -jar dubbo-admin-0.0.1-SNAPSHOT.jar
</code></pre>
</li>
<li>
<p>使用方法</p>
<p>登录时，用户名和密码都是root</p>
<p>界面效果：</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191129085610131.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
</li>
</ol>
<h2 id="常见问题">常见问题</h2>
<h3 id="问题一找不到服务提供者">问题一：找不到服务提供者</h3>
<p>问题描述：</p>
<p>​		使用multicast注册中心时，一直报 <code>No provider available for the service xxxx Service1</code></p>
<p>问题原因：</p>
<p>​		dubbo的服务消费方在服务注册中心中无法找到匹配的服务提供者，导致服务无法调用</p>
<p>问题解决：</p>
<ol>
<li>
<p>检查服务提供者、消费者配置是否和快速开始或者官方multicast示例中一致</p>
</li>
<li>
<p>如果服务提供者和消费者处于同一台服务器上，或者一个服务提供者有多个服务消费者，在消费者这方需要关闭multicast的单播模式，改为广播模式，否则消费者可能无法接收到服务提供者发出的服务注册消息。</p>
<pre><code class="language-xml">&lt;dubbo:registry address=&quot;multicast://224.5.6.7:1234?unicast=false&quot; /&gt;
</code></pre>
<p>或</p>
<pre><code class="language-xml">&lt;dubbo:registry protocol=&quot;multicast&quot; address=&quot;224.5.6.7:1234&quot;&gt;
    &lt;dubbo:parameter key=&quot;unicast&quot; value=&quot;false&quot; /&gt;
&lt;/dubbo:registry&gt;
</code></pre>
<p>参见：<a href="http://dubbo.apache.org/zh-cn/docs/user/references/registry/multicast.html">官方说明</a></p>
</li>
<li>
<p>如果上面两步都排除掉了，依然无法解决。 使用终极大法，将你的网线拔掉，或者网络断掉，然后重启服务提供者、消费者，你会发现已经解决了。之后你再插上网线也不会再有问题，就是这么神奇~</p>
</li>
</ol>
<h3 id="问题二启动消费者时有qos-server无法启动的警告">问题二：启动消费者时，有qos server无法启动的警告</h3>
<p>问题描述：</p>
<pre><code>警告:  [DUBBO] Fail to start qos server: , dubbo version: 2.7.3, current host: 10.10.13.127
java.net.BindException: Address already in use: bind
</code></pre>
<p>问题原因：</p>
<pre><code>通常这种情况发生在消费者和提供者运行在同一台服务器上，因为dubbo应用在启动时默认会启动一个心跳服务运行在22222端口，当一台服务器运行多个dubbo应用时，就会端口冲突。

</code></pre>
<p>问题解决：</p>
<p>​	在开发过程中可以直接将qos心跳服务停掉</p>
<pre><code class="language-xml">&lt;dubbo:application name=&quot;hello-dubbo&quot;&gt;
    &lt;!-- 关闭qos心跳服务 --&gt;
    &lt;dubbo:parameter key=&quot;qos.enable&quot; value=&quot;false&quot; /&gt;
&lt;/dubbo:application&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程]]></title>
        <id>https://cxp-twx.github.io/post/duo-xian-cheng</id>
        <link href="https://cxp-twx.github.io/post/duo-xian-cheng">
        </link>
        <updated>2019-11-25T02:49:33.000Z</updated>
        <content type="html"><![CDATA[<h1 id="多线程">多线程</h1>
<h4 id="前言">前言：</h4>
<h4 id="1-什么是进程">1、什么是进程？</h4>
<p>一个正在运行的程序就是一个进程。进程是操作系统资源分配（计算资源，比如CPU，存储：内存）的最小单位。</p>
<h4 id="2-什么是线程">2、什么是线程</h4>
<p>线程是资源调度的最小单位（线程在消耗资源）。线程的主要作用执行任务，一个线程可以执行很多任务。</p>
<h2 id="什么是单线程">什么是单线程？</h2>
<p>如果一个进程，只有一个线程。这样的程序叫做单线程程序。</p>
<p>好处：资源可以最大化使用。不会出现争夺资源的问题。</p>
<p>缺陷：效率很低，容易阻塞。无法处理并发任务（例如：多人聊天）。</p>
<p>当你程序启动的时候，JVM会创建一个线程执行你的main函数，这个线程称为主线程。</p>
<h2 id="什么是多线程">什么是多线程？</h2>
<p>如果一个进程，拥有不止一个线程。这样的程序称为多线程程序。</p>
<p>优势：可以同时执行多个任务。提高运行的效率。</p>
<h3 id="什么时候使用多线程">什么时候使用多线程？</h3>
<ol>
<li>多个任务互不影响，任务之间没有交集，谁先执行完，谁后执行完无所谓。这种时候可以使用多线程，让多个任务同时执行。</li>
<li>当你有一个任务很耗时，可以把这个耗时的任务放到一个单独线程里执行，这样就不会阻塞程序的执行。</li>
<li>你的需求只能靠多线程（多人聊天，英雄联盟各个角色的操作）完成的时候，要使用多线程。</li>
</ol>
<h3 id="如何使用多线程">如何使用多线程?</h3>
<ol>
<li>使用Thread的子类</li>
<li>让一个类实现Runable接口</li>
</ol>
<h4 id="一-使用thread的子类">一、使用Thread的子类</h4>
<ol>
<li>创建一个类继承于Thread。</li>
<li>重写这个类的run方法。</li>
</ol>
<pre><code class="language-java">public class MyThread extends Thread {

	public MyThread() {
		super();
	}

	public MyThread(String name) {
		super(name);
	}

	@Override
	public void run() {
		System.out.println(&quot;我是一个子线程&quot;);
		for(int i = 0; i &lt; 500000; i++) {
			System.out.println(i);
		}
	}
}
</code></pre>
<blockquote>
<p>MyThread是一个类，因此可以根据需要添加属性以及方法，也就是说普通类能有的这个类都可以有。</p>
</blockquote>
<ol start="3">
<li>创建MyThread类的对象</li>
<li>启动线程</li>
</ol>
<pre><code class="language-java">public class TestMultiplyThread2 {

	public static void main(String[] args) {
		
		Thread mt = new MyThread(&quot;线程A&quot;);
		//mt.run();//如果直接调用run方法，并不会新的线程中执行任务。
		mt.start();//start方法才在新的线程中执行run方法。
		
		System.out.println(&quot;hello world&quot;);
	}

}
</code></pre>
<hr>
<p>匿名类的写法</p>
<pre><code class="language-java">public class TestMultiplyThread2 {

	public static void main(String[] args) {
		Thread t1 = new Thread(&quot;线程B&quot;) {
			@Override
			public void run() {
				System.out.println(&quot;我是一个子线程&quot;);
				for(int i = 0; i &lt; 500000; i++) {
					System.out.println(i);
				}
			}
		};
		t1.start();
		
		System.out.println(&quot;hello world&quot;);
	}

}
</code></pre>
<h4 id="二-让一个类实现runnable接口">二、让一个类实现Runnable接口</h4>
<ol>
<li>创建一个类实现Runnable接口</li>
<li>实现接口中的run方法</li>
</ol>
<pre><code class="language-java">public class MyRunnable implements Runnable {

	@Override
	public void run() {
		System.out.println(&quot;我是一个子线程&quot;);
		for(int i = 0; i &lt; 500000; i++) {
			System.out.println(i);
		}
	}
}
</code></pre>
<ol start="3">
<li>创建实现类的对象</li>
<li>实现类的对象作为Thread类的参数</li>
<li>启动线程</li>
</ol>
<pre><code class="language-java">public class TestMultiplyThread3 {

	public static void main(String[] args) {
		Runnable mr = new MyRunnable();
		Thread t = new Thread(mr);
		t.start();
		System.out.println(&quot;hello world&quot;);
	}
}
</code></pre>
<hr>
<p>匿名类的写法：</p>
<pre><code class="language-java">public class TestMultiplyThread3 {

	public static void main(String[] args) {
//		Runnable mr = new MyRunnable();
		Runnable mr = new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;我是一个子线程&quot;);
				for(int i = 0; i &lt; 500000; i++) {
					System.out.println(i);
				}
			}
		};
		Thread t = new Thread(mr);
		t.start();
		System.out.println(&quot;hello world&quot;);
	}
}
</code></pre>
<hr>
<p>lambda表达式写法：</p>
<pre><code class="language-java">public class TestMultiplyThread3 {

	public static void main(String[] args) {

		Runnable mr = () -&gt; {
			System.out.println(&quot;我是一个子线程&quot;);
			for(int i = 0; i &lt; 500000; i++) {
				System.out.println(i);
			}
		};
		Thread t = new Thread(mr);
		t.start();
		System.out.println(&quot;hello world&quot;);
	}
}
</code></pre>
<h3 id="多线程的常用方法">多线程的常用方法</h3>
<p>currentThread() 获取当前线程对象。  <strong>类方法</strong></p>
<p>setName(String name) 设置线程的名字。</p>
<p>getName() 获取线程的名字。</p>
<p>setPriority(int priority) 设置线程的优先级。 优先级的取值范围[1,10],默认是5</p>
<p>getPriority() 获取线程的优先级。</p>
<p>getState() 获取线程的状态</p>
<p>join() 执行该线程，会阻塞当前线程。</p>
<p>sleep(long millis) 休眠指定时间（单位毫秒），会阻塞当前线程。<strong>类方法</strong></p>
<p>start() 启动线程</p>
<p>yield() 暂定该线程的执行，交出CPU的使用权。</p>
<h3 id="线程的同步">线程的同步</h3>
<h4 id="什么是线程的同步">什么是线程的同步？</h4>
<p>并行指的是线程同时执行。</p>
<p>同步不是线程同时执行，而是线程不同时执行。同步本质指的是数据的同步。一般情况下，线程之间是相互独立，如果都去访问同一个变量，极有可能让这个数据变乱。如果不想让数据变乱，应在不让他们同时访问同一个变量。这个控制过程称为线程同步。</p>
<h4 id="如何实现线程的同步">如何实现线程的同步？</h4>
<h4 id="一-同步代码块">一、同步代码块</h4>
<pre><code class="language-java">synchronized(对象){
	共享资源//我们所谓的那个变量。
}
</code></pre>
<p>示例代码：</p>
<pre><code class="language-java">public class SellWindow implements Runnable {
	
	private int tickets = 100;
	private Object lock = new Object();
	
	@Override
	public void run() {
		while(tickets &gt; 0) {
			String threadName = Thread.currentThread().getName();
			synchronized (lock) {
				tickets--;
				if(tickets &gt;= 0) {
					System.out.println(threadName + &quot;卖掉1张票，剩余&quot; + tickets);
				}
			}
		}
	}

}
</code></pre>
<blockquote>
<p>同步代码块synchronized (对象)，多个线程要公用同一个对象，才能真正意义上加上锁。对象没有特殊要求，可以是任何继承于Object类的对象。包括this</p>
</blockquote>
<h4 id="二-同步方法">二、同步方法</h4>
<p>被synchronized修饰的方法称为同步方法。</p>
<pre><code class="language-java">public class SellWindow3 implements Runnable {
	
	private int tickets = 100; 
	
	@Override
	public void run() {
		while(tickets &gt; 0) {
			
			//method();
			method2();
		}
	}
	
	public void method() {
		synchronized (this) {
			tickets--;
			String threadName = Thread.currentThread().getName();
			if(tickets &gt;= 0) {
				System.out.println(threadName + &quot;卖掉1张票，剩余&quot; + tickets);
			}
		}
	}

	public synchronized void method2() {
		tickets--;
		String threadName = Thread.currentThread().getName();
		if(tickets &gt;= 0) {
			System.out.println(threadName + &quot;卖掉1张票，剩余&quot; + tickets);
		}
	}
}
</code></pre>
<h4 id="使用锁对象上锁和解锁">使用锁对象上锁和解锁</h4>
<pre><code class="language-java">public class SellWindow4 implements Runnable {

	private int tickets = 100;
	Lock lock = new ReentrantLock();
	@Override
	public void run() {
		while (tickets &gt; 0) {
			String threadName = Thread.currentThread().getName();
			lock.lock();
			tickets--;
			if (tickets &gt;= 0) {
				System.out.println(threadName + &quot;卖掉1张票，剩余&quot; + tickets);
			}
			lock.unlock();
		}
	}
}
</code></pre>
<h4 id="线程同步小节">线程同步小节</h4>
<p>同步不是线程同时执行，而是线程不同时执行。同步本质指的是数据的同步。一般情况下，线程之间是相互独立，如果都去访问同一个变量，极有可能让这个数据变乱。如果不想让数据变乱，应在不让他们同时访问同一个变量。这个控制过程称为线程同步。</p>
<p>在开发中，如果多个线程访问一个资源（某变量），为了保证数据的正确性，可以使用3种方式来实现线程同步：使用synchronized(){}代码块，使用synchronized方法，或者给共享资源加锁和解锁。</p>
<h3 id="线程通信">线程通信</h3>
<h4 id="什么是线程通信">什么是线程通信？</h4>
<p>不同线程之间可以相互的发信号。这就是线程通信。之所以需要进行线程通信，是因为有些时候，一个线程的执行需要依赖另外一个线程的执行结果。在结果到来之前，让线程等待（wait），有了结果只之后再进行后续的操作。对于另外一个线程而言，计算完结果，通知（notify）一下处于等待状态的线程.</p>
<p>线程通信借助的是Object类的wait，notify，nitifyall方法。</p>
<p>wait作用是让当前线程阻塞，阻塞多久，取决于有没有其他线程唤醒它。</p>
<p>notify作用是唤醒处于wait状态的线程。必须是同一个监视器下的线程。</p>
<p>notifyall作用是唤醒所有处于wait状态的线程。必须是同一个监视器下的线程。</p>
<p>一般情况下，多线程里会出现线程同步的问题，我们不但要进行线程通信，还要解决线程同步的问题。</p>
<h4 id="生产者-消费者模式">生产者-消费者模式</h4>
<p>这是一个比较经典的多线程场景。有商品的时候，消费者才可以消费，没有商品的时候，消费者等待。商品库存充足的时候，生产者等待，库存不满的时候，生产者生产商品。</p>
<pre><code class="language-java">public class Saler {//售货员类
	private int productCount = 10;	//商品数量
	public synchronized void stockGoods() {
		if(productCount &lt; 2000) {
			productCount++;
			System.out.println(Thread.currentThread().getName() + &quot;生产了1件商品，库存是：&quot; + productCount);
			this.notifyAll();
		}else {
			System.out.println(&quot;库存满了&quot;);
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		
	}
	
	public synchronized void sellGoods() {
		if(productCount &gt; 0) {
			productCount--;
			System.out.println(Thread.currentThread().getName() + &quot;购买了1件商品，库存剩余：&quot; + productCount);
			 
			this.notifyAll();
		}else {
			System.out.println(&quot;库存不足&quot;);
			try {
				this.wait();
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}
	}
}

</code></pre>
<pre><code class="language-java">public class Productor implements Runnable{//生产者类
	private Saler s;

	public Productor(Saler s) {
		super();
		this.s = s;
	}

	@Override
	public void run() {
		while(true) {
			s.stockGoods();
		}
	}
	
}
</code></pre>
<pre><code class="language-java">public class Customer implements Runnable{//消费者类

	private Saler s;
	
	
	public Customer(Saler s) {
		super();
		this.s = s;
	}


	@Override
	public void run() {
		while(true) {
			s.sellGoods();
		}
	}
	
}
</code></pre>
<pre><code class="language-java">public class TestTread {

	public static void main(String[] args) {
		//生产者-消费者模式。模拟生产和消费过程
		Saler s = new Saler();
		Customer c = new Customer(s);
		Productor p = new Productor(s);
		Thread t1 = new Thread(c, &quot;客户1&quot;);
		t1.start();
		Thread t2 = new Thread(p,&quot;厂家&quot;);
		t2.start();
		Customer c2 = new Customer(s);
		Thread t3 = new Thread(c2, &quot;客户2&quot;);
		t3.start();
	}

}
</code></pre>
<h3 id="线程的生命周期">线程的生命周期</h3>
<p>线程的生命周期指的是线程从创建到销毁的过程。在整个过程中，不同的时期线程有不同的状态。而且在程序运行期间会发生状态的转换。</p>
<p>官方定义的线程状态如下：</p>
<p>NEW：新建状态，指的是线程已经创建，但是尚未start()。</p>
<p>RUNNABLE：可运行状态（已经调用了start方法），已经准备就绪，一旦抢到CPU就立即执行。</p>
<p>BLOCKED：阻塞状态，处于阻塞状态的线程正在等待进入Synchronized块（或方法）。</p>
<p>WAITING：等待状态，等待其他线程执行任务。直到其他线程任务结束或者收到notify信号。</p>
<p>TIMED-WAITING：等待状态，限定时间的等待状态。</p>
<p>TERMINATED：终止状态。线程要运行的任务已经结束。</p>
<p><strong>生活中程序员会把线程划分为如下状态：</strong></p>
<p>NEW：新建状态，指的是线程已经创建，但是尚未start()。</p>
<p>RUNNABLE：可运行状态（已经调用start方法），已经准备就绪，一旦抢到CPU就立即执行。</p>
<p>RUNNING：正在运行状态，已经抢到CPU，正在执行代码片段。</p>
<p>BLOCKED：阻塞状态。</p>
<p>DEAD：死亡状态。线程的任务已经结束。</p>
<h4 id="线程的状态转换">线程的状态转换</h4>
<figure data-type="image" tabindex="1"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90aW1nc2EuYmFpZHUuY29tL3RpbWc_aW1hZ2UmcXVhbGl0eT04MCZzaXplPWI5OTk5XzEwMDAwJnNlYz0xNTY1OTM3MzAwMzI3JmRpPTc0MWY2NDU5N2JlZmE0Y2ZkYjg5Mjc1ZGYwODJiZjM2JmltZ3R5cGU9MCZzcmM9aHR0cCUzQSUyRiUyRnBpYzIuemhpbWcuY29tJTJGdjItZDc5MTZjYTFhMmY4OWU5ZDFhMDI5NTRiYzExMGU5MWRfYi5qcGc?x-oss-process=image/format,png" alt="线程的状态转换"></figure>
<h3 id="线程池">线程池</h3>
<h4 id="什么是线程池">什么是线程池？</h4>
<p>水池：存放水的池子。</p>
<p>线程池：存放线程的池子。</p>
<p>Java中的线程池：是一个管理线程的池子。可以在需要的时候开辟线程，可以控制最大开辟的线程个数，可以在不需要的时候关闭线程，可以让任务排队执行。这些管理过程不需要我们干预，线程池能帮我们完成。我们所要做的就是往线程池中放任务。</p>
<h4 id="为什么要有线程池">为什么要有线程池？</h4>
<p>多线程解决了任务并发问题，但是开辟和关闭线程很消耗系统的性能，开辟和关闭一个线程要处理很多细节，频繁的开辟和关闭线程会给系统增加很多开销。</p>
<p>线程池使用了重用的概念，可以控制线程开辟的数量，复用这些线程执行任务。这样就不用频繁的开辟和关闭线程了。</p>
<h4 id="线程池的使用">线程池的使用</h4>
<pre><code class="language-java">public class TestThreadPool {

	public static void main(String[] args) {
		
		ThreadPoolExecutor pool = new ThreadPoolExecutor(10, 20, 2, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;&gt;(3),new ThreadPoolExecutor.DiscardPolicy());
		//pool.allowCoreThreadTimeOut(false);
		pool.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(&quot;我是一个任务&quot;+Thread.currentThread().getName());
			}
		});
		for(int i = 0; i &lt; 200; i++) {
			pool.execute(new Runnable() {
				@Override
				public void run() {
					System.out.println(&quot;我是另外一个任务&quot;+Thread.currentThread().getName());
				}
			});
		}
		
		try {
			Thread.sleep(4000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(pool.getPoolSize());
	}

}
</code></pre>
<p>pool可以指定核心线程的个数，最大允许的线程的个数，超过核心线程数以后，多久关闭线程，任务队列，以及任务拒绝的机制。</p>
<h4 id="线程池工具类">线程池工具类</h4>
<p>Exectors 是线程池工具类，可以帮我们快速构建线程池。</p>
<p>三种常见的线程池：</p>
<ol>
<li>固定线程个数的线程池</li>
<li>不限线程个数的线程池</li>
<li>单个线程的线程池（串行任务池）</li>
</ol>
<pre><code class="language-java">public class TestExecutors {

	public static void main(String[] args) {
		ExecutorService es = Executors.newFixedThreadPool(3);
//		ExecutorService es = Executors.newCachedThreadPool();
//		ExecutorService es = Executors.newSingleThreadExecutor();
		es.submit(new Runnable() {
			@Override
			public void run() {
				System.out.println(Thread.currentThread().getName());
				
			}
		});
	}
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Redis最全详细学习]]></title>
        <id>https://cxp-twx.github.io/post/redis-zui-quan-xiang-xi-xue-xi</id>
        <link href="https://cxp-twx.github.io/post/redis-zui-quan-xiang-xi-xue-xi">
        </link>
        <updated>2019-11-21T08:54:47.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-redis介绍">1. redis介绍</h1>
<h2 id="11-什么是redis">1.1. 什么是redis</h2>
<blockquote>
<p>Redis是用C语言开发的一个开源的高性能键值对（key-value）数据库。它通过提供多种键值数据类型来适应不同场景下的存储需求</p>
</blockquote>
<h3 id="redis支持的键值数据类型">Redis支持的键值数据类型</h3>
<p>字符串类型</p>
<p>散列类型  (对应Java中的Object，它主要用来存储对象)</p>
<p>列表类型  （List）</p>
<p>集合类型    (Set)</p>
<p>有序集合类型。 (TreeSet)</p>
<h2 id="12-redis的应用场景">1.2. redis的应用场景</h2>
<p>缓存（数据查询、短连接、新闻内容、商品内容等等）。（最多使用）</p>
<p>分布式集群架构中的session分离。</p>
<p>聊天室的在线好友列表。</p>
<p>任务队列。（秒杀、抢购、12306等等）</p>
<p>应用排行榜。</p>
<p>网站访问统计。</p>
<p>数据过期处理（可以精确到毫秒）</p>
<h1 id="2-redis的安装">2. Redis的安装</h1>
<h2 id="21-在windows上安装">2.1 在Windows上安装</h2>
<p>Redis官方只提供了Linux和macos的版本，并没有提供Windows安装包，但是微软的github仓库中我们可以下载到Windows上可用的Redis程序包，但已经很久没有更新，建议仅用来作为开发练手，不要用于实际的生产环境中。</p>
<p>下载地址： https://github.com/microsoftarchive/redis/tags</p>
<p>下载后直接解压就可以用了</p>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191116145815684.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h2 id="22-在linux上安装">2.2 在Linux上安装</h2>
<p>redis是C语言开发，建议在linux上运行，示例使用CentOS7作为安装环境。</p>
<ol>
<li>
<p>安装redis需要先将官网下载的源码进行编译，编译依赖gcc环境，如果没有gcc环境，需要安装gcc</p>
<pre><code class="language-bash">yum install gcc-c++
</code></pre>
<blockquote>
<p>阿里云的CentOS7默认已经内置了gcc，可以跳过这一步</p>
</blockquote>
</li>
<li>
<p>下载redis</p>
<p>从官网下载</p>
<p>http://download.redis.io/releases/redis-5.0.5.tar.gz</p>
<p>将redis-5.0.5.tar.gz拷贝任意路径下，如 /home/john/opt/</p>
</li>
<li>
<p>解压源码</p>
<pre><code class="language-bash">cd /home/john/opt/
tar -zxvf redis-5.0.5.tar.gz  
</code></pre>
</li>
<li>
<p>进入解压后的目录进行编译安装</p>
<pre><code class="language-bash">cd /home/john/opt/redis-5.0.5/src
make # 编译源代码
make install  # 安装
# 上面两步也可以直接通过 make &amp;&amp; make install两步并一步执行
</code></pre>
<blockquote>
<p>Redis默认的安装目录是/usr/local/bin， 我们在执行make install命令时添加prefix参数可修改默认安装位置，如： make PREFIX=/usr/local/redis install</p>
</blockquote>
</li>
</ol>
<h1 id="3-redis单机启动">3. redis单机启动</h1>
<p>redis.conf是redis的配置文件，默认在redis源码包解压后的根目录有一份redis.conf文件，我们可将其拷贝一份到上一步中redis的安装目录</p>
<pre><code class="language-bash">cp /home/john/opt/redis-5.0.5/src/redis.conf /usr/local/bin
</code></pre>
<p>我们装完redis以后，默认的安装路径是/usr/local/bin，系统会自动来此目录寻找命令，所以我们不需要在配置环境变量，在任意目录都可以使用redis相关的命令，如redis-server、redis-cli</p>
<h2 id="31-前端模式启动">3.1.   前端模式启动</h2>
<p>启动命令：</p>
<pre><code class="language-bash">redis-server /usr/local/bin/redis.conf
</code></pre>
<p>通过上面的命令启动，redis将以前端模式启动，前端模式启动的缺点是ssh命令窗口关闭则redis-server程序结束，不推荐使用此方法。</p>
<h2 id="32-后端模式启动">3.2.   后端模式启动</h2>
<h3 id="321-开启远程连接">3.2.1 开启远程连接</h3>
<p>配置文件（<mark>redis.conf</mark>）</p>
<ul>
<li>注释掉 bind 127.0.0.1这行</li>
<li>关闭保护模式  将protected-mode yes 改成 protected-mode no</li>
</ul>
<h3 id="322-添加密码验证">3.2.2 添加密码验证</h3>
<p>放开 # requirepass foobared 这行注释，将后面的foobared改成你自己需要设置的密码</p>
<p>客户端连接时，需要添加-a 参数指定密码才能连上来。</p>
<h3 id="323-开启后台守护进程运行模式">3.2.3 开启后台守护进程运行模式</h3>
<p>将 # daemonize no 这行放开注释， 并且改成 yes， Redis server将以后台方式运行。</p>
<h3 id="324-指定日志文件">3.2.4 指定日志文件</h3>
<p>将 logfile &quot;&quot; 改成 logfile &quot;你需要的redis日志文件名称&quot;， 默认的空字符串代表输出到前端控制台（标准输出）</p>
<p>修改redis.conf配置文件， daemonize yes 以后端模式启动。</p>
<h3 id="325-启动">3.2.5 启动</h3>
<p>启动命令和前端启动一样，只不过控制台不会输出任何信息，而且命令结束，如果没有异常会马上退出。</p>
<h1 id="5-redis集群">5.   redis集群</h1>
<h2 id="51-集群原理">5.1. 集群原理</h2>
<h3 id="511-redis-cluster架构图">5.1.1.   redis-cluster架构图</h3>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191116145858295.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>架构细节:</p>
<ol>
<li>所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</li>
<li>节点的fail是通过集群中超过半数的节点检测失效时才生效.</li>
<li>客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</li>
<li>redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value  Redis 集群中内置了 16384 个哈希槽，当需要在 Redis 集群中放置一个 key-value 时，redis 先对 key 使用 crc16 算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点</li>
</ol>
<h3 id="512-redis-cluster投票容错">5.1.2.   redis-cluster投票:容错</h3>
<p>!<img src="https://img-blog.csdnimg.cn/20191116145933804.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ol>
<li>投票过程是集群中所有master参与,如果半数以上master节点与master节点通信超过(cluster-node-timeout),认为当前master节点挂掉.</li>
<li>什么时候整个集群不可用(cluster_state:fail)?
<ol>
<li>如果集群任意master挂掉,且当前master没有slave.集群进入fail状态,也可以理解成集群的slot映射[0-16383]不完成时进入fail状态</li>
<li>如果集群超过半数以上master挂掉，无论是否有slave集群进入fail状态.</li>
</ol>
</li>
</ol>
<blockquote>
<p>当集群不可用时,所有对集群的操作做都不可用，收到((error) CLUSTERDOWN The cluster is down)错误</p>
</blockquote>
<h2 id="53-创建集群">5.3. 创建集群</h2>
<h3 id="531-集群结点规划">5.3.1.   集群结点规划</h3>
<p>这里在同一台服务器用不同的端口表示不同的redis服务器(伪集群)，如下：</p>
<pre><code>主节点：192.168.101.3:7001 192.168.101.3:7002 192.168.101.3:7003

从节点：192.168.101.3:7004 192.168.101.3:7005 192.168.101.3:7006
</code></pre>
<h3 id="532-修改配置">5.3.2 修改配置</h3>
<p>修改redis.conf配置文件</p>
<pre><code class="language-conf">port 7001  # 将每个节点的端口号改成不一样的(因为同一台机器上一个端口只能被一个进程绑定)
cluster-enabled yes #是否开启集群模式
cluster-config-file nodes.conf	#集群配置文件名称
cluster-node-timeout 5000	#集群中节点间投票通信的超时时间
appendonly yes  #配置集群中当前节点仅开启AOF持久化模式
pidfile /var/run/redis_7001.pid  #将pid文件改成不同的名称，建议和当前节点的端口号对应
</code></pre>
<h3 id="533-创建集群目录">5.3.3 创建集群目录</h3>
<p>在/usr/local下创建redis-cluster目录，其下创建7001、7002。。7006目录，如下：</p>
<figure data-type="image" tabindex="3"><img src="https://img-blog.csdnimg.cn/20191116151053692.png" alt="在这里插入图片描述"></figure>
<p>将redis安装目录bin下的文件拷贝到每个700X目录内，并且将配置文件也拷贝一份到每个700X目录</p>
<pre><code class="language-bash">cp /usr/local/bin/redis/redis* /usr/local/redis-cluster/7001
cp /home/john/opt/redis-5.0.5/src/redis.conf /usr/local/redis-cluster/7001
</code></pre>
<p>修改每个700X目录下的redis.conf配置文件中的端口号和pid文件路径</p>
<h3 id="534-启动每个节点redis服务">5.3.4.   启动每个节点redis服务</h3>
<p>进入/usr/local/redis_cluster目录下，编写启动集群脚本：start_redis_cluster.sh</p>
<p>cd /usr/local/redis_cluster</p>
<p>vim start_redis_cluster.sh</p>
<pre><code class="language-bash">#!/bin/bash

work_dir=`pwd`

echo &quot;开始启动redis集群中的每个节点&quot;
for idx in {1..6}
do
    cd $work_dir
    cd &quot;./700$idx&quot; &amp;&amp; ./redis-server ./redis.conf
    if [ $? != 0 ] 
    then
        echo &quot;启动700$idx节点失败，停止启动集群&quot;
        exit 1
    fi  
    echo &quot;启动700$idx&quot;
done
echo &quot;所有集群节点启动完成&quot;
</code></pre>
<p>编辑完成后，按ESC切换到命令模式， 输入ZZ 或者 :wq保存退出。（<mark>此处可能需要给此文件加权限！！</mark>）</p>
<p>启动Redis集群中所有节点</p>
<pre><code class="language-bash">./start_redis_cluster.sh 
</code></pre>
<p>查看redis进程：</p>
<p>ps aux | grep redis</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191116150107895.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h3 id="534-执行创建集群命令">5.3.4.   执行创建集群命令</h3>
<p>Redis 5开始，集群不需要依赖Ruby，官方直接提供了集群管理支持</p>
<pre><code class="language-bash">redis-cli --cluster create 127.0.0.1:7001 127.0.0.1:7002 \
127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005 127.0.0.1:7006 \
--cluster-replicas 1
</code></pre>
<blockquote>
<p>注意，这里用127.0.0.1仅适用于在本机练习集群搭建，真实环境下需要换成外公网IP，否则无法远程连接到你的redis集群</p>
</blockquote>
<p>命令说明：</p>
<p>redis集群至少需要3个主节点，每个主节点有一个从节点总共6个节点</p>
<p>--cluster-replicas指定为1表示为集群中每个master都指定一个slave，也就是说上面6个节点会有3个主节点和对应的3个从节点</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191116150148565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>如果一切正常，最后会看到如下输出</p>
<pre><code class="language-bash">[OK] All 16384 slots covered.
</code></pre>
<h4 id="可能会遇到的错误">可能会遇到的错误</h4>
<h1 id="错误一"><mark>错误一</mark>：</h1>
<p>如果创建redis集群的时候，ip用的是127.0.0.1，那么你在用Java客户端远程操作Redis集群的时候，会死活连不上，一直是报<strong>127.0.0.1:7001</strong>无法连接</p>
<p>解决办法：创建Redis集群时，创建命令中传入的节点IP参数列表使用外部可以访问的IP</p>
<p>错误二：</p>
<p>如果执行时报如下错误：</p>
<p>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0</p>
<p>解决方法是删除生成的配置文件nodes.conf，如果不行则说明现在创建的节点包括了旧集群的结点信息，需要删除redis的持久化文件后再重启redis，比如：appendonly.aof、dump.rdb</p>
<h2 id="54-停止redis集群">5.4. 停止Redis集群</h2>
<p>在/usr/local/redis_cluster目录下，创建脚本文件：stop_redis_cluster.sh</p>
<p>输入以下内容：</p>
<pre><code class="language-bash">#!/bin/bash

work_dir=`pwd`

count=0
err_count=0
echo &quot;开始停止redis集群&quot;
for idx in {1..6}
do
    cd $work_dir
    cd &quot;./700$idx&quot; &amp;&amp; ./redis-cli -c -p &quot;700$idx&quot; shutdown
    if [ $? != 0 ] 
    then
        echo &quot;停止700$idx节点失败&quot;
        let err_count++
    fi  
    echo &quot;停止700$idx节点&quot;
    let count++
done
echo &quot;Redis集群一共有$count个节点，成功停止`expr $count - $err_count`个节点，有$err_count个节点停止失败.&quot;
</code></pre>
<p>执行此脚本可以停止redis集群</p>
<h2 id="55-查询集群信息">5.5. 查询集群信息</h2>
<p>集群创建成功登陆任意redis结点查询集群中的节点情况。</p>
<p>客户端以集群方式登陆：</p>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191116150252796.png" alt="在这里插入图片描述"></figure>
<p>说明：</p>
<p><code>./redis-cli -c -h 192.168.101.3 -p 7001</code>，其中<code>-c</code>表示以集群方式连接redis，<code>-h</code>指定ip地址，<code>-p</code>指定端口号</p>
<h3 id="551-查看集群状态相关命令">5.5.1 查看集群状态相关命令</h3>
<p>cluster nodes 查询集群结点信息</p>
<p>cluster info 查询集群状态信息</p>
<h2 id="56-添加主节点">5.6. 添加主节点</h2>
<p>集群创建成功后可以向集群中添加节点，下面是添加一个master主节点</p>
<p>添加7007节点，参考集群节点规划章节添加一个“7007”目录作为新节点。</p>
<p>Redis 5 添加主节点命令：</p>
<p>语法：</p>
<pre><code>redis-cli –cluster add-node 要添加节点的ip:端口 集群中当前存在的任何一个节点的ip和端口
</code></pre>
<p>示例：</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7006 10.10.14.166:7000
</code></pre>
<p>输出结果</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191116150331536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>查看集群结点发现7007已添加到集群中：</p>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191116150406841.png" alt="在这里插入图片描述"></figure>
<p>注意：新添加的master node有以下两个特征</p>
<ol>
<li>由于它没有分配hash槽，所以该节点无法存储任何数据</li>
<li>由于它没有分配hash槽，所以在其他从节点要升级成主节点的过程中，该节点不参与投票（没有投票权）</li>
</ol>
<h3 id="561-hash槽重新分配">5.6.1.   hash槽重新分配</h3>
<p>添加完主节点需要对主节点进行hash槽分配这样该主节才可以存储数据。</p>
<p>redis集群有16384个槽，集群中的每个结点分配自已的槽，通过查看集群结点（cluster nodes命令）可以看到槽占用情况。 可以看到新添加的7007节点并没有分配到hash槽</p>
<figure data-type="image" tabindex="9"><img src="https://img-blog.csdnimg.cn/20191116150406841.png" alt="在这里插入图片描述"></figure>
<p>给刚添加的7007结点分配槽</p>
<p>第一步：连接上集群</p>
<pre><code class="language-bash">redis-cli --cluster reshard 127.0.0.1:7001  #（连接集群中任意一个可用结点就行）
</code></pre>
<p>第二步：输入要分配的槽数量</p>
<figure data-type="image" tabindex="10"><img src="https://img-blog.csdnimg.cn/20191116150518597.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>输入 500表示分配500个槽</p>
<p>第三步：输入接收槽的结点id</p>
<figure data-type="image" tabindex="11"><img src="https://img-blog.csdnimg.cn/20191116150552362.png" alt="在这里插入图片描述"></figure>
<p>这里准备给7007分配槽，通过cluster nodes查看7007结点id为15b809eadae88955e36bcdbb8144f61bbbaf38fb</p>
<p>输入：15b809eadae88955e36bcdbb8144f61bbbaf38fb</p>
<p>第四步：输入源结点id</p>
<figure data-type="image" tabindex="12"><img src="https://img-blog.csdnimg.cn/20191116150620672.png" alt="在这里插入图片描述"></figure>
<p>这里输入all</p>
<p>第五步：输入yes开始移动槽到目标结点id</p>
<figure data-type="image" tabindex="13"><img src="https://img-blog.csdnimg.cn/20191116150702652.png" alt="在这里插入图片描述"></figure>
<p>至此，新添加的7007 master节点的hash槽就分配完毕，可以存储数据了！</p>
<p>关于Redis 集群的hash slots相关知识，可以参阅：</p>
<p><a href="https://www.cnblogs.com/abc-begin/p/8203613.html">redis hash slot（虚拟桶）</a></p>
<p><a href="https://www.jianshu.com/p/fe7b7800473e">Redis Cluster及hash slot 算法</a></p>
<h2 id="57-添加从节点">5.7. 添加从节点</h2>
<p>集群创建成功后可以向集群中添加节点，下面是添加一个slave从节点。</p>
<p>添加7008从结点，将7008作为7007的从结点。</p>
<p>Redis 5中添加从节点命令：</p>
<p>语法：</p>
<pre><code class="language-bash">redis-cli –cluster add-node 要添加节点的ip:端口 集群中任意已有master的ip和端口 --cluster-slave [--cluster-master-id masterid]
</code></pre>
<p>示例：</p>
<p>添加一个从节点，不指定目标主节点</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7008 10.10.14.166:7001 --cluster-slave
</code></pre>
<blockquote>
<p>注意：该命令只是向集群中添加了一个从节点，但并没有指名要作为哪个master node的从节点，Redis集群会将其添加到集群中随机挑一个从节点较少的master node上，作为其从节点</p>
</blockquote>
<p>添加一个从节点，并指定所属主节点</p>
<pre><code class="language-bash">redis-cli --cluster add-node 10.10.14.166:7008 10.10.14.166:7001 --cluster-slave --cluster-master-id 3c3a0c74aae0b56170ccb03a76b60cfe7dc1912e
</code></pre>
<blockquote>
<p>我们通过增加了一个cluster-master-id参数，指定从节点要添加到哪个主节点上。主节点的ID可以通过cluster nodes查看到</p>
</blockquote>
<p>注意：如果原来该结点在集群中的配置信息已经生成cluster-config-file指定的配置文件中（如果cluster-config-file没有指定则默认为nodes.conf），这时可能会报错：</p>
<p>[ERR] Node XXXXXX is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0</p>
<p>解决方法是删除生成的配置文件nodes.conf，删除后再执行添加从节点指令</p>
<p>查看集群中的结点可以发现，刚添加的7008为7007的从节点</p>
<h2 id="58-删除结点">5.8. 删除结点：</h2>
<p>Redis5以后删除节点命令：</p>
<p>语法：</p>
<pre><code class="language-bash">redis-cli --cluster del-node ip:port node_id
</code></pre>
<blockquote>
<p>注：上面的ip:port为集群中存在的任意节点，node_id是你要删除的节点的id</p>
</blockquote>
<p>示例：</p>
<pre><code class="language-bash">redis-cli --cluster del-node 10.10.14.166:7001 d3b977fd46386db84fd85b9240deb602087c8617
</code></pre>
<p>删除已经占有hash槽的结点会失败，报错如下：</p>
<p>[ERR] Node 127.0.0.1:7005 is not empty! Reshard data away and try again.</p>
<p>需要将该结点占用的hash槽分配出去（参考hash槽重新分配章节）。</p>
<h1 id="6-redis持久化策略">6. Redis持久化策略</h1>
<h2 id="61-rdb快照模式">6.1 RDB快照模式</h2>
<p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p>
<h3 id="611-工作步骤">6.1.1 工作步骤</h3>
<ol>
<li>Redis forks；</li>
<li>子进程开始将数据写到临时RDB文件中；</li>
<li>当子进程完成写RDB文件，用新文件替换老文件；</li>
<li>当RedisServer重新启动时，读取RDB文件恢复到内存中。</li>
</ol>
<figure data-type="image" tabindex="14"><img src="https://img-blog.csdnimg.cn/20191116150840494.png" alt="在这里插入图片描述"></figure>
<h3 id="612-配置参数">6.1.2 配置参数</h3>
<pre><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。

# save &quot;&quot;  			 # 将上面三个配置注释掉，只保留一个save &quot;&quot;， 代表禁用RDB快照模式
</code></pre>
<h2 id="62-aof模式">6.2 AOF模式</h2>
<p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，</p>
<p>Redis就不是一个合适的选择。</p>
<p>Append-only-file 模式是另一种选择。</p>
<p>你可以在配置文件中打开AOF模式</p>
<h3 id="621-工作步骤">6.2.1 工作步骤</h3>
<ol>
<li>Redis客户端发送读写命令</li>
<li>RedisServer接收并执行命令，同时同步记录命令到AOF文件中</li>
<li>Redis重新启动时读取AOF文件，执行其中每一条指令完成数据恢复</li>
</ol>
<figure data-type="image" tabindex="15"><img src="https://img-blog.csdnimg.cn/20191116150910427.png" alt="在这里插入图片描述"></figure>
<h3 id="622-配置参数">6.2.2 配置参数</h3>
<pre><code># appendfsync always    # 命令过来后，立刻写入AOF文件（会强制flush操作系统IO缓冲）
appendfsync everysec	# 默认策略， 每秒钟将缓存的命令写入到AOF文件中
# appendfsync no        # 关闭AOF备份
</code></pre>
<h2 id="63-rdb模式与aof模式的对比">6.3 RDB模式与AOF模式的对比</h2>
<h3 id="631-rdb模式的优点">6.3.1 RDB模式的优点</h3>
<ol>
<li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li>
<li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li>
<li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li>
</ol>
<h3 id="632-rdb模式的缺点">6.3.2 RDB模式的缺点</h3>
<ol>
<li>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li>
</ol>
<h3 id="633-aof模式的优点">6.3.3 AOF模式的优点</h3>
<ol>
<li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li>
<li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li>
<li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li>
</ol>
<h3 id="634-aof模式的缺点">6.3.4 AOF模式的缺点</h3>
<ol>
<li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li>
<li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li>
</ol>
<blockquote>
<p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。</p>
</blockquote>
<blockquote>
<h4 id="如果rdb文件和aof同时存在当redis重启的时候会优先载入aof文件来恢复原始的数据因为在通常情况下aof文件保存的数据集要比rdb文件完整">如果RDB文件和AOF同时存在，当redis重启的时候会优先载入AOF文件来恢复原始的数据,因为在通常情况下AOF文件保存的数据集要比RDB文件完整</h4>
</blockquote>
<h1 id="7-通过springboot操作redis">7. 通过SpringBoot操作redis</h1>
<p>注： 下面的教程以最新的SpringBoot版本 2.2.0为例</p>
<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;2.2.0.RELEASE&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<h2 id="71-sringboot操作单机版redis">7.1. SringBoot操作单机版Redis</h2>
<h3 id="711-引入依赖">7.1.1   引入依赖</h3>
<pre><code class="language-xml">&lt;!-- SpringBoot2以后，默认的redis客户端已经由jedis改成了lettuce，下面依赖会把lettuce-core也添加进来 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- 如果项目中用到了redis连接池，需要添加如下依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
    &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<h3 id="712-springboot配置">7.1.2   SpringBoot配置</h3>
<p>application.yml</p>
<pre><code class="language-yml">spring:
    redis:
    host: www.taotao.com
#    port: 6379		# 如果端口号不是默认端口需要制定
#    password: xxx	# 如果redis服务端开启了口令验证，需要添加
    lettuce:
      pool:			# 如果使用redis连接池，需要添加apche的common-pool2依赖
        max-idle: 2
        max-wait: 1000ms
</code></pre>
<h3 id="713-java代码">7.1.3.   Java代码</h3>
<p>通过创建单实例jedis对象连接redis服务，如下代码：</p>
<pre><code class="language-java">@Slf4j
@SpringBootTest
public class TestRedisClient {

   @Autowired
   private StringRedisTemplate redisTemplate;

   @Test
   public void testRedis() {
      Set&lt;String&gt; keys = redisTemplate.keys(&quot;*&quot;);
      log.info(&quot;操作前存在的keys: &quot; + keys);

      String key = &quot;lanou_F4&quot;;

      redisTemplate.opsForList().rightPushAll(key, new String[]{&quot;宋超&quot;, &quot;国胜&quot;, &quot;国伟&quot;, &quot;高飞&quot;});

      long size = redisTemplate.opsForList().size(key);
      log.info(&quot;当前&quot;+key+&quot;值的数量： &quot; + size);

      List&lt;String&gt; values = redisTemplate.opsForList().range(key, 0, size);
      log.info(&quot;当前&quot; + key +&quot;的值： &quot; + values);

      keys = redisTemplate.keys(&quot;*&quot;);
      log.info(&quot;操作后存在的keys: &quot; + keys);
   }
}
</code></pre>
<h2 id="72-springboot操作redis集群">7.2. SpringBoot操作Redis集群</h2>
<h3 id="721-引入依赖">7.2.1. 引入依赖</h3>
<pre><code class="language-xml">&lt;dependencies&gt;
        &lt;!-- 添加spring-boot-starter-data-redis依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
            &lt;!-- 排除掉lettuce客户端相关依赖 --&gt;
            &lt;!-- lettuce客户端连接阿里云上自建的redis集群会有连接超时的问题 --&gt;
            &lt;exclusions&gt;
                &lt;exclusion&gt;
                    &lt;groupId&gt;io.lettuce&lt;/groupId&gt;
                    &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt;
                &lt;/exclusion&gt;
            &lt;/exclusions&gt;
        &lt;/dependency&gt;
        &lt;!-- 替换成jedis客户端 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;redis.clients&lt;/groupId&gt;
            &lt;artifactId&gt;jedis&lt;/artifactId&gt;
        &lt;/dependency&gt;

        &lt;!-- redis连接池依赖 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;
            &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;
        &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<h3 id="722-springboot配置">7.2.2. SpringBoot配置</h3>
<p>application.yml</p>
<pre><code class="language-yml">spring:
  redis:
    jedis:
      pool: # 配置redis连接池相关参数
        max-idle: 2
        max-active: 10
        min-idle: 1
    cluster:
      nodes: teacher.lanou.com:7001,teacher.lanou.com:7002,teacher.lanou.com:7003,teacher.lanou.com:7004,teacher.lanou.com:7005,teacher.lanou.com:7006
</code></pre>
<h3 id="723-java代码">7.2.3. Java代码</h3>
<pre><code class="language-java">@SpringBootTest
class SpringbootRedisApplicationTests {

    @Autowired
    private StringRedisTemplate redisTemplate;


    @Test
    public void testPutKV() {
        ValueOperations&lt;String, String&gt; ops = redisTemplate.opsForValue();
        ops.set(&quot;name&quot;, &quot;张三&quot;);
        String name = ops.get(&quot;name&quot;);
        Assertions.assertEquals(&quot;张三&quot;, name, &quot;应该返回张三&quot;);
    }

    @Test
    public void testOpsForList() {
        ListOperations&lt;String, String&gt; ops = redisTemplate.opsForList();
        ops.rightPush(&quot;yanfa3&quot;, &quot;王康健&quot;);
        ops.leftPush(&quot;yanfa3&quot;, &quot;于漫漫&quot;);
        ops.rightPushAll(&quot;yanfa3&quot;, &quot;李光&quot;, &quot;星辰&quot;, &quot;鹏杰&quot;, &quot;士军&quot;);

        Assertions.assertEquals(6, ops.size(&quot;yanfa3&quot;), &quot;应该是由6个元素才对&quot;);

        List&lt;String&gt; stuNames = ops.range(&quot;yanfa3&quot;, 0, -1);
        stuNames.forEach((v) -&gt; {
            System.out.println(v);
        });

    }
}
</code></pre>
<blockquote>
<p>集群模式只是依赖和配置不同，在代码中使用的API没有什么区别</p>
</blockquote>
<h2 id="73-外部连接不上redis的解决方法">7.3. 外部连接不上redis的解决方法</h2>
<p>由于linux防火墙默认开启，redis的服务端口6379并不在开放规则之内，所有需要将此端口开放访问或者关闭防火墙。</p>
<p>查看防火墙状态：sevice iptables status</p>
<p>关闭防火墙命令：sevice iptables stop</p>
<p>如果是修改防火墙规则，可以修改：/etc/sysconfig/iptables文件</p>
<h1 id="8-系统添加缓存逻辑示例">8.   系统添加缓存逻辑示例</h1>
<p>添加缓存逻辑的原则：缓存逻辑不能影响正常的业务逻辑执行。</p>
<h2 id="81-添加缓存后系统架构">8.1. 添加缓存后系统架构</h2>
<figure data-type="image" tabindex="16"><img src="https://img-blog.csdnimg.cn/20191116151010893.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令学习]]></title>
        <id>https://cxp-twx.github.io/post/linux-chang-yong-ming-ling-xue-xi</id>
        <link href="https://cxp-twx.github.io/post/linux-chang-yong-ming-ling-xue-xi">
        </link>
        <updated>2019-11-18T07:53:10.000Z</updated>
        <content type="html"><![CDATA[<h1 id="linux学习">Linux学习</h1>
<h1 id="目录结构">目录结构：</h1>
<p><strong>https://www.runoob.com/linux/linux-system-contents.html</strong></p>
<h2 id="1-在虚拟机中安装centos操作系统">1. 在虚拟机中安装Centos操作系统</h2>
<p>使用VirtualBox虚拟机工具安装centos6操作系统</p>
<h3 id="11-linux-ssh操作终端">**1.1 Linux **SSH操作终端</h3>
<p>使用SecureCRT工具通过ssh服务远程连接到linux，通过命令行操作</p>
<h3 id="12-linux常用命令"><strong>1.2.</strong> <strong>Linux常用</strong>命令</h3>
<h4 id="目录相关命令"><strong>目录</strong><mark>相关命令</mark>：</h4>
<blockquote>
<p>ls: 查看当前目录文件</p>
<p>ll:查看所有以及</p>
<p>cd: 切换工作目录 如: cd ~ （进入当前用户home目录）</p>
<p>pwd: 显示当前工作目录</p>
<p>mkdir: 新建目录</p>
<p>mkdir -p /././.   :创建多级目录</p>
<p>cd .. :跳出到根目录（到上一级目录 	）</p>
<p><strong>ls-命令参数</strong> :</p>
<ul>
<li>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为&quot;.&quot;的视为隐藏档，不会列出)</li>
<li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li>
<li>-r 将文件以相反次序显示(原定依英文字母次序)</li>
<li>-t 将文件依建立时间之先后次序列出</li>
<li>-A 同 -a ，但不列出 &quot;.&quot; (目前目录) 及 &quot;..&quot; (父目录)</li>
<li>-F 在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;/&quot;</li>
<li>-R 若目录下有文件，则以下之文件亦皆依序列出</li>
</ul>
</blockquote>
<h4 id="文件操作相关"><strong>文件操作</strong>相关：</h4>
<blockquote>
<p>cat: 查看文件内容</p>
<p>tail  -fn 100 /etc/passwd （查看文件最后100行， 自动刷新，非常适合看日志）</p>
<p>rm: 删除</p>
<p>mv: 移动文件 (如果还移动到当前目录，就是重命名)</p>
<p>touch: 创建一个空文件</p>
<p>sz [文件名] ：下载Linux上的文件到本地系统</p>
<p>使用指令&quot;cp&quot;将当前目录&quot;test/&quot;下的所有文件复制到新目录&quot;newtest&quot;下，输入如下命令：</p>
<pre><code class="language-bash">$ cp –r test/ newtest  
</code></pre>
</blockquote>
<blockquote>
<p>**我们知道cp是复制，mv就是剪切，在windows下的叫法<img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cuaXRleWUuY29tL2ltYWdlcy9zbWlsZXMvaWNvbl9sb2wuZ2lm" alt="img">，在linux下二者还有一个区别，就是生成的文件的权限不一定相同。</p>
<p>**mv只是移动了文件，文件的一切都没有改变，而cp是在目标文件夹中创建了新的文件。</p>
</blockquote>
<h4 id="vim-文本编辑相关"><strong>VIM 文本</strong>编辑相关：</h4>
<blockquote>
<p>vim: linux上的一个强大的文本编辑器</p>
<p>保存并退出： :wq(命令模式下)、 ZZ（命令模式下）</p>
<p>不保存退出：:q! (命令模式下)</p>
<p>从命令模式切换到编辑模式：	a、i、o</p>
<p>跳到文件头： gg</p>
<p>跳到文件尾：GG</p>
</blockquote>
<h4 id="进程相关命令"><strong>进程</strong>相关命令：</h4>
<blockquote>
<p>查看当前系统中运行了哪些进程：ps aux | grep  vsftp (查看当前有没有运行ftp进程)</p>
<p>杀进程： kill -9 [进程号]</p>
</blockquote>
<h4 id="centos安装包管理器yum-命令"><strong>Centos</strong>安装包管理器Yum 命令：</h4>
<blockquote>
<p>查看已安装的程序：sudo yum list installed | grep vsftp	(查看是否安装了vsftp软件)</p>
<p>卸载已安装程序： sudo yum remove vsftpd.i686</p>
<p>安装程序： sudo yum install vsftpd</p>
</blockquote>
<h4 id="centos防火墙命令相关"><strong>Centos</strong>防火墙命令相关:</h4>
<blockquote>
<p>查看防火墙状态：service iptables status</p>
<p>关闭防火墙：service iptables stop</p>
<p>开启防火墙：service iptables start</p>
</blockquote>
<h4 id="服务开机自启动">服务开机自启动：</h4>
<blockquote>
<p>chkconfig vsftpd on  (设置vsftpd服务开机自启动)</p>
</blockquote>
<h4 id="关机服务开机自启">关机服务开机自启：</h4>
<blockquote>
<p>chkconfig iptables off (设置防火墙服务不开机自启)</p>
<p>关机：sudo halt –p</p>
<p>重启: sudo reboot</p>
</blockquote>
<h4 id="用户相关">用户相关：</h4>
<blockquote>
<p>useradd user1——创建用户user1</p>
<p>使用 passwd 命令为新建用户设置密码：password user1</p>
<p>命令 usermod 修改用户账户：usermod –l u1 user1  改名字</p>
<p>usermod –g users user1 ：加入用户组</p>
<p>su user :查询进入用户</p>
<p>sudo password user：重置这个用户的密码</p>
<p>删除用户：userdel user2</p>
<p>删除用户 user3，同时删除他的工作目录：userdel –r user3</p>
<p>d命令查看一个用户的UID和GID, 例：查看user4的id：：id user4<br>
finger命令 ——可以查看用户的主目录、启动shell、用户名、地址、电话等信息</p>
<p>命令 groupadd创建用户组：：groupadd –g 888 users ：：创建一个组users，其GID为888</p>
</blockquote>
<ul>
<li>
<p>两种方式，我们以kill用户user为例:</p>
<ol>
<li>pkill方式</li>
</ol>
<p>pkill -u user</p>
<ol start="2">
<li>killall方式</li>
</ol>
<p>killall -u user</p>
</li>
</ul>
<h4 id="其他">其他：</h4>
<blockquote>
<p>sudo make &amp;&amp; make install：同时执行多个简单的命令</p>
<p>./configure\：后面的\是转义，代表不换行太长了继续编辑</p>
<p>ps aux | grep nginx  ：查看是否启动（也是查看有无进程）</p>
<p>wget  url ：直接根据url链接下载</p>
<p>rz -be:上传本地的文件到Linux</p>
<p>tar -zxf  。。。。：解压tar包</p>
<p>语法：unzip ［选项］ 压缩文件名.zip</p>
<p>sudo  ./nginx -s reload :热加载（修改了配置文件后不重启，热加载让其生效！）</p>
<p>查看虚拟机IP：：ip address</p>
<p>ll -a | grep sudoers ：查看文件权限</p>
<p>chmod 664 sudoers：添加文件权限</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[更轻量级框架Springboot学习]]></title>
        <id>https://cxp-twx.github.io/post/geng-qing-liang-ji-kuang-jia-springboot-xue-xi</id>
        <link href="https://cxp-twx.github.io/post/geng-qing-liang-ji-kuang-jia-springboot-xue-xi">
        </link>
        <updated>2019-11-12T08:54:32.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springboot学习">SpringBoot学习</h1>
<ul class="contains-task-list">
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8877305"><label class="task-list-item-label" for="task-item-8877305"> #### 踩过的坑：</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-2864247"><label class="task-list-item-label" for="task-item-2864247"> Ctrl + alt + L：列编辑(不好使(不要放手Ctrl+alt))：：：：alt+加拉取（在源码模式下）</label></p>
</li>
<li class="task-list-item">
<p><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox" id="task-item-8455403"><label class="task-list-item-label" for="task-item-8455403"> typora的偏好设置里面竟然有恢复之前未保存的文件，太强了，粉了！！！</label></p>
</li>
</ul>
<pre><code class="language-xml">&lt;!-- 当项目以war包的方式部署到外部Tomcat运行时 --&gt;
        &lt;!-- 必须将tomcat标记为provided，阻止将内置的tomcat包打到war包中，以防与外部tomcat容器中的包冲突 --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;



如果将SpringBoot工程打成war包，放到外部Tomcat中去运行需要做如下配置：
 &lt;ol&gt;
     &lt;li&gt;将pom打包格式改成war&lt;/li&gt;
     &lt;li&gt;将spring-boot-starter-tomcat依赖配置成provided&lt;/li&gt;
     &lt;li&gt;启动类做如下修改&lt;/li&gt;
 &lt;/ol&gt;
</code></pre>
<blockquote>
<p>在SpringBoot中，默认配置的/**映射到/static。<br>
静态资源映射还有一个配置选项，为了简单这里用.properties方式书写：</p>
<p>spring.mvc.static-path-pattern=/** # Path pattern used for static<br>
resources.</p>
<p>这个配置会影响默认的/**，例如修改为/static/**后，只能映射如/static/js/sample.js这样的请求（修改前是/js/sample.js）。这个配置只能写一个值，不像大多数可以配置多个用逗号隔开的。</p>
</blockquote>
<p><mark>在application.yml文件中严格按照层级结构（按照idea的提示）来书写也不会出错！</mark></p>
<h3 id="springboot视图">SpringBoot视图</h3>
<h3 id="thymeleaf">Thymeleaf</h3>
<pre><code>模板引擎(springBoot中用来取参)
</code></pre>
<pre><code class="language-xml">&lt;!--前端页面中--&gt;
&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;
&lt;!--pom.xml中--&gt;
		&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>。。。</p>
<h1 id="springboot的运行方式">SpringBoot的运行方式</h1>
<ol>
<li>直接在IDEA中运行入口处类</li>
<li>通过Spring-boot-maven-plugin打成可执行jar包，通过Java-jar 运行</li>
<li>通过mvc spring-boot ：run运行</li>
</ol>
<p>打包部署：</p>
<p><strong>jar包</strong></p>
<p>SpringBoot官方建议通过SpringBoot提供的打包插件将项目打包成一个可执行的jar包(在这个jar包里面已经内置了Tomcat，可以直接当一个web跑)，方便部署和管理。</p>
<p>添加编译插件(通过start.spring.io创建的工程默认就有)</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;packaging&gt;jar&lt;/packaging&gt;
    &lt;!-- ... --&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;fork&gt;true&lt;/fork&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<p>然后直接通过</p>
<pre><code class="language-cmd">$ mvn clean package
$ java -jar target/mymodule-0.0.1-SNAPSHOT.jar
</code></pre>
<blockquote>
<p>注意， 如果你使用了src/main/webapp目录，打成jar包会忽略掉该目录下的所有文件，这种情况下只能选择打war包的方式</p>
</blockquote>
<p><strong>war包</strong></p>
<p>主要分为两步</p>
<h3 id="第一步修改pomxml">第一步，修改pom.xml</h3>
<p>示例配置：<br>
pom.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;!-- ... --&gt;
    &lt;packaging&gt;war&lt;/packaging&gt;
    &lt;!-- ... --&gt;
    &lt;dependencies&gt;
    &lt;!-- 必须将tomcat标记为provided，阻止将内置的tomcat包打到war包中，以防与外部tomcat容器中的包冲突 --&gt;
    &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- ... --&gt;
        &lt;!-- Compile --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
            &lt;artifactId&gt;jstl&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;!-- 支持JSP --&gt;        
    &lt;dependency&gt;
            &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
            &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
            &lt;scope&gt;provided&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!-- Test --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;useSystemClassLoader&gt;false&lt;/useSystemClassLoader&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;
</code></pre>
<h3 id="第二步-注册启动类">第二步 注册启动类</h3>
<p>创建 ServletInitializer.java，继承 SpringBootServletInitializer ，覆盖 configure()，把启动类 Application 注册进去。外部 Web 应用服务器构建 Web Application Context 的时候，会把启动类添加进去。</p>
<pre><code class="language-java">public class ServletInitializer extends SpringBootServletInitializer {
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {
        return application.sources(Application.class);
    }
}
</code></pre>
<p>Mybatis逆向工程插件模板</p>
<p><strong>generatorConfig.xml</strong>的配置文件之前已有上传。。</p>
<pre><code class="language-xml"> //他需要有个编译时的mysql——springboot内部的是scope是runtime
		&lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;version&gt;8.0.18&lt;/version&gt;
        &lt;/dependency&gt;

&lt;!-- 定义mybatis逆向工程代码生成插件 (生成之后建议注释掉)--&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
                &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.3.7&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;Generate MyBatis Artifacts&lt;/id&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;generate&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
                &lt;configuration&gt;
                    &lt;!-- ${basedir}是maven提供的内置变量，获取的是项目根目录的路径 --&gt;
                    &lt;!-- 指定自定义配置文件（代码生成工具）路径 --&gt;
                    &lt;configurationFile&gt;${basedir}/src/main/resources/mybatis/generatorConfig.xml&lt;/configurationFile&gt;
                    &lt;includeCompileDependencies&gt;true&lt;/includeCompileDependencies&gt;
                    &lt;overwrite&gt;true&lt;/overwrite&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
</code></pre>
<h1 id="springboot-ssm整合">SpringBoot-SSM整合</h1>
<h2 id="第一步">第一步：</h2>
<p>配置pom.xml以及生成Mybatis逆向工程</p>
<h2 id="第二步">第二步</h2>
<p>标识启动类</p>
<h2 id="第三步">第三步</h2>
<p>application.yml配置填写</p>
<h2 id="第四步">第四步</h2>
<p>开始需求书写（层级就可以开始了）</p>
<h2 id="thymeleaf模板引擎取代jsp视图">Thymeleaf模板引擎取代JSP视图</h2>
<p>SpringBoot官方建议我们使用Thymeleaf模板引擎取代JSP视图，如果我们就想使用JSP怎么办呢？可以，做好下面几步配置就可以了</p>
<h3 id="第一步修改pomxml中的打包方式为war">第一步：修改pom.xml中的打包方式为war</h3>
<pre><code>&lt;project&gt;
     ...
    &lt;packaging&gt;war&lt;/packaging&gt;
     ...
&lt;/project&gt;
</code></pre>
<h3 id="第二步添加jsp依赖">第二步：添加JSP依赖</h3>
<pre><code>&lt;!--配置支持jsp--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;
    &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;
&lt;/dependency&gt;

</code></pre>
<h3 id="第三步配置internalresourceviewresolver参数">第三步：配置InternalResourceViewResolver参数</h3>
<pre><code>spring:
  mvc:
    view:
      prefix: /WEB-INF/ #配置JSP文件前缀
      suffix: .jsp      #配置JSP页面后缀

</code></pre>
<blockquote>
<p>注：<br>
1、jsp页面必须放到webapp目录或webapp/WEB-INF/下<br>
2、如果使用了jsp作为视图，则工程只能打成war包部署(因为jar包不会将webapp目录下的东西打进去)</p>
</blockquote>
<h1 id="踩坑ing">踩坑ing</h1>
<pre><code class="language-xml">mybatis:  mapper-locations: classpath:/mybatis/mappers/*.xml


config-location: &lt;!--二者有区别--&gt;

</code></pre>
<ol>
<li>Date类解决</li>
</ol>
<ul>
<li>在Spring Boot项目中，使用==@RestController==注解，返回的java对象中若含有date类型的属性，则<strong>默认输出为TIMESTAMP时间戳格式</strong></li>
</ul>
<p>在application.properties配置文件增加以下配置:</p>
<pre><code class="language-properties">spring.jackson.date-format=yyyy-MM-dd HH:mm:ss
spring.jackson.time-zone=GMT+8
#之前的做法是在bean类的date属性上添加注解@JSONFormat（&quot;yyyy-MM-dd HH:mm:ss&quot;）

</code></pre>
<ul>
<li>在Spring Boot项目中，使用==@Controller==注解，储存在Model中的java对象中若含有date类型的属性，则默认是GBK格式</li>
</ul>
<pre><code class="language-html">#dates.format()
用来格式化日期时间

${#dates.format(date, 'dd/MMM/yyyy HH:mm')}
${#dates.arrayFormat(datesArray, 'dd/MMM/yyyy HH:mm')}
${#dates.listFormat(datesList, 'dd/MMM/yyyy HH:mm')}
${#dates.setFormat(datesSet, 'dd/MMM/yyyy HH:mm')}

&lt;!--强势——&gt;

&lt;td th:text=&quot;${#dates.format(book.publish, 'yyyy-MM-dd HH:mm')}&quot;&gt;&lt;/td&gt;

</code></pre>
<ul>
<li><code>@InitBinder</code>用于在<code>@Controller</code>中标注于方法，表示为当前控制器注册一个属性编辑器或者其他，只对当前的Controller有效。<mark>而@Controller必须显式的存在Date类</mark></li>
</ul>
<pre><code class="language-Java">@InitBinderpublic void initBinder(ServletRequestDataBinder binder) {  
    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);    binder.registerCustomEditor(Date.class, new CustomDateEditor(sdf, true));
}

</code></pre>
<pre><code class="language-java">/**
 * 全局handler前日期统一处理
 * @author zhanghang
 * @date 2018/1/11
 */
@Component
public class DateConverterConfig implements Converter&lt;String, Date&gt; {

    private static final List&lt;String&gt; formarts = new ArrayList&lt;&gt;(4);
    static{
        formarts.add(&quot;yyyy-MM&quot;);
        formarts.add(&quot;yyyy-MM-dd&quot;);
        formarts.add(&quot;yyyy-MM-dd hh:mm&quot;);
        formarts.add(&quot;yyyy-MM-dd hh:mm:ss&quot;);
    }

    @Override
    public Date convert(String source) {
        String value = source.trim();
        if (&quot;&quot;.equals(value)) {
            return null;
        }
        if(source.matches(&quot;^\\d{4}-\\d{1,2}$&quot;)){
            return parseDate(source, formarts.get(0));
        }else if(source.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2}$&quot;)){
            return parseDate(source, formarts.get(1));
        }else if(source.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}$&quot;)){
            return parseDate(source, formarts.get(2));
        }else if(source.matches(&quot;^\\d{4}-\\d{1,2}-\\d{1,2} {1}\\d{1,2}:\\d{1,2}:\\d{1,2}$&quot;)){
            return parseDate(source, formarts.get(3));
        }else {
            throw new IllegalArgumentException(&quot;Invalid boolean value '&quot; + source + &quot;'&quot;);
        }
    }

    /**
     * 格式化日期
     * @param dateStr String 字符型日期
     * @param format String 格式
     * @return Date 日期
     */
    public  Date parseDate(String dateStr, String format) {
        Date date=null;
        try {
            DateFormat dateFormat = new SimpleDateFormat(format);
            date = dateFormat.parse(dateStr);
        } catch (Exception e) {

        }
        return date;
    }

}
//还没有验证对错、、、、、、、

</code></pre>
<ul>
<li>
<p><strong>layUI中的表格cols[[</strong></p>
<p><strong>{}</strong></p>
<p><strong>]]和thymeleaf中的内联表达式冲突需要这样书写，简单改变下冲突cols[</strong></p>
<p><strong>[{</strong></p>
<p>​     <strong>}]</strong></p>
<p><strong>]</strong></p>
</li>
<li>
<p><strong>banner文件</strong></p>
</li>
</ul>
<pre><code class="language-Java">/*SpringApplication.run(SpringbootSsmApplication.class, args);*/


//对比

//关闭banner
SpringApplicationBuilder sub
= new SpringApplicationBuilder(SpringbootSsmApplication.class);

sub.bannerMode(Banner.Mode.OFF).run(args);

</code></pre>
<ul>
<li>好玩的</li>
</ul>
<pre><code class="language-css">table, tr, td, th {   
    /*用来决定表格的边框是分开的还是合并的：collapse、separate*/   
    border-collapse: separate;
}

&lt;!--引入css使用link--&gt;
 /*在HTML中，&lt;link&gt;标签没有结束标签。rel属性用于定义当前文档与被链接文档之间的关系。*/  
&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/table_y.css&quot;&gt;
&lt;!--引入js使用script--&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;myscripts.js&quot;&gt;&lt;/script&gt;





注释：外部文件不能包含 &lt;script&gt; 标签！

</code></pre>
<h1 id="导入import"><strong>导入import：</strong></h1>
<h3 id="springboot-21版本解决tomcat最大支持10m文件上传问题">SpringBoot 2.1版本解决Tomcat最大支持10M文件上传问题</h3>
<pre><code class="language-Java">@Bean
public TomcatServletWebServerFactory tomcatEmbedded() {
    TomcatServletWebServerFactory tomcat = new TomcatServletWebServerFactory();
    tomcat.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; {
        if ((connector.getProtocolHandler() instanceof AbstractHttp11Protocol&lt;?&gt;)) {
            //-1 means unlimited
            ((AbstractHttp11Protocol&lt;?&gt;) connector.getProtocolHandler()).setMaxSwallowSize(-1);
        }
    });
    return tomcat;
}

</code></pre>
<h3 id="springboot-15版本解决tomcat最大只能上传10m文件问题">SpringBoot 1.5版本解决Tomcat最大只能上传10M文件问题</h3>
<pre><code class="language-java">@Bean
public TomcatEmbeddedServletContainerFactory tomcatFactory() {
    TomcatEmbeddedServletContainerFactory tomcatFactory = new TomcatEmbeddedServletContainerFactory();
    tomcatFactory.addConnectorCustomizers((TomcatConnectorCustomizer) connector -&gt; {
        if ((connector.getProtocolHandler() instanceof AbstractHttp11Protocol&lt;?&gt;)) {
            //-1 means unlimited
            ((AbstractHttp11Protocol&lt;?&gt;) connector.getProtocolHandler()).setMaxSwallowSize(-1);
        }
    });
    return tomcatFactory;
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Solr搜索详细总结]]></title>
        <id>https://cxp-twx.github.io/post/solr-sou-suo-xiang-xi-zong-jie</id>
        <link href="https://cxp-twx.github.io/post/solr-sou-suo-xiang-xi-zong-jie">
        </link>
        <updated>2019-10-28T07:51:57.000Z</updated>
        <content type="html"><![CDATA[<h1 id="solr搜索引擎">Solr搜索引擎</h1>
<h2 id="solr下载安装">Solr下载安装</h2>
<ul>
<li>官方下载地址：https://archive.apache.org/dist/lucene/solr/</li>
<li>Windows系统下载zip包，Linux、MaxOS系统下载tgz包</li>
</ul>
<h2 id="solr目录结构">Solr目录结构</h2>
<ul>
<li>bin： 存放solr的可执行文件</li>
<li>contrib： 存放solr提供的扩展包</li>
<li>dist: Solr运行需要的jar包</li>
<li>docs: 文档目录</li>
<li>example: 官方提供的示例目录，配合官方示例教程，体验Solr功能</li>
<li>licences: 协议目录</li>
<li>server: solr工作的主目录，里面有默认的配置，将来创建的核心也会默认存储到此目录下，Solr Admin程序也在此目录下</li>
</ul>
<h2 id="错误点">错误点</h2>
<figure data-type="image" tabindex="1"><img src="https://img-blog.csdnimg.cn/20191107143559255.png" alt=""></figure>
<figure data-type="image" tabindex="2"><img src="https://img-blog.csdnimg.cn/20191107143354809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<p>终极办法：删除相关port的文件重新启动</p>
<h2 id="基本命令">基本命令</h2>
<p>解压：</p>
<pre><code class="language-bash">~$ unzip -q solr-8.2.0.zip
</code></pre>
<h2 id="启动">启动</h2>
<h3 id="window10下">window10下</h3>
<p>在包目录下启动命令行</p>
<p>输入</p>
<blockquote>
<p>bin\solr.cmd start -e cloud</p>
</blockquote>
<p>停止端口命令：</p>
<blockquote>
<p>bin\solr stop -all</p>
</blockquote>
<p>重启</p>
<blockquote>
<p>bin/solr restart [options]</p>
<p>最好分别开启</p>
</blockquote>
<p>其他命令：</p>
<ul>
<li>上图有查看进程占用和杀进程</li>
<li>创建示例数据源</li>
</ul>
<pre><code class="language-bash"> java -jar -Dc=techproducts -Dauto example\exampledocs\post.jar example\exampledocs\*
</code></pre>
<ul>
<li>
<p>上传文件</p>
<p>rz -be</p>
</li>
<li>
<p>删除创建的集合</p>
</li>
<li>
<p>bin/solr delete -c  name</p>
</li>
<li>
<p>创建新的集合</p>
<ul>
<li>bin/solr create -c  newName  -s 2 -rf 2</li>
</ul>
</li>
</ul>
<h3 id="linux下">Linux下</h3>
<p>启动</p>
<pre><code class="language-bash">./bin/solr start -e cloud
</code></pre>
<p>创建示例数据源</p>
<pre><code class="language-bash">$ bin/post -c techproducts example/exampledocs/*
</code></pre>
<p>重启分别开启端口：</p>
<blockquote>
<p>./bin/solr start -c -p 8983 -s example/cloud/node1/solr</p>
<p>./bin/solr start -c -p 7574 -s example/cloud/node2/solr -z localhost:9983</p>
</blockquote>
<h3 id="通用">通用：</h3>
<p>创建集合（配置）</p>
<p>sample_techproducts_configs</p>
<hr>
<p>基本结束可以进行Solr的各种query！！！</p>
<h2 id="solr中常用">Solr中常用</h2>
<p>q：查询条件（可指定字段，短语，组合等）</p>
<p>fl：可指定返回的字段</p>
<p>df：默认按照某种字段查询</p>
<p>创建字段</p>
<p>方法：</p>
<ol>
<li>使用Linux 命令行</li>
<li>使用postman选择post方式(“add-filed”)</li>
<li>Solr搜索引擎-Schema:</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9sdWNlbmUuYXBhY2hlLm9yZy9zb2xyL2d1aWRlLzhfMi9pbWFnZXMvc29sci10dXRvcmlhbC90dXRvcmlhbC1hZGQtZmllbGQucG5n?x-oss-process=image/format,png" alt=""></figure>
<p>Copy字段</p>
<p>方法：</p>
<ol>
<li>
<p>使用Linux 命令行</p>
</li>
<li>
<p>使用postman选择post方式（“add-copy-filed”）</p>
<blockquote>
<p>作用： 使其他字段通过copy的方式覆盖（也就是增大了搜索范围）</p>
</blockquote>
</li>
<li>
<p>Solr搜索引擎-Schema:</p>
</li>
</ol>
<h2 id="建立自己的搜索库">建立自己的搜索库</h2>
<p>create，以及进行准备工作</p>
<h2 id="配置中文分词器">配置中文分词器</h2>
<p>managed-schema文件中添加</p>
<pre><code class="language-xml">&lt;fieldType name=&quot;text_zh&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt;
    &lt;analyzer type=&quot;index&quot;&gt;
      &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
      &lt;filter class=&quot;solr.CJKWidthFilterFactory&quot;/&gt;
      &lt;filter class=&quot;solr.StopFilterFactory&quot;
              words=&quot;org/apache/lucene/analysis/cn/smart/stopwords.txt&quot;/&gt;
      &lt;filter class=&quot;solr.PorterStemFilterFactory&quot;/&gt;
      &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
      &lt;/analyzer&gt;
    &lt;analyzer type=&quot;query&quot;&gt;
      &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
      &lt;filter class=&quot;solr.CJKWidthFilterFactory&quot;/&gt;
      &lt;filter class=&quot;solr.StopFilterFactory&quot;
              words=&quot;org/apache/lucene/analysis/cn/smart/stopwords.txt&quot;/&gt;
      &lt;filter class=&quot;solr.PorterStemFilterFactory&quot;/&gt;
      &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
    &lt;/analyzer&gt;
&lt;/fieldType&gt;
</code></pre>
<p>核心配置文件中添加.jar</p>
<pre><code class="language-xml">&lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/analysis-extras/lucene-libs&quot; regex=&quot;.*\.jar&quot; /&gt;
</code></pre>
<h2 id="定义字段">定义字段</h2>
<blockquote>
<p>新版本建议通过命令行（个人觉得方便的是postman方式）添加；其实也可以在文件中粘贴复制添加（好像新版本添加的不生效，应该是两种方式不能混合用）</p>
</blockquote>
<ul>
<li>addfiled的名字不用和数据库保持一致，查的时候一样即可</li>
</ul>
<p>如何删除字段？</p>
<pre><code class="language-json">{&quot;delete-filed&quot;:{&quot;name&quot; : &quot;filedName&quot;}}
</code></pre>
<p>Solr中的“无模式”，可以自动根据类型配字段（有坑）</p>
<h3 id="动态字段">动态字段</h3>
<p>添加copy filed</p>
<p>dest：目标</p>
<p>source：字段源</p>
<p>添加dynamic filed  (*_开头)</p>
<p>（add-dynamic-filed）</p>
<p>copy到dynamic 字段的时候都要有*_</p>
<p>示例：</p>
<p><em>—</em>——</p>
<pre><code class="language-json">{“add-copy-filed&quot; :{&quot;source&quot;:&quot;*_subject&quot;,&quot;dest&quot;:&quot;\*\_keywords&quot;}}
</code></pre>
<p>至此可以通过idea批量插入代码并进行操作了！！！</p>
<h2 id="开始java批量加入数据">开始Java批量加入数据</h2>
<h1 id="错误及其litterkey">错误及其LitterKey</h1>
<ol>
<li>
<p>postman的字段可转码中文：</p>
<blockquote>
<p>选中中文右击选择encode</p>
</blockquote>
</li>
<li>
<p>multiValued：是否数组（单值）</p>
</li>
<li>
<p>stored：是否保存</p>
</li>
<li>
<p>indexed：是否索引（不索引不能搜索）</p>
</li>
<li>
<p>solrconfig.xml（核心配置）和managed schema（关联数据库操作）文件的作用<br>
路径：..\solr-8.2.0\server\solr\configsets_default\conf</p>
</li>
<li>
<p>To Index JSON Format</p>
<pre><code class="language-bash">bin/post -c films example/films/films.json

..\solr-8.2.0&gt; java -jar -Dc=films -Dauto example\exampledocs\post.jar example\films\*.json

</code></pre>
</li>
<li>
<p>facet：构面计数</p>
</li>
<li>
<p>删除（delete）collection时先删除、后停止Solr（重启时一个节点一个节点的开启可以写成一个.bak文件）</p>
</li>
<li>
<p>不要使用 example、cloud（这是测试目录），自己去创建一个集群</p>
</li>
<li>
<p>集群模式Solr(-c启动)和单机模式（可以产生添加字段managed schema文件发生变化即增加字段filed）</p>
</li>
<li>
<p>单机模式启动bin\solr.cmd start （无参数）| 无core（核心）可用，要先创建一个bin\solr.cmd create -c lanou3g、目录所在（..\solr-8.2.0\server\solr）是基于_default目录下的文件创建的。</p>
</li>
</ol>
<p><span style="float: right;color: red;">Author   :   陈祥朋 </span></p>
<hr>
<h1 id="以下为转载君哥的"><mark>以下为转载君哥的</mark>：</h1>
<h1 id="1-solr入门">1. Solr入门</h1>
<h2 id="11-solr下载安装">1.1. Solr下载安装</h2>
<p>官方下载地址：https://archive.apache.org/dist/lucene/solr/</p>
<p>Windows系统下载zip包，Linux、MaxOS系统下载tgz包</p>
<h2 id="111-solr目录结构">1.1.1. Solr目录结构</h2>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdnimg.cn/20191113104819175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<ul>
<li>bin： 存放solr的可执行文件</li>
<li>contrib： 存放solr提供的扩展包</li>
<li>dist: Solr运行需要的jar包</li>
<li>docs: 文档目录</li>
<li>example: 官方提供的示例目录，配合官方示例教程，体验Solr功能</li>
<li>licences: 协议目录</li>
<li>server: solr工作的主目录，里面有默认的配置，将来创建的核心也会默认存储到此目录下，Solr Admin程序也在此目录下</li>
</ul>
<h2 id="12-solr入门">1.2. Solr入门</h2>
<h3 id="121-运行官方示例项目">1.2.1. 运行官方示例项目</h3>
<p>官方示例教程文档： https://lucene.apache.org/solr/guide/8_2/solr-tutorial.html</p>
<p>官方提供了三个示例教程，从Solr怎么简单使用，到怎么创建自己的搜索库，一步一步有引导，推荐跟着练习一遍。</p>
<h3 id="122-solr-admin-ui的使用">1.2.2. Solr Admin UI的使用</h3>
<p>Solr Admin是Solr给我们提供的一个方便查询和管理Solr的Web控制台应用，通过此应用，我们不需要编写任何程序就可以对Solr的很多功能进行操作。</p>
<p>默认访问地址： http://localhost:8983/solr</p>
<figure data-type="image" tabindex="5"><img src="https://img-blog.csdnimg.cn/20191113104901119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="1221-简单查询">1.2.2.1. 简单查询</h4>
<h4 id="1222-按照某个字段搜索">1.2.2.2. 按照某个字段搜索</h4>
<h4 id="1223-搜索短语">1.2.2.3. 搜索短语</h4>
<h4 id="1224-搜索结果中只返回某些字段">1.2.2.4. 搜索结果中只返回某些字段</h4>
<h4 id="1225-搜索结果分页">1.2.2.5. 搜索结果分页</h4>
<figure data-type="image" tabindex="6"><img src="https://img-blog.csdnimg.cn/20191113104943258.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h4 id="1226-搜索结果高亮显示">1.2.2.6. 搜索结果高亮显示</h4>
<p>搜索参数设置：</p>
<figure data-type="image" tabindex="7"><img src="https://img-blog.csdnimg.cn/20191113105027724.png" alt="在这里插入图片描述"></figure>
<p>搜索结果展示：</p>
<p><strong><img src="https://img-blog.csdnimg.cn/20191113105342188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></strong></p>
<h4 id="1227-删除solr索引库中的数据">1.2.2.7. 删除Solr索引库中的数据</h4>
<figure data-type="image" tabindex="8"><img src="https://img-blog.csdnimg.cn/20191113105109330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NoZW5fbmVhbF9KYXZh,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></figure>
<h1 id="2-深入solr">2. 深入Solr</h1>
<h2 id="21-solr配置文件">2.1. Solr配置文件</h2>
<h3 id="211-managed-schema文件">2.1.1. managed-schema文件</h3>
<p>managed-schema文件是Solr中core或collection的搜索库定义配置文件，里面配置了搜索库有哪些Field和FieldType等。</p>
<p>Solr的工作流程大体如下：</p>
<ul>
<li>创建用于存储被搜索数据的core或collection(集群模式)；</li>
<li>定义创建的core有哪些字段，以及哪些字段需要索引、哪些字段只存储，不需要索引。具体来说，就是通过Solr提供的SchemaAPI去管理core中的字段；</li>
<li>将数据导入到Solr中，在此过程中，Solr会对导入的数据建索引（所以一定要先定义Schema字段，再导入数据）；</li>
<li>调用Solr的HttpAPI搜索数据</li>
</ul>
<blockquote>
<p>managed-schema文件就是用来管理某个core中有哪些字段或者字段类型，可以把Solr当成是一个数据库，里面有字段、有字段类型、能存储、能查询（搜索）</p>
</blockquote>
<h4 id="2111-solr中常用的数据类型">2.1.1.1. Solr中常用的数据类型</h4>
<p>Solr中主要的数据类型由实现类和类型定义两部分组成， 数据类型是由Solr中定义好的Java类，类型定义是在managed-schema文件中定义的，数据类型不能直接使用，必须在managed-schema中定义后才能直接在字段中引用。</p>
<p>在managed-schema中定义字段类型时，会将数据类型和其他属性（如：是否多值、是否存储）组合到一起</p>
<p>默认的managed-schema配置文件中已经定义了一些常用的数据类型，如</p>
<pre><code class="language-xml">&lt;fieldType name=&quot;string&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; docValues=&quot;true&quot; /&gt;
&lt;fieldType name=&quot;strings&quot; class=&quot;solr.StrField&quot; sortMissingLast=&quot;true&quot; multiValued=&quot;true&quot; docValues=&quot;true&quot; /&gt;
&lt;fieldType name=&quot;boolean&quot; class=&quot;solr.BoolField&quot; sortMissingLast=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;booleans&quot; class=&quot;solr.BoolField&quot; sortMissingLast=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pint&quot; class=&quot;solr.IntPointField&quot; docValues=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pfloat&quot; class=&quot;solr.FloatPointField&quot; docValues=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;plong&quot; class=&quot;solr.LongPointField&quot; docValues=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pdouble&quot; class=&quot;solr.DoublePointField&quot; docValues=&quot;true&quot;/&gt;

&lt;fieldType name=&quot;pints&quot; class=&quot;solr.IntPointField&quot; docValues=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pfloats&quot; class=&quot;solr.FloatPointField&quot; docValues=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;plongs&quot; class=&quot;solr.LongPointField&quot; docValues=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pdoubles&quot; class=&quot;solr.DoublePointField&quot; docValues=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;random&quot; class=&quot;solr.RandomSortField&quot; indexed=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pdate&quot; class=&quot;solr.DatePointField&quot; docValues=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;pdates&quot; class=&quot;solr.DatePointField&quot; docValues=&quot;true&quot; multiValued=&quot;true&quot;/&gt;
&lt;fieldType name=&quot;binary&quot; class=&quot;solr.BinaryField&quot;/&gt;

</code></pre>
<p>可以看到每个字段类型定义都由类型的实现类和若干个其他属性组合而成</p>
<p>除了上面定义的简单类型之外默认的managed-schema文件中还定义了一些特殊的字段类型</p>
<pre><code class="language-xml">&lt;!-- ignored类型本身是一个StrField类型，但是将stored和indexed都定义成了false，代表不存储、不建索引，实际上就是忽略数据中的此字段不处理 --&gt;
&lt;fieldType name=&quot;ignored&quot; stored=&quot;false&quot; indexed=&quot;false&quot; multiValued=&quot;true&quot; class=&quot;solr.StrField&quot; /&gt;

</code></pre>
<p>带分词功能的字段类型</p>
<pre><code class="language-xml">&lt;!-- text_general类型和上面的字段类型定义语法一样，本身数据solr.TextField类型，但是声明时通过内部的子标签指定了数据存储索引和数据搜索索引的分词器 --&gt;
&lt;fieldType name=&quot;text_general&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot; multiValued=&quot;true&quot;&gt;
    &lt;analyzer type=&quot;index&quot;&gt;
        &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;
        &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;
        &lt;!-- in this example, we will only use synonyms at query time
        &lt;filter class=&quot;solr.SynonymGraphFilterFactory&quot; synonyms=&quot;index_synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;false&quot;/&gt;
        &lt;filter class=&quot;solr.FlattenGraphFilterFactory&quot;/&gt;
        --&gt;
        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
    &lt;/analyzer&gt;
    &lt;analyzer type=&quot;query&quot;&gt;
        &lt;tokenizer class=&quot;solr.StandardTokenizerFactory&quot;/&gt;
        &lt;filter class=&quot;solr.StopFilterFactory&quot; ignoreCase=&quot;true&quot; words=&quot;stopwords.txt&quot; /&gt;
        &lt;filter class=&quot;solr.SynonymGraphFilterFactory&quot; synonyms=&quot;synonyms.txt&quot; ignoreCase=&quot;true&quot; expand=&quot;true&quot;/&gt;
        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
    &lt;/analyzer&gt;
&lt;/fieldType&gt;

</code></pre>
<h4 id="2112-添加字段类型定义fieldtype">2.1.1.2. 添加字段类型定义(FieldType)</h4>
<p>我们添加自定义字段类型的一个重要应用场景就是当我们的字段需要支持中文分词时，指定字段的实现类型是</p>
<p>solr.TextField，然后指定数据存储索引和搜索的索引分词器为支持中文的分词器。</p>
<p>语法参见上一章节 带分词功能的字段类型，中文分词器的配置参见配置中文分词器章节</p>
<h4 id="2113-solr中的无模式模式和字段类型自动推测">2.1.1.3. Solr中的&quot;无模式&quot;模式和字段类型自动推测</h4>
<p>我们在将数据导入到Solr中时，如果事先没有添加字段，Solr会根据数据的内容，自动推测应该用什么字段类型，并且自动生成field配置标签到当前core对应的managed-schema配置文件中</p>
<h4 id="2114-添加字段field">2.1.1.4. 添加字段(Field)</h4>
<p>前面说过managed-schema中主要就是定义了fieldType和field， 在以前老版本的solr中managed-schema的名字叫做schema.xml，可以直接手动编辑文件维护其中的字段定义。</p>
<p>而在新版本的Solr中，官方不建议手动修改此文件，改用Schema API的方式来维护字段</p>
<p>配置示例</p>
<pre><code class="language-xml">&lt;field name=&quot;price&quot; type=&quot;float&quot; default=&quot;0.0&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;

</code></pre>
<p>定义字段需要指定字段的名称、类型(引用上面声明的fieldType的名称)、默认值、是否存储、是否索引等。</p>
<h4 id="2115-添加拷贝字段copy-field">2.1.1.5. 添加拷贝字段(Copy Field)</h4>
<p>Solr支持通过配置Copy Field，将多个字段拷贝到某个字段上，这样在搜索时，可以只用一个字段实现同时搜索多个字段内容的效果。</p>
<p>配置示例</p>
<pre><code class="language-xml">&lt;copyField source=&quot;cat&quot; dest=&quot;text&quot; maxChars=&quot;30000&quot; /&gt;

</code></pre>
<h4 id="2116-动态字段dynamic-fields">2.1.1.6. 动态字段(Dynamic Fields)</h4>
<p>Solr可以通过配置动态字段来实现对某些名称相似的字段统一管理，因为动态字段定义时名称中允许包含通配符。</p>
<p>动态字段和普通字段作用一致，唯一不同的就是名称中允许包含通配符，Solr在索引数据时会优先查找配置中定义的准确字段(通过field配置的字段)，如果没有找到匹配的，就从动态字段中找是否有匹配的，如果找到，就用动态字段的字段定义来索引数据。</p>
<p>配置示例</p>
<pre><code class="language-xml">&lt;dynamicField name=&quot;*_i&quot; type=&quot;int&quot; indexed=&quot;true&quot;  stored=&quot;true&quot;/&gt;

</code></pre>
<h3 id="212-schema-api">2.1.2. Schema API</h3>
<p>为了减少手动编辑managed-schema文件引入的错误，新版本的Solr提供了一套基于HTTP协议的Schema API来维护managed-schema文件</p>
<p>Schema API可以完成以下操作</p>
<h4 id="2121-add-field">2.1.2.1. add-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;add-field&quot;:{
     &quot;name&quot;:&quot;sell_by&quot;,
     &quot;type&quot;:&quot;pdate&quot;,
     &quot;stored&quot;:true }
}' http://localhost:8983/api/cores/gettingstarted/schema

</code></pre>
<h4 id="2122-delete-field">2.1.2.2. delete-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;delete-field&quot; : { &quot;name&quot;:&quot;sell_by&quot; }
}' http://localhost:8983/api/cores/gettingstarted/schema

</code></pre>
<h4 id="2123-replace-field">2.1.2.3. replace-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;replace-field&quot;:{
     &quot;name&quot;:&quot;sell_by&quot;,
     &quot;type&quot;:&quot;date&quot;,
     &quot;stored&quot;:false }
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="2124-add-dynamic-field">2.1.2.4. add-dynamic-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;add-dynamic-field&quot;:{
     &quot;name&quot;:&quot;*_s&quot;,
     &quot;type&quot;:&quot;string&quot;,
     &quot;stored&quot;:true }
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="2125-delete-dynamic-field">2.1.2.5. delete-dynamic-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;delete-dynamic-field&quot;:{ &quot;name&quot;:&quot;*_s&quot; }
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="2126-replace-dynamic-field">2.1.2.6. replace-dynamic-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;replace-dynamic-field&quot;:{
     &quot;name&quot;:&quot;*_s&quot;,
     &quot;type&quot;:&quot;text_general&quot;,
     &quot;stored&quot;:false }
}' http://localhost:8983/solr/gettingstarted/schema


</code></pre>
<h4 id="2127-add-field-type">2.1.2.7. add-field-type</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;add-field-type&quot;:{
     &quot;name&quot;:&quot;myNewTextField&quot;,
     &quot;class&quot;:&quot;solr.TextField&quot;,
     &quot;indexAnalyzer&quot;:{
        &quot;tokenizer&quot;:{
           &quot;class&quot;:&quot;solr.PathHierarchyTokenizerFactory&quot;,
           &quot;delimiter&quot;:&quot;/&quot; }},
     &quot;queryAnalyzer&quot;:{
        &quot;tokenizer&quot;:{
           &quot;class&quot;:&quot;solr.KeywordTokenizerFactory&quot; }}}
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="2128-delete-field-type">2.1.2.8. delete-field-type</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;delete-field-type&quot;:{ &quot;name&quot;:&quot;myNewTxtField&quot; }
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="2129-replace-field-type">2.1.2.9. replace-field-type</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;replace-field-type&quot;:{
     &quot;name&quot;:&quot;myNewTxtField&quot;,
     &quot;class&quot;:&quot;solr.TextField&quot;,
     &quot;positionIncrementGap&quot;:&quot;100&quot;,
     &quot;analyzer&quot;:{
        &quot;tokenizer&quot;:{
           &quot;class&quot;:&quot;solr.StandardTokenizerFactory&quot; }}}
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="21210-add-copy-field">2.1.2.10. add-copy-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;add-copy-field&quot;:{
     &quot;source&quot;:&quot;shelf&quot;,
     &quot;dest&quot;:[ &quot;location&quot;, &quot;catchall&quot; ]}
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h4 id="21211-delete-copy-field">2.1.2.11. delete-copy-field</h4>
<p>使用示例</p>
<pre><code class="language-bash">curl -X POST -H 'Content-type:application/json' --data-binary '{
  &quot;delete-copy-field&quot;:{ &quot;source&quot;:&quot;shelf&quot;, &quot;dest&quot;:&quot;location&quot; }
}' http://localhost:8983/api/cores/gettingstarted/schema


</code></pre>
<h3 id="213-solrconfigxml文件">2.1.3. solrconfig.xml文件</h3>
<p>solrconfig.xml文件中定义了Solr core的数据目录、需要的第三方jar包、索引配置等。一般我们修改这个配置文件主要是配置中文分词器，因为Solr官方默认没有配置支持中文分词器的字段类型。</p>
<h2 id="22-core-vs-collection">2.2. Core VS Collection</h2>
<blockquote>
<p>在单机模式启动的Solr中一个搜索数据集叫做core，而在集群模式启动的Solr中搜索数据集的名称叫做collection</p>
</blockquote>
<h3 id="221-单机模式使用solr">2.2.1. 单机模式使用Solr</h3>
<h4 id="2211-以单机模式启动solr">2.2.1.1. 以单机模式启动Solr</h4>
<pre><code class="language-bash">bin/solr start  # linux、macos
bin\solr.cmd start # windows


</code></pre>
<p>启动成功后命令行会有如下输出</p>
<pre><code>Started Solr server on port 8983. Happy searching!


</code></pre>
<h4 id="2212-创建core核心">2.2.1.2. 创建core核心</h4>
<pre><code class="language-bash">bin/solr create -c 核心名  # linux、macos
bin\solr.cmd create -c 核心名 # windows


</code></pre>
<h4 id="2213-导入数据到solr">2.2.1.3. 导入数据到Solr</h4>
<blockquote>
<p>参见使用SpringBoot操作Solr章节</p>
</blockquote>
<h4 id="2214-停止单机版solr">2.2.1.4. 停止单机版Solr</h4>
<pre><code class="language-bash">bin/solr stop -all  # linux、macos
bin\solr.cmd stop -all # windows


</code></pre>
<h3 id="222-以集群模式启动solr">2.2.2. 以集群模式启动Solr</h3>
<h4 id="2221-以集群模式启动solr">2.2.2.1. 以集群模式启动Solr</h4>
<p>以集群模式启动Solr</p>
<pre><code class="language-bash">bin/solr start -c  # linux、macos
bin\solr.cmd start -c # windows


</code></pre>
<p>以集群模式启动后，如果没指定端口号，Solr默认会启动一个8983的节点；同时还会将内置的Zookeeper服务也启动起来，运行到9983端口上</p>
<p>向Solr集群中添加节点</p>
<pre><code class="language-bash">bin/solr start -c -p 节点端口号 -z localhost:9983 # linux、macos
bin\solr.cmd start -c -p 节点端口号 -z localhost:9983 # windows


</code></pre>
<p>-p参数指定节点运行的端口号，-z参数将新创建的节点添加到集群中</p>
<blockquote>
<p>Zookeeper是一个分布式管理框架，专门用来管理集群中各节点的状态。</p>
</blockquote>
<h4 id="2222-创建collection">2.2.2.2. 创建collection</h4>
<pre><code class="language-bash">bin/solr create -c collection名称 -s 2 -rf 2  # linux、macos
bin\solr.cmd create -c collection名称 -s 2 -rf 2 # windows


</code></pre>
<p>-c 参数指定创建的collection名称</p>
<p>-s 参数表示该collection要分布到几个分片上</p>
<p>-rf 参数表示每个分片有几个副本（用于容灾）</p>
<blockquote>
<p>Solr的集群模式和Reids集群类似，每个分片都有一个master节点和若干个slave节点组成，当master节点发生故障无法对外提供服务时，Solr集群会自动选举一个slave节点作为master对外服务。</p>
</blockquote>
<h4 id="2223-导入数据到solr集群">2.2.2.3. 导入数据到Solr集群</h4>
<blockquote>
<p>参见使用SpringBoot操作Solr章节</p>
</blockquote>
<h4 id="2224-停止solr集群">2.2.2.4. 停止Solr集群</h4>
<ul>
<li>
<p>停止集群中某个节点</p>
<pre><code class="language-bash">bin/solr stop -p 要停止的节点的端口号 # linux、macos
bin\solr.cmd stop -p 要停止的节点的端口号 # windows


</code></pre>
</li>
<li>
<p>停止整个Solr集群</p>
<pre><code class="language-bash">bin/solr stop -all # linux、macos
bin\solr.cmd stop -all # windows


</code></pre>
</li>
</ul>
<h2 id="23-配置中文分词器">2.3. 配置中文分词器</h2>
<p>分词器的作用在于将搜索的文本按照词组进行分割，可以大大的提高搜索的准确度。Solr对大部分的语言分词都进行了支持，其中也包括简体中文，但是遗憾的是截止最新的8.3.0版本，官方只是提供了中文分词的jar包，但是并没有对其进行配置。这就需要我们在用的时候配置中文分词器。</p>
<p>Solr官方提供了两种中文分词器：smartcn和icu</p>
<p>以smartcn分词器为例，配置方法如下：</p>
<h3 id="231-修改solrconfigxml配置文件添加中文分词器依赖">2.3.1. 修改solrconfig.xml配置文件，添加中文分词器依赖</h3>
<pre><code class="language-xml">......
&lt;lib dir=&quot;${solr.install.dir:../../../..}/dist/&quot; regex=&quot;solr-ltr-\d.*\.jar&quot; /&gt;
&lt;!-- 添加这行 --&gt;
&lt;lib dir=&quot;${solr.install.dir:../../../..}/contrib/analysis-extras/lucene-libs&quot; regex=&quot;.*\.jar&quot; /&gt;
......


</code></pre>
<h3 id="232-修改managed-schema配置文件新建fieldtype">2.3.2. 修改managed-schema配置文件，新建fieldType</h3>
<pre><code class="language-xml">&lt;!-- 添加自定义的支持中文分词的字段类型 --&gt;
&lt;fieldType name=&quot;text_zh&quot; class=&quot;solr.TextField&quot; positionIncrementGap=&quot;100&quot;&gt;
    &lt;analyzer type=&quot;index&quot;&gt;
        &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
        &lt;filter class=&quot;solr.CJKWidthFilterFactory&quot;/&gt;
        &lt;filter class=&quot;solr.StopFilterFactory&quot;
                words=&quot;org/apache/lucene/analysis/cn/smart/stopwords.txt&quot;/&gt;
        &lt;filter class=&quot;solr.PorterStemFilterFactory&quot;/&gt;
        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
    &lt;/analyzer&gt;
    &lt;analyzer type=&quot;query&quot;&gt;
        &lt;tokenizer class=&quot;org.apache.lucene.analysis.cn.smart.HMMChineseTokenizerFactory&quot;/&gt;
        &lt;filter class=&quot;solr.CJKWidthFilterFactory&quot;/&gt;
        &lt;filter class=&quot;solr.StopFilterFactory&quot;
                words=&quot;org/apache/lucene/analysis/cn/smart/stopwords.txt&quot;/&gt;
        &lt;filter class=&quot;solr.PorterStemFilterFactory&quot;/&gt;
        &lt;filter class=&quot;solr.LowerCaseFilterFactory&quot;/&gt;
    &lt;/analyzer&gt;
&lt;/fieldType&gt;


</code></pre>
<blockquote>
<p>在%solr安装目录%/server/configsets/_default/conf目录下有一份默认的配置文件managed-schema、solrconfig.xml。建议配置中文分词器时直接修改这个默认配置文件。因为在新建核心时，Solr会将这里的默认配置文件拷贝一份作为新核心的配置文件。</p>
</blockquote>
<h2 id="24-使用springboot操作solr">2.4. 使用SpringBoot操作Solr</h2>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-solr&lt;/artifactId&gt;
&lt;/dependency&gt;


</code></pre>
<p>application.yml中配置</p>
<pre><code class="language-yml">spring:
  data:
    solr:
      host: http://localhost:8983/solr/


</code></pre>
<p>通过Java代码导入数据到Solr和搜索</p>
<pre><code class="language-java">@Slf4j
@Service
public class SolrService {

    @Autowired
    private SolrClient solrClient;

    @Autowired
    private MessageDao messageDao;

    public static final int BATCH_SIZE = 10;

    public static final String CORE_NAME = &quot;lanou3g&quot;;

    /**
     * 将数据批量导入Solr中
     * @throws IOException
     * @throws SolrServerException
     */
    public void importData2Solr() throws IOException, SolrServerException {
        List&lt;Message&gt; messages = messageDao.loadAllMessage();
        List&lt;SolrInputDocument&gt; batchList = new ArrayList&lt;&gt;();
        messages.forEach((message -&gt; {

            // 将message对象转换成solr的inputDocument
            SolrInputDocument inDoc = new SolrInputDocument();
            inDoc.addField(&quot;id&quot;, message.getId());
            inDoc.addField(&quot;from_id&quot;, message.getFromId());
            inDoc.addField(&quot;to_id&quot;, message.getToId());
            inDoc.addField(&quot;subject&quot;, message.getSubject());
            inDoc.addField(&quot;content&quot;, message.getContent());
            inDoc.addField(&quot;createtime&quot;, message.getCreatetime());
            inDoc.addField(&quot;status&quot;, message.getStatus());
            inDoc.addField(&quot;attachment&quot;, message.getAttachment());

            batchList.add(inDoc);
            if(batchList.size() % BATCH_SIZE == 0) {
                try {
                    solrClient.add(CORE_NAME ,batchList);
                    batchList.clear();
                    log.info(&quot;批量导入&quot;+BATCH_SIZE+&quot;条到solr.&quot;);
                } catch (SolrServerException e) {
                    e.printStackTrace();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }));

        if(batchList.size() &gt; 0) {
            solrClient.add(CORE_NAME, batchList);
            log.info(&quot;批量导入&quot;+batchList.size()+&quot;条到solr.&quot;);
            batchList.clear();
        }
        log.info(&quot;数据导入完成！&quot;);

        // 提交数据到solr
//        solrClient.commit();  // 无参的需要在配置文件中将核心名称添加到solr url中，参见application.yml
        solrClient.commit(CORE_NAME);
    }


    /**
     * 从Solr中分页搜索数据
     * @param q 搜索关键字
     * @param fields 限制返回的结果集中只允许哪个字段
     * @param start 分页参数
     * @param pageSize   分页参数
     */
    public void searchFromSolr(String q, String[] fields, int start, int pageSize) {

        SolrQuery params = new SolrQuery(q);
        if(fields != null &amp;&amp; fields.length &gt; 0) {
            params.setFields(fields);
        }

        // 分页参数
        params.setStart(start);
        params.setRows(pageSize);

        // 不设置按照哪个字段搜索的时候，默认搜索哪个字段
        // （一般会将系统中所有支持检索的字段通过CopyField的方式拷贝到一个统一的字段上，用于搜索，比如下面的keywords）
        params.setParam(&quot;df&quot;, &quot;keywords&quot;);

        // 设置搜索结果高亮显示
        params.setHighlight(true);
        // 设置往搜索结果中所有匹配关键字的地方添加指定的前缀和后缀（内容随意）
        params.setHighlightSimplePre(&quot;&lt;i class=\&quot;keywords\&quot;&gt;&quot;);
        params.setHighlightSimplePost(&quot;&lt;/i&gt;&quot;);

        try {
//            QueryResponse queryResp = solrClient.query(params);
            QueryResponse queryResp = solrClient.query(CORE_NAME, params);
            SolrDocumentList results = queryResp.getResults();
            long numFound = results.getNumFound();
            System.out.println(&quot;总共搜索到&quot;+numFound+&quot;条结果&quot;);
            results.forEach((solrDoc) -&gt; {
                StringBuilder sb = new StringBuilder();
                sb.append(&quot;{&quot;);
                Collection&lt;String&gt; fieldNames = solrDoc.getFieldNames();
                fieldNames.forEach((fieldName) -&gt; {
                    Object fieldValue = solrDoc.getFieldValue(fieldName);
                    sb.append(&quot;\&quot;&quot;+fieldName+&quot;\&quot;:\&quot;&quot;+fieldValue+&quot;\&quot;,&quot;);
                });
                if(sb.length() &gt; 1) {
                    sb.deleteCharAt(sb.length() - 1);
                }
                sb.append(&quot;}&quot;);

                System.out.println(&quot;row: &quot; + sb.toString());
            });
        } catch (SolrServerException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

    }
}


</code></pre>
]]></content>
    </entry>
</feed>