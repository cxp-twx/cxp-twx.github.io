<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>CheckChen</title>
<meta name="description" content="吾日三省吾身" />
<link rel="shortcut icon" href="https://cxp-twx.github.io/favicon.ico?v=1576205079785">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://cxp-twx.github.io/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://cxp-twx.github.io">
  <img class="avatar" src="https://cxp-twx.github.io/images/avatar.png?v=1576205079785" alt="">
  </a>
  <h1 class="site-title">
    CheckChen
  </h1>
  <p class="site-description">
    吾日三省吾身
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

    
        <div class="post-container">
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/ji-he-kuang-jia">
        <h2 class="post-title">集合框架</h2>
      </a>
      <div class="post-info">
        <span>
          2017-11-18
        </span>
        <span>
          13 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/litenerandfilter-bi-ji">
        <h2 class="post-title">Litener&amp;Filter笔记</h2>
      </a>
      <div class="post-info">
        <span>
          2017-10-08
        </span>
        <span>
          13 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/maven-gong-cheng">
        <h2 class="post-title">Maven工程</h2>
      </a>
      <div class="post-info">
        <span>
          2017-08-18
        </span>
        <span>
          9 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/web-hui-gu">
        <h2 class="post-title">web回顾</h2>
      </a>
      <div class="post-info">
        <span>
          2017-06-13
        </span>
        <span>
          8 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        <h1 id="javaweb回顾">JavaWeb回顾</h1>
<h2 id="tomcat">Tomcat</h2>
<ul>
<li>命令</li>
<li>配置</li>
<li>部署</li>
</ul>
<h2 id="jsp">JSP</h2>
<h3 id="语法">语法</h3>
<p>JSP页面由以下几部分组成</p>
<ol>
<li>页面指令</li>
<li>HTML代码</li>
<li>Java代码片段</li>
<li>JavaScript代码</li>
<li>EL表达式</li>
<li>JSTL标签</li>
</ol>
<h3 id="页面指令">页面指令</h3>
<ul>
<li>page : 用来设置页面相关的属性、编码
<ul>
<li>language</li>
<li>contentType</li>
<li>import</li>
<li>pageEncoding</li>
<li>isErrorPage</li>
<li>errorPage</li>
</ul>
</li>
<li>include： 静态（编译期包含）包含其他页面到当前的JSP中
<ul>
<li>file</li>
</ul>
</li>
<li>taglib: 引入标签库
<ul>
<li>prefix</li>
<li>uri</li>
</ul>
</li>
</ul>
<h3 id="java代码片段">Java代码片段</h3>
<ul>
<li>
<p>普通Java代码片段</p>
<pre><code class="language-jsp">&lt;%
  out.println(&quot;Hello World!&quot;);
%&gt;
</code></pre>
</li>
<li>
<p>变量输出</p>
<pre><code class="language-jsp">&lt;% String message = &quot;Hello JSP&quot;; %&gt;

&lt;%=message %&gt;
</code></pre>
</li>
<li>
<p>变量声明、方法定义代码片段</p>
<pre><code class="language-jsp">&lt;%! 
	private int age = 70;
	
	public int getAge() {
        return age;
    }
%&gt;
</code></pre>
</li>
<li>
<p>Java代码中嵌套HTML</p>
<ul>
<li>
<p>纯Java代码拼接字符串</p>
<pre><code class="language-jsp">&lt;%
out.println(&quot;&lt;table&gt;&quot;);
for(int i = 0; i &lt; 3; i++) {
    out.println(&quot;&lt;tr&gt;&quot;);
    for(int j = 0; j &lt; 3; j++) {
		out.println(&quot;&lt;td&gt;i: &quot;+i+&quot;, j: &quot;+j+&quot;&lt;/td&gt;&quot;);
    }
    out.println(&quot;&lt;/tr&gt;&quot;);
}
out.println(&quot;&lt;/table&gt;&quot;);
%&gt;
</code></pre>
</li>
<li>
<p>嵌套HTML标签</p>
<pre><code class="language-jsp">&lt;table&gt;
    &lt;%
        for(int i = 0; i &lt; 3; i++) {
    %&gt;
    &lt;tr&gt;
    	&lt;%
        for(int j = 0; j &lt; 3; j++) {
        %&gt;
        &lt;td&gt;i: &lt;%=i %&gt;, j: &lt;%=j %&gt;&lt;/td&gt;
        &lt;%
        }
        %&gt;
    &lt;/tr&gt;
     &lt;%
        }
     %&gt;
&lt;/table&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="jstlel">JSTL&amp;EL</h3>
<p>JSTL是JSP的标准标签库，作用就是减少JSP中的JAVA代码片段，提高JSP页面代码的可读性。</p>
<p>EL表达式是一门表达式语言，通常用来配合JSTL实现变量取值，具体来说可以读取作用域中、请求头中、Cookie中、请求参数中的变量值。</p>
<h4 id="jstl标签库分类">JSTL标签库分类</h4>
<ul>
<li>核心标签库(core)
<ul>
<li>out</li>
<li>set</li>
<li>catch</li>
<li>forEach</li>
<li>forTokens</li>
<li>if</li>
<li>choose、when、otherwise</li>
<li>url、param</li>
</ul>
</li>
<li>格式化标签库(fmt)
<ul>
<li>formatDate</li>
<li>formatNumber</li>
</ul>
</li>
</ul>
<h4 id="el内置对象">EL内置对象</h4>
<ul>
<li>
<p>取Cookie中的值： cookie</p>
<pre><code class="language-jsp">${cookie.message} // 取Cookie中key为message的属性值
</code></pre>
</li>
<li>
<p>取请求头中的值： header</p>
<pre><code class="language-jsp">${header.username}  //取请求头中key为username的属性值
</code></pre>
</li>
<li>
<p>取请求参数中的值： param</p>
<pre><code class="language-jsp">${param.username}  //取请求参数中key为username的属性值
</code></pre>
</li>
<li>
<p>取作用域中的值</p>
<blockquote>
<p>EL表达式取作用域中的值，可以不显式使用内置对象，el会自动从最小的作用域pageScope中取，如果没找到指定参数，再去requestScope中找，再是sessionScope，最后是applicationScope。</p>
</blockquote>
<p>显式取特定作用域中的属性值</p>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
</ul>
<pre><code class="language-jsp">${sessionScope.user}  // EL会直接去session作用中取值，即使没有取到值也不会去其他作用域中尝试取值

</code></pre>
</li>
</ul>
<h4 id="jsp中的动作标签">JSP中的动作标签</h4>
<ul>
<li>useBean: 实例化一个Java类
<ul>
<li>class: 指定类的全名</li>
<li>id： 对象引用的变量名</li>
</ul>
</li>
<li>setProperty: 设置属性值
<ul>
<li>name： 指向useBean实例化的对象名称</li>
<li>property:  对象的属性名</li>
<li>value： 要设置的值</li>
</ul>
</li>
<li>getProperty： 获取属性值
<ul>
<li>name</li>
<li>property</li>
</ul>
</li>
<li>forward： 请求转发(地址栏不变)</li>
<li>param： 一般作为其他的标签的子元素，用于传参</li>
<li>include： 动态（在运行时才包含进来）包含其他JSP页面</li>
</ul>
<h4 id="四大作用域">四大作用域</h4>
<ul>
<li>
<p>pageContext: PageContext</p>
<p>范围：当前页面</p>
</li>
<li>
<p>request: HttpServletRequest</p>
<p>范围：一次请求</p>
</li>
<li>
<p>session: HttpSession</p>
<p>范围：一次会话</p>
</li>
<li>
<p>application: ServletContext</p>
<p>范围：整个应用声明周期</p>
</li>
</ul>
<h4 id="九大内置对象">九大内置对象</h4>
<ul>
<li>out</li>
<li>pageContext</li>
<li>request</li>
<li>session</li>
<li>application</li>
<li>response</li>
<li>page</li>
<li>config</li>
<li>exception</li>
</ul>
<h3 id="servlet">Servlet</h3>
<h4 id="servlet基础">Servlet基础</h4>
<ul>
<li>
<p>如何创建一个Servlet类？</p>
<ol>
<li>创建一个普通Java类</li>
<li>继承HttpServlet</li>
<li>重写doGet、doPost方法</li>
</ol>
</li>
<li>
<p>注册Servlet</p>
<ul>
<li>
<p>注解的方式： @WebServlet</p>
</li>
<li>
<p>xml的方式： 在web.xml中添加</p>
<pre><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;&lt;/servlet-name&gt;
    &lt;servlet-class&gt;&lt;/servlet-class&gt;
&lt;/servlet&gt;
&lt;servlet-mapping&gt;
	&lt;servlet-name&gt;&lt;/servlet-name&gt;
    &lt;url-pattern&gt;&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="servlet生命周期">Servlet生命周期</h4>
<ul>
<li>void init(ServletConfig config);   --初始化Servlet时调用（默认首次请求）</li>
<li>void service(HttpServletRequest req, HttpServletResponse resp);	 -- 每次请求此Servlet时调用</li>
<li>void destroy();   --销毁 （应用停止时调用）</li>
</ul>
<h4 id="文件上传">文件上传</h4>
<ul>
<li>通常文件上传： apache的 commons-fileupload、commons-io包。
<ul>
<li>FileItem</li>
<li>DiskFileItemFactory</li>
<li>ServletFileupload</li>
</ul>
</li>
<li>Servlet3.0： @MultipartConfig
<ul>
<li>Part</li>
</ul>
</li>
</ul>
<h4 id="查询分页">查询分页</h4>
<ul>
<li>
<p>物理分页</p>
<p>物理分页是在查询数据库时真正的进行了分页处理，每次只取一页的数据。</p>
</li>
<li>
<p>逻辑分页</p>
<p>逻辑分页在查询数据库时并没有做分页逻辑，而是把所有数据一次性加载到内存，在用户需要查看数据时，在内存中拿到当前页需要展示的数据，返回给页面展示。</p>
</li>
<li>
<p>通用分页参数</p>
<ul>
<li>currentPage： 当前页</li>
<li>pageSize: 每页展示条数</li>
<li>totalCount: 总条数</li>
<li>data: 当前页数据</li>
<li>totalPage: 总页数</li>
</ul>
</li>
</ul>
<h3 id="cookiesession">Cookie&amp;Session</h3>
<h4 id="cookie的特点">Cookie的特点</h4>
<ul>
<li>存储的数据大小很有限</li>
<li>Cookie是存储在客户端的</li>
<li>Cookie不能存储中文</li>
<li>安全性较低，不适合存储敏感数据</li>
</ul>
<h4 id="session的特点">Session的特点</h4>
<ul>
<li>Session存储的数据大小没有上限</li>
<li>Session是存储在服务端</li>
<li>Session中可以存储Java中所有类型的数据</li>
<li>安全性较高</li>
<li>Session是由Cookie演变而来的一种技术，本身也需要依赖Cookie（JSESSIONID）</li>
</ul>
<blockquote>
<p>Cookie和Session都属于会话跟踪技术，解决了HTTP协议无状态的问题。</p>
</blockquote>
<h4 id="cookie的使用">Cookie的使用</h4>
<ul>
<li>
<p>创建Cookie</p>
<p>Cookie cookie = new Cookie(&quot;key&quot;, &quot;value&quot;);</p>
</li>
<li>
<p>设置Cookie属性</p>
<p>cookie.setMaxAge(60);  //单位是秒， 设置为0代表立马删除</p>
<p>cookie.setPath();</p>
<p>cookie.setDomain();</p>
</li>
<li>
<p>写Cookie</p>
<p>response.addCookie(cookie);</p>
</li>
<li>
<p>获取Cookie中的数据</p>
<p>Cookie[] cookies = reuqest.getCookies();</p>
<p>// 遍历查找需要获取的数据</p>
</li>
</ul>
<h3 id="filter">Filter</h3>
<p>Filter的原理是能够在Servlet之前去接触到请求，进而完成一些例如： 设置请求参数、修改请求数据、重定向操作。</p>
<p>Filter是一个链式结构，应用中支持同时存在多个过滤器，他们通过chain.doFilter(req, resp)方法连起来，如果在某个filter中没有调用此方法，那么请求将无法正常往下进行。</p>
<h4 id="filter的使用">Filter的使用</h4>
<ol>
<li>创建Filter
<ol>
<li>新建一个普通Java类实现Filter接口</li>
<li>重写doFilter方法。 （看情况重写声明周期方法init、destroy）</li>
</ol>
</li>
<li>注册Filter
<ul>
<li>xml的方式  在web.xml中配置，和servlet类似</li>
<li>注解的方式  @WebFilter</li>
</ul>
</li>
</ol>
<h3 id="listener">Listener</h3>
<p>Listener用于监听特定的操作，当感兴趣的操作触发时，会自动回调Listener中的方法。</p>
<p>从作用上来说主要分以下几类：</p>
<ul>
<li>监听三大作用域创建、销毁
<ul>
<li>ServletRequestListener</li>
<li>HttpSessionListener</li>
<li>ServletContextListener</li>
</ul>
</li>
<li>监听三大作用域属性添加、移除、替换
<ul>
<li>ServletRequestAttributeListener</li>
<li>HttpSessionAttributeListener</li>
<li>ServletContextAttrbuteListener</li>
</ul>
</li>
</ul>
<blockquote>
<p>上面这六种监听器在使用时都需要通过注解@WebListener、或者在web.xml中注册</p>
</blockquote>
<h4 id="使用方法">使用方法</h4>
<ol>
<li>创建一个普通类，实现对应的Listener接口，并实现其中的方法</li>
<li>注册Listener。 注解、web.xml</li>
</ol>
<ul>
<li>不需要注册的监听器
<ul>
<li>监听特定对象从Session作用域中添加、移除的： HttpSessionBindingListener</li>
<li>监听Session钝化、活化： HttpSessionActivationListener</li>
</ul>
</li>
</ul>
<h4 id="使用方法-2">使用方法</h4>
<pre><code>1. 让特定对象实现对应的Listener接口

</code></pre>
<ol start="2">
<li>重写监听方法，完成业务操作</li>
</ol>
<h3 id="ajaxjquery-ajax">Ajax&amp;jQuery Ajax</h3>
<h4 id="原生ajax">原生Ajax</h4>
<ul>
<li>对象： XMLHttpRequest  (xhr)</li>
<li>get操作
<ol>
<li>创建请求对象</li>
<li>设置请求参数</li>
<li>设置回调函数</li>
<li>发起请求</li>
</ol>
</li>
<li>post操作
<ol>
<li>创建请求对象</li>
<li>设置请求参数</li>
<li>设置回调函数</li>
<li>设置请求头（编码格式）</li>
<li>发起请求</li>
</ol>
</li>
</ul>
<h4 id="jquery中的ajax">jQuery中的Ajax</h4>
<ul>
<li>ajax(url, {options});</li>
<li>get(url, data, fn, 'json');</li>
<li>post(url, data, fn, 'json');</li>
<li>getJSON(url, data, fn);</li>
</ul>

      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/java-jin-fa-guo-cheng-wen-ti-zong-jie">
        <h2 class="post-title">Java进发过程——问题总结</h2>
      </a>
      <div class="post-info">
        <span>
          2017-06-13
        </span>
        <span>
          10 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/ajax-fu-xi-bi-ji">
        <h2 class="post-title">Ajax-复习笔记</h2>
      </a>
      <div class="post-info">
        <span>
          2017-04-13
        </span>
        <span>
          7 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        <p><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#ajax">Ajax</a>
<ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-get">数据请求 Get</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BAajax%E8%AF%B7%E6%B1%82%E5%AF%B9%E8%B1%A1">创建ajax请求对象</a></li>
<li><a href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82">发送请求</a></li>
</ul>
</li>
<li><a href="#xmlhttprequest-readystate%E7%8A%B6%E6%80%81%E8%A1%A8">XMLHttpRequest readyState状态表</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82-post">数据请求 Post</a></li>
</ul>
</li>
<li><a href="#jquery-ajax">JQuery Ajax</a>
<ul>
<li><a href="#%E5%BA%95%E5%B1%82ajax%E5%86%99%E6%B3%95">底层ajax写法</a></li>
<li><a href="#get%E8%AF%B7%E6%B1%82">get请求</a></li>
<li><a href="#post%E8%AF%B7%E6%B1%82">post请求</a></li>
<li><a href="#%E8%8E%B7%E5%8F%96json%E6%95%B0%E6%8D%AE%E4%B8%93%E7%94%A8%E6%96%B9%E6%B3%95">获取JSON数据专用方法</a></li>
</ul>
</li>
<li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E6%96%B9%E5%BC%8F">服务器和客户端数据传输的方式</a>
<ul>
<li><a href="#xml">xml</a></li>
<li><a href="#json">json</a>
<ul>
<li><a href="#%E5%89%8D%E7%AB%AFjson%E6%93%8D%E4%BD%9C">前端json操作</a></li>
<li><a href="#%E5%90%8E%E5%8F%B0json%E6%93%8D%E4%BD%9C%E5%BA%93">后台json操作库</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a>
<ul>
<li><a href="#ajax-2">Ajax</a></li>
<li><a href="#jquery">JQuery</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</p>
<h2 id="ajax">Ajax</h2>
<ul>
<li>是什么?</li>
</ul>
<blockquote>
<p>“Asynchronous Javascript And XML”（异步JavaScript和XML），</p>
</blockquote>
<blockquote>
<p>并不是新的技术，只是把原有的技术，整合到一起而已。</p>
</blockquote>
<pre><code>1.使用CSS和XHTML来表示。
2.使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
</code></pre>
<ul>
<li>有什么用?</li>
</ul>
<blockquote>
<p>咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。  就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。</p>
</blockquote>
<h3 id="数据请求-get">数据请求 Get</h3>
<h4 id="创建ajax请求对象">创建ajax请求对象</h4>
<pre><code class="language-javascript">function  ajaxFunction(){
	    var xmlHttp;
	    try{ // Firefox, Chrome, Opera 8.0+, Safari
	        xmlHttp=new XMLHttpRequest();
	    }
	    catch (e){
	        try{// Internet Explorer（高版本）
	            xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);
	        }
	        catch (e){
	            try{// Internet Explorer（低版本）
	                xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);
	            }
	            catch (e){}
	        }
	    }
	    return xmlHttp;
	}
</code></pre>
<h4 id="发送请求">发送请求</h4>
<pre><code class="language-javascript">//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 发送请求。
    /*	
	 *	参数一： 请求类型  GET or  POST
	 *	参数二： 请求的路径
	 *	参数三： 是否异步， true  or false
	 */
    request.open(&quot;GET&quot; ,&quot;TestServlet&quot; ,true );
    request.send();
}



// 如果发送请求的同时，还想获取数据，那么代码如下

//执行get请求
function get() {

    //1. 创建xmlhttprequest 对象
    var request = ajaxFunction();

    //2. 设置请求参数
    request.open(&quot;GET&quot; ,&quot;TestServlet?name=aa&amp;age=18&quot; ,true );

    //3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
    request.onreadystatechange = function(){
        // readyState的值一共有5个状态，参见下表
        // readyState == 4 表示请求已经完成， 再判断状态码是否是200，200表示服务端正常响应(没有报错)
        if(request.readyState == 4 &amp;&amp; request.status == 200){
            //弹出响应的信息
            alert(request.responseText);
        }
    }
    
    // 4. 发送请求
    request.send();
}
</code></pre>
<h3 id="xmlhttprequest-readystate状态表">XMLHttpRequest readyState状态表</h3>
<table>
<thead>
<tr>
<th>值</th>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>0</code></td>
<td><code>UNSENT</code></td>
<td>代理被创建，但尚未调用 open() 方法。</td>
</tr>
<tr>
<td><code>1</code></td>
<td><code>OPENED</code></td>
<td><code>open()</code> 方法已经被调用。</td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>HEADERS_RECEIVED</code></td>
<td><code>send()</code> 方法已经被调用，并且头部和状态已经可获得。</td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>LOADING</code></td>
<td>请求中； <code>responseText</code> 属性已经包含部分数据。</td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>DONE</code></td>
<td>请求完成。</td>
</tr>
</tbody>
</table>
<h3 id="数据请求-post">数据请求 Post</h3>
<pre><code class="language-javascript">&lt;script type=&quot;text/javascript&quot;&gt;
	//1. 创建对象
	// 和get请求一样
	
	function post() {
		//1. 创建请求对象
		var request = ajaxFunction();
		
		// 2. 设置请求地址、参数、类型(post、get)
		request.open(&quot;post&quot;, &quot;StudentServlet&quot;, true);
		
		//3. 获取响应数据 注册监听的意思。  一会准备的状态发生了改变，那么就执行 = 号右边的方法
	    request.onreadystatechange = function(){
	        //前半段表示 已经能够正常处理。  再判断状态码是否是200
	        if(request.readyState == 4 &amp;&amp; request.status == 200){
	            //弹出响应的信息
	            console.log(&quot;请求完成&quot;);
	            var h1 = document.getElementById(&quot;h1&quot;);
	        	h1.innerHTML = request.responseText;
	        }
	    }
		
	 	// 4. 如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据
		request.setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;);
		
		// 5. 发送请求
    	// 如果是GET请求，参数写在这里是无效的
		request.send(&quot;id=555&quot;);
	}

&lt;/script&gt;
</code></pre>
<h2 id="jquery-ajax">JQuery Ajax</h2>
<h3 id="底层ajax写法">底层ajax写法</h3>
<pre><code class="language-javascript">// 语法：$.ajax(url, [settings]);

$.ajax(&quot;TestServlet&quot;, {
    type: &quot;GET&quot;,
    data: {
        action: &quot;json&quot;,
        uname: &quot;zhangsan&quot;
    },
    dataType: &quot;json&quot;,
    success: function(data, status_text){
        console.log(data);
        console.log(&quot;status_text: &quot; + status_text);
    },
    error: function(xhr, textStatus, errorThrow) {
        console.log(&quot;请求失败&quot;);
    }
});
</code></pre>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">所</mi><mi mathvariant="normal">有</mi><mi>a</mi><mi>j</mi><mi>a</mi><mi>x</mi><mi mathvariant="normal">相</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">底</mi><mi mathvariant="normal">层</mi><mi mathvariant="normal">实</mi><mi mathvariant="normal">现</mi><mi mathvariant="normal">，</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">都</mi><mi mathvariant="normal">是</mi><mi mathvariant="normal">在</mi><mi mathvariant="normal">它</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">基</mi><mi mathvariant="normal">础</mi><mi mathvariant="normal">上</mi><mi mathvariant="normal">给</mi><mi mathvariant="normal">我</mi><mi mathvariant="normal">们</mi><mi mathvariant="normal">封</mi><mi mathvariant="normal">装</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">更</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">便</mi><mi mathvariant="normal">使</mi><mi mathvariant="normal">用</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">方</mi><mi mathvariant="normal">法</mi><mi mathvariant="normal">。</mi><mi mathvariant="normal">关</mi><mi mathvariant="normal">于</mi></mrow><annotation encoding="application/x-tex">.ajax方法是其他所有ajax相关方法的底层实现，其他方法都是在它的基础上给我们封装的更方便使用的方法。 关于</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">所</span><span class="mord cjk_fallback">有</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mord cjk_fallback">相</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">底</span><span class="mord cjk_fallback">层</span><span class="mord cjk_fallback">实</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">都</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">在</span><span class="mord cjk_fallback">它</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">础</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">给</span><span class="mord cjk_fallback">我</span><span class="mord cjk_fallback">们</span><span class="mord cjk_fallback">封</span><span class="mord cjk_fallback">装</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">更</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">便</span><span class="mord cjk_fallback">使</span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">方</span><span class="mord cjk_fallback">法</span><span class="mord cjk_fallback">。</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">于</span></span></span></span>.ajax的详细介绍参见 <a href="http://jquery.cuishifeng.cn/jQuery.Ajax.html">http://jquery.cuishifeng.cn/jQuery.Ajax.html</a></p>
</blockquote>
<h3 id="get请求">get请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.get( &quot;url&quot;,{pid:pid} ,function(data,status_text){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="post请求">post请求</h3>
<pre><code class="language-javascript">/*
 * 参数：
 *  url: 请求地址
 *  data: 待发送 Key/value 参数
 *  fn: 请求成功后回调函数
 *  type: 返回内容格式，xml, html, script, json, text, _default
 */

$.post( &quot;url&quot;,{pid:pid} ,function(data,status){
    console.log(data);
    console.log(&quot;status_text: &quot; + status_text);
},&quot;json&quot; );	// 指定请求返回的格式是json，jquery会帮我们把服务端返回的json字符串转换成js的json对象
</code></pre>
<h3 id="获取json数据专用方法">获取JSON数据专用方法</h3>
<pre><code class="language-javascript">$.getJSON(&quot;url&quot;, {id:1, name: &quot;zhangsan&quot;} function(json){
  console.log(json);
});
</code></pre>
<h2 id="服务器和客户端数据传输的方式">服务器和客户端数据传输的方式</h2>
<h3 id="xml">xml</h3>
<p>因为无效数据占比太大，阅读困难。基本已经被json格式淘汰掉了</p>
<pre><code class="language-xml">  	&lt;list&gt;
        &lt;city&gt;
        &lt;id&gt;1&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;深圳&lt;/cname&gt;
        &lt;/city&gt;
        &lt;city &gt;
        &lt;id&gt;2&lt;id&gt;
        &lt;pid&gt;1&lt;/pid&gt;
        &lt;cname&gt;东莞&lt;/cname&gt;
        &lt;/city&gt;
    &lt;/list&gt;

</code></pre>
<h3 id="json">json</h3>
<p>阅读性更好 、 占用空间更小。</p>
<pre><code class="language-json">[{city:{id:1, pid:1, cname:&quot;深圳&quot;}}, {city:{id:2, pid:1, cname:&quot;东莞&quot;}}]

</code></pre>
<h4 id="前端json操作">前端json操作</h4>
<pre><code class="language-js">JSON.parse(jsonStr); // 将JSON字符串转成js对象
JSON.stringify(obj);  // 将js对象转成JSON字符串

</code></pre>
<h4 id="后台json操作库">后台json操作库</h4>
<ul>
<li>
<p>fastjson库</p>
<p>JSON.toJSONString();	// 将JavaBean encode成 json string<br>
JSON.parseObject();		// 将json对象decode成javabean<br>
JSON.parseArray();		// 将json数组decode成java List或 JSONArray类型</p>
</li>
<li>
<p>Gson库</p>
</li>
<li>
<p>Jackson库</p>
</li>
<li>
<p>...</p>
</li>
</ul>
<h2 id="总结">总结</h2>
<h3 id="ajax-2">Ajax</h3>
<ul>
<li>创建异步请求对象的方法</li>
<li>发起异步GET请求的步骤</li>
<li>发起异步POST请求的步骤</li>
<li>异步POST请求与GET请求的对比</li>
</ul>
<h3 id="jquery">JQuery</h3>
<ul>
<li>$.ajax()</li>
<li>$.get()</li>
<li>$.post()</li>
<li>$.getJSON()</li>
<li>jQuery中各个ajax方法之间的区别和联系</li>
</ul>

      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/jquery">
        <h2 class="post-title">JQuery</h2>
      </a>
      <div class="post-info">
        <span>
          2017-03-21
        </span>
        <span>
          14 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/cong-windows-guo-du-dao-mac-bi-bei-kuai-jie-jian-dui-zhao-biao">
        <h2 class="post-title">从 Windows 过度到 Mac 必备快捷键对照表</h2>
      </a>
      <div class="post-info">
        <span>
          2017-03-16
        </span>
        <span>
          9 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/java-shi-jian-lei-api">
        <h2 class="post-title">Java时间类API</h2>
      </a>
      <div class="post-info">
        <span>
          2017-02-15
        </span>
        <span>
          1 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
    <article class="post">
      <a href="https://cxp-twx.github.io/post/23-chong-she-ji-mo-shi-gai-nian">
        <h2 class="post-title">23种设计模式概念</h2>
      </a>
      <div class="post-info">
        <span>
          2017-02-01
        </span>
        <span>
          19 min read
        </span>
        
      </div>
      
      <div class="post-abstract">
        
      </div>
    </article>
  
</div>

    
        <div class="pagination-container">
  
    <a href="https://cxp-twx.github.io/page/2/" class="prev-page">上一页</a>
  
  
    <a href="https://cxp-twx.github.io/page/4/" class="next-page">下一页</a>
  
</div>

    
        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://cxp-twx.github.io/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
